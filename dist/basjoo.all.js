 (function() { // webpackBootstrap
 	"use strict";
 	var __webpack_modules__ = ({

/***/ "./ts/dash/DashTVPlayer.ts":
/*!*********************************!*\
  !*** ./ts/dash/DashTVPlayer.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashTVPlayer": function() { return /* binding */ DashTVPlayer; }
/* harmony export */ });
/* harmony import */ var _streaming_AbrController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./streaming/AbrController */ "./ts/dash/streaming/AbrController.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _core_EventBus__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/EventBus */ "./ts/dash/core/EventBus.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/Utils */ "./ts/dash/core/Utils.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _streaming_MetricsModel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./streaming/MetricsModel */ "./ts/dash/streaming/MetricsModel.ts");
/* harmony import */ var _streaming_VideoModel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./streaming/VideoModel */ "./ts/dash/streaming/VideoModel.ts");
/* harmony import */ var _streaming_StreamController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./streaming/StreamController */ "./ts/dash/streaming/StreamController.ts");
/* harmony import */ var _ttml_TTMLRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ttml/TTMLRenderer */ "./ts/dash/ttml/TTMLRenderer.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */










/**
 * DashTVPlayer
 *
 * @module DashTVPlayer（インターフェースモジュール）
 */
/**
 * DashTVPlayer
 * @constructor
 */
var DashTVPlayer = /** @class */ (function () {
    function DashTVPlayer(view) {
        var _this = this;
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.xhrCustom = null;
        /**
         * 再生に必要な情報が揃っているかの判定
         * @param (なし)
         * @return {boolean} 判定値
         */
        this.isReady = function () { return _this.element != null && _this.source != null; };
        /**
         * MediaSourceのサポート判定
         * @return {boolean} 判定地
         */
        this.supportsMediaSource = function () {
            var hasWebKit = 'WebKitMediaSource' in window;
            var hasMediaSource = 'MediaSource' in window;
            return hasWebKit || hasMediaSource;
        };
        /**
         * メディアの再生
         * @return (なし)
         */
        this.play = function () {
            if (!_this.supportsMediaSource.call(_this)) {
                _this.errHandler.capabilityError(_this.eventBus, 'mediasource');
                return;
            }
            if (_this.source && (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.source, 'params')) {
                _this.params = _this.source.params;
            }
            _this.playing = true;
            _this.xhrCustom =
                _this.source && (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.source, 'xhrCustom')
                    ? _this.source.xhrCustom
                    : {};
            _this.streamController = new _streaming_StreamController__WEBPACK_IMPORTED_MODULE_8__.StreamController(_this.params, _this.eventBus, _this.metricsModel, _this.abrController, _this.xhrCustom);
            _this.streamController.setVideoModel(_this.videoModel);
            _this.streamController.setUpMediaSource(_this.element);
            _this.streamController.setPresentationStartTime(_this.initialPresentationStartTime);
            _this.streamController.setPresentationEndTime(_this.initialPresentationEndTime);
            _this.streamController.setBandwidthLimit(_this.minBandwidth, _this.maxBandwidth);
            _this.streamController.setAutoPlay(_this.autoPlay);
            _this.streamController.load(_this.source);
        };
        this.VERSION = '1.9.10';
        this.DEPLOY_DATE = 'ver.2022/3/31 11:12:21';
        this.params = {};
        this.element = view;
        this.playing = false;
        this.autoPlay = true;
        this.eventBus = new _core_EventBus__WEBPACK_IMPORTED_MODULE_3__.EventBus();
        this.NXDebug = DashTVPlayer.Debug;
        this.metricsModel = new _streaming_MetricsModel__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.abrController = new _streaming_AbrController__WEBPACK_IMPORTED_MODULE_0__.AbrController();
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.videoModel =
            this.element != null
                ? new _streaming_VideoModel__WEBPACK_IMPORTED_MODULE_7__["default"](this.element, this.eventBus)
                : new _streaming_VideoModel__WEBPACK_IMPORTED_MODULE_7__.DummyVideoModel(this.element, this.eventBus);
        this.xhrCustom = null;
        this.initialPresentationStartTime = NaN;
        this.initialPresentationEndTime = NaN;
        this.minBandwidth = {
            video: NaN,
            audio: NaN,
        };
        this.maxBandwidth = {
            video: NaN,
            audio: NaN,
        };
        DashTVPlayer.LogHandler.log(this.DEPLOY_DATE);
        DashTVPlayer.LogHandler.log_item('player_version', this.DEPLOY_DATE + ' / ' + this.VERSION);
    }
    /**
     * 自動再生の設定 isReadyの状態で判断
     * @return (なし)
     */
    //NSV-a const doAutoPlay = () => {
    //NSV-a   if (isReady()) {
    //NSV-a     play.call(this);
    //NSV-a   }
    //NSV-a };
    /**
     * 内部のEventBusにハンドラを登録
     * @param {string} type - イベントの種別
     * @param {function} listener - イベントを処理する関数
     * @param {boolean} useCapture - captureフラグ
     * @return (なし)
     */
    DashTVPlayer.prototype.addEventListener = function (type, listener, useCapture) {
        //this.
        this.eventBus.addEventListener(type, listener, useCapture);
    };
    /**
     * 内部のEventBusに登録したハンドラを解除
     * @param {string} type - イベントの種別
     * @param {function} listener - イベントを処理する関数
     * @param {boolean} useCapture - captureフラグ
     */
    DashTVPlayer.prototype.removeEventListener = function (type, listener, useCapture) {
        //this.
        this.eventBus.removeEventListener(type, listener, useCapture);
    };
    /**
     * バージョンの取得
     * @this DashTVPlayer
     * @return バージョン
     */
    DashTVPlayer.prototype.getVersion = function () {
        return this.VERSION;
    };
    /**
     * デバッグ情報の出力先の取得
     * @return デバッグ情報出力用オブジェクト
     */
    DashTVPlayer.prototype.getDebug = function () {
        return this.NXDebug;
    };
    /**
     * ビデオ処理用インスタンスを参照する
     * @return ビデオ処理用インスタンス
     */
    DashTVPlayer.prototype.getVideoModel = function () {
        return this.videoModel;
    };
    /**
     * AutoPlayの設定
     * @param {boolean} value - trueで自動再生on/falseで自動再生off
     * @return (なし)
     */
    DashTVPlayer.prototype.setAutoPlay = function (value) {
        this.autoPlay = value;
    };
    /**
     * AutoPlayが設定されていればtrueを返す。
     * @return {boolean} true/false
     */
    DashTVPlayer.prototype.getAutoPlay = function () {
        return this.autoPlay;
    };
    /**
     * mpdの種別がdynamicであればtrueを返す。
     * @return {boolean} true/false
     */
    DashTVPlayer.prototype.getIsDynamic = function () {
        return this.streamController.getIsDynamic();
    };
    /**
     * 全ピリオド情報の取得
     * @return {array} 全ピリオド情報
     */
    DashTVPlayer.prototype.getPeriodInfo = function () {
        return this.streamController.getPeriodInfo();
    };
    /**
     * インデックスを指定してピリオド情報を取得
     * @param {int} idx - ピリオドのインデックス
     * @return {period} ピリオド情報
     */
    DashTVPlayer.prototype.getPeriodInfoForIdx = function (idx) {
        return this.streamController.getPeriodInfoForIdx(idx);
    };
    /**
     * 時刻指定して該当ピリオドのインデックスを取得
     * @param {float} time - 取得したいピリオドの時刻（秒）を指定
     * @return {int} ピリオドのインデックス
     */
    DashTVPlayer.prototype.getPeriodIdxForTime = function (time) {
        return this.streamController.getPeriodIdxForTime(time);
    };
    /**
     * 再生中のピリオドのインデックスを取得
     * @return {int} ピリオドのインデックス
     */
    DashTVPlayer.prototype.getCurrentPlayingPeriodIdx = function () {
        var ctime = this.videoModel.getCurrentTime();
        //return streamController.getCurrentPlayingPeriodIdx();
        return this.streamController.getPeriodIdxForTime(ctime);
    };
    /**
     * 指定されたピリオドのBaseURLのインデックスを取得
     * @param {int} idx - ピリオドのインデックス
     * @return {int} BaseURLのインデックス
     */
    DashTVPlayer.prototype.getBaseURLIdxFor = function (idx) {
        return this.streamController.getBaseURLIdxFor(idx);
    };
    /**
     * 指定されたピリオドのBaseURLのインデックスの最大値を取得
     * @param {int} idx - ピリオドのインデックス
     * @return {int} BaseURLのインデックスの最大値
     */
    DashTVPlayer.prototype.getMaxBaseURLIdxFor = function (idx) {
        return this.streamController.getMaxBaseURLIdxFor(idx);
    };
    /**
     * 指定されたピリオドのBaseURLのインデックスを設定
     * @param {int} periodIdx - ピリオドのインデックス
     * @param {int} idx - BaseURLのインデックス
     * @return (なし)
     */
    DashTVPlayer.prototype.setBaseURLIdxFor = function (periodIdx, idx) {
        this.streamController.setBaseURLIdxFor(periodIdx, idx);
    };
    /**
     * 指定された種別のアダプテーションのインデックスの取得
     * @param {string} type - "video" または "audio"
     * @return {int} アダプテーションインデックス 種別が誤りの場合-1
     */
    DashTVPlayer.prototype.getCurrentAdaptationIdxFor = function (type) {
        return this.streamController.getCurrentAdaptationIdxFor(type);
    };
    /**
     * アダプテーションインデックスの指定
     * @param {string} type - "video" または "audio"
     * @param {int} idx - インデックス
     * @return (なし)
     */
    DashTVPlayer.prototype.setAdaptationIdxFor = function (type, idx) {
        this.streamController.setAdaptationIdxFor(type, idx);
    };
    /**
     * アダプテーションのRole指定
     * @param {string} type - "video" または "audio"
     * @param {string} value - Roleのvalue値
     * @return (なし)
     */
    DashTVPlayer.prototype.setAdaptationRoleFor = function (type, value) {
        this.streamController.setAdaptationRoleFor(type, value);
    };
    /**
     * 指定したピリオドの先頭に遷移する
     * @param {int} value - 遷移したいピリオドのインデックス
     * @return (なし)
     */
    DashTVPlayer.prototype.setCueingPeriodIdx = function (value) {
        this.streamController.setCueingPeriodIdx(value);
    };
    /**
     * メトリックスのインスタンスを取得
     * @return MetricsModelのインスタンス
     */
    DashTVPlayer.prototype.getMetricsExt = function () {
        //return this.metricsModel;
        return this.metricsModel;
    };
    /**
     * getMetricsFor
     * @param {string} type - メディア種別('video'または'audio')
     * @return ??
     */
    DashTVPlayer.prototype.getMetricsFor = function (type) {
        //const metrics = this.metricsModel.getReadOnlyMetricsFor(type);
        var metrics = this.metricsModel.getMetricsFor(type);
        return metrics;
    };
    /**
     * 指定した種別の最大品質を指すインデックス値の取得
     * @param {string} type - メディア種別('video'または'audio')
     * @return {int} 最大品質を指すインデックス値
     */
    DashTVPlayer.prototype.getMaxQualityIndexFor = function (type) {
        return this.abrController.getMaxQualityIndexFor(type);
    };
    /**
     * 指定した種別の現在の品質指すインデックス値の取得
     * @param {string} type - メディア種別('video'または'audio')
     * @return {int} 現在の品質を指すインデックス値
     */
    DashTVPlayer.prototype.getQualityFor = function (type) {
        return this.abrController.getQualityFor(type);
    };
    /**
     * 指定した種別の品質インデックスを指定する
     * @param {string} type - メディア種別('video'または'audio')
     * @param {int} value 品質を指すインデックス値
     */
    DashTVPlayer.prototype.setQualityFor = function (type, value) {
        this.abrController.setPlaybackQuality(type, value);
    };
    /**
     * 指定した種別の現在の品質指すインデックス値の取得
     * @param {string} type - メディア種別('video'または'audio')
     * @return {int} 現在の品質を指すインデックス値
     */
    DashTVPlayer.prototype.getDefaultQualityFor = function (type) {
        return this.abrController.getDefaultQualityFor(type);
    };
    /**
     * 指定した種別の品質のインデックスのデフォルト値を指定する
     * @param {string} type - メディア種別('video'または'audio')
     * @param {int} value 品質を指すインデックス値
     */
    DashTVPlayer.prototype.setDefaultQualityFor = function (type, value) {
        this.abrController.setDefaultPlaybackQuality(type, value);
        this.abrController.setPlaybackQuality(type, value);
    };
    /**
     * 指定したメディア種別のビットレートの最小値を設定する。
     * MPD内の設定値より小さいbandwidthのrepresentationは除外します。
     * (すべてが設定値より小さい場合はその中で最大の値を選択します。)
     * @param {string} type - メディア種別('video'または'audio')
     * @param {int} value - ビットレート値(bps)
     * @return (なし)
     */
    DashTVPlayer.prototype.setMinBandwidthFor = function (type, value) {
        this.minBandwidth[type] = value;
    };
    /**
     * 指定したメディア種別のビットレートの最大値を設定する。
     * MPD内の設定値より大きいbandwidthのrepresentationは除外します。
     * (すべてが設定値より大きい場合はその中で最小の値を選択します。)
     * @param {string} type - メディア種別('video'または'audio')
     * @param {int} value - ビットレート値(bps)
     * @return (なし)
     */
    DashTVPlayer.prototype.setMaxBandwidthFor = function (type, value) {
        this.maxBandwidth[type] = value;
    };
    /**
     * ABR機能の設定値を取得
     * @return {boolean} true(ABR機能ON)/false(ABR機能OFF)
     */
    DashTVPlayer.prototype.getAutoSwitchQuality = function () {
        return this.abrController.getAutoSwitchBitrate();
    };
    /**
     * 指定したメディア種別のソースバッファを取得する。
     * @param {string} type - メディア種別('video'または'audio')
     * @return (SourceBuffer)
     */
    DashTVPlayer.prototype.getBufferFor = function (type) {
        return this.streamController.getBufferFor(type);
    };
    /**
     * メディアソースのreadyStateを取得する。
     * @return (string)
     */
    DashTVPlayer.prototype.getMediaSourceReadyState = function () {
        return this.streamController.getMediaSourceReadyState();
    };
    /**
     * ABR機能を設定する
     * @param {boolean} value - true(ABR機能ON)/false(ABR機能OFF)
     * @return (なし)
     */
    DashTVPlayer.prototype.setAutoSwitchQuality = function (value) {
        this.abrController.setAutoSwitchBitrate(value);
    };
    /**
     * DashTVPlayerにvideo要素を紐付ける
     * @param {video_element}
     * @return (なし)
     */
    DashTVPlayer.prototype.attachView = function (view) {
        this.element = view;
        if (this.element) {
            var status_1 = null;
            if (this.videoModel != null && this.videoModel.isDummy()) {
                status_1 = this.videoModel.getCurrentStatus();
            }
            this.videoModel = new _streaming_VideoModel__WEBPACK_IMPORTED_MODULE_7__["default"](this.element, this.eventBus);
            if (status_1 != null) {
                this.videoModel.setCurrentStatus(status_1);
            }
            this.streamController.updateVideoModel(this.videoModel);
        }
        else {
            this.videoModel = null;
        }
    };
    /**
     * 再生するコンテンツの情報を設定
     * @param {string} _source - 再生コンテンツURL
     * @param {float} start (省略化) - 再生開始時刻
     * @param {float} end (省略化) - 再生終了時刻
     */
    DashTVPlayer.prototype.attachSource = function (_source, start, end) {
        this.initialPresentationStartTime = start >= 0 ? start : NaN;
        this.initialPresentationEndTime = end || NaN;
        this.source = _source;
        if (this.playing && this.streamController) {
            DashTVPlayer.LogHandler.clearLogs();
            this.streamController.reset();
            this.streamController = null;
            this.playing = false;
        }
        if (this.source != null) {
            if (!this.videoModel.isDummy()) {
                this.videoModel.checkCanplaythrough();
                if (this.isReady()) {
                    this.play.call(this);
                }
            }
            else {
                this.play.call(this);
            }
        }
    };
    /**
     * マニフェスト情報を直接指定する
     * @param {text} url - セグメントファイルのbaseurl
     * @param {xml} data - マニフェスト情報
     */
    DashTVPlayer.prototype.setManifestFromExt = function (url, data) {
        this.streamController.setManifestFromExt(url, data);
    };
    /**
     * プレーヤをリセットする
     * @return (なし)
     */
    DashTVPlayer.prototype.reset = function () {
        this.attachSource(null);
        this.attachView(null);
        this.minBandwidth = {
            video: NaN,
            audio: NaN,
        };
        this.maxBandwidth = {
            video: NaN,
            audio: NaN,
        };
    };
    /**
     * 再生時刻（先頭からの時間）の指定
     * @param {float} value - コンテンツ開始からvalue秒指定
     * @return (なし)
     */
    DashTVPlayer.prototype.setCurrentTime = function (value) {
        var currentTime = this.videoModel.getCurrentTime();
        var mediaDur = this.videoModel.getDuration();
        var seekTime = value;
        if (seekTime < 0) {
            seekTime = 0;
        }
        else if (seekTime > mediaDur) {
            seekTime = mediaDur;
        }
        else {
            // eslint-disable-line no-empty
        }
        DashTVPlayer.LogHandler.log('*** SEEK: ' + value + ' [' + currentTime + '] -> [' + seekTime + ']');
        this.NXDebug.log('*** SEEK: ' + value + ' [' + currentTime + '] -> [' + seekTime + ']');
        if (!this.videoModel.isDummy()) {
            if (!this.videoModel.isPaused()) {
                this.setPause();
            }
            this.videoModel.setCurrentTime(seekTime);
        }
        else {
            this.streamController.seek(seekTime);
        }
    };
    DashTVPlayer.prototype.getBufferState = function () {
        return this.streamController.getBufferState();
    };
    /**
     * 再生時刻のシーク値(delta)の指定
     * @param {float} value - 再生中時刻から＋/-dalta秒指定してシーク
     * @param {boolean} _silent - シーク後のイベント処理をスキップするか否か
     * @return (なし)
     */
    DashTVPlayer.prototype.setCurrentTimeDelta = function (value, _silent) {
        var currentTime = this.videoModel.getCurrentTime();
        var mediaDur = this.videoModel.getDuration();
        var silent = _silent || false;
        var seekTime = currentTime + value;
        if (seekTime < 0) {
            seekTime = 0;
        }
        else if (seekTime > mediaDur) {
            seekTime = mediaDur;
        }
        else {
            // eslint-disable-line no-empty
        }
        DashTVPlayer.LogHandler.log('*** SEEK: ' + value + ' [' + currentTime + '] -> [' + seekTime + ']');
        this.NXDebug.log('*** SEEK: ' + value + ' [' + currentTime + '] -> [' + seekTime + ']');
        if (!this.videoModel.isDummy()) {
            if (silent) {
                this.videoModel.silentSeek(seekTime);
            }
            else {
                if (!this.videoModel.isPaused()) {
                    this.setPause();
                }
                this.videoModel.setCurrentTime(seekTime);
            }
        }
        else {
            this.streamController.seek(seekTime);
        }
    };
    /**
     * 再生時刻のオフセット指定
     * @param {float} value - 再生中時刻から＋value秒指定して再生
     * @return (なし)
     */
    DashTVPlayer.prototype.setSeekTime = function (value) {
        var currentTime = this.videoModel.getCurrentTime();
        var mediaDur = this.videoModel.getDuration();
        var seekTime = currentTime + value;
        if (seekTime < 0) {
            seekTime = 0;
        }
        else if (seekTime > mediaDur) {
            seekTime = mediaDur;
        }
        else {
            // eslint-disable-line no-empty
        }
        DashTVPlayer.LogHandler.log('*** SEEK: ' + value + ' [' + currentTime + '] -> [' + seekTime + ']');
        this.NXDebug.log('*** SEEK: ' + value + ' [' + currentTime + '] -> [' + seekTime + ']');
        if (!this.videoModel.isDummy()) {
            if (!this.videoModel.isPaused()) {
                this.setPause();
            }
            this.videoModel.setCurrentTime(seekTime);
        }
        else {
            this.streamController.seek(seekTime);
        }
    };
    DashTVPlayer.prototype.getCurrentManifestData = function () {
        return this.streamController.getCurrentManifestData();
    };
    /**
     * 一時停止状態にする
     * @param {boolean} _manual - manual pause を指定する 省略時はtrue
     * @return (なし)
     */
    DashTVPlayer.prototype.setPause = function (_manual) {
        var manual = _manual || true;
        this.streamController.pause(manual);
    };
    /**
     * 再生状態にする
     * @param {boolean} _manual - manual pause を指定する 省略時はtrue
     * @return (なし)
     */
    DashTVPlayer.prototype.setPlay = function (_manual) {
        var manual = _manual || true;
        this.streamController.play(manual);
    };
    /**
     * コンテンツの再生を終了する
     * @return (なし)
     */
    DashTVPlayer.prototype.end = function () {
        if (this.streamController) {
            this.streamController.end();
        }
    };
    /**
     * 再生開始時刻を指定する
     * @param  {float} value - 再生開始時刻（秒）
     * @return (なし)
     */
    DashTVPlayer.prototype.setPresentationStartTime = function (value) {
        this.initialPresentationStartTime = value;
    };
    DashTVPlayer.prototype.setDebugMode = function (mode) {
        this.NXDebug.setMode(mode);
    };
    DashTVPlayer.prototype.getDebugMode = function () {
        return this.NXDebug.getMode();
    };
    DashTVPlayer.Debug = new _core_Debug__WEBPACK_IMPORTED_MODULE_1__["default"]();
    DashTVPlayer.LogHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_5__["default"];
    DashTVPlayer.ttml_renderer = _ttml_TTMLRenderer__WEBPACK_IMPORTED_MODULE_9__.ttml_renderer;
    return DashTVPlayer;
}());



/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ts_dash_DashTVPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ts/dash/DashTVPlayer */ "./ts/dash/DashTVPlayer.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

console.dir(_ts_dash_DashTVPlayer__WEBPACK_IMPORTED_MODULE_0__.DashTVPlayer);
window.DashTVPlayer = _ts_dash_DashTVPlayer__WEBPACK_IMPORTED_MODULE_0__.DashTVPlayer;


/***/ }),

/***/ "./ts/dash/core/Base64.ts":
/*!********************************!*\
  !*** ./ts/dash/core/Base64.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE64": function() { return /* binding */ BASE64; }
/* harmony export */ });
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * BASE64
 *
 * @module BASE64（BASE64モジュール）
 */
/* istanbul ignore next*/
var utf8_decode = function (enc_input) {
    var decode_out = '';
    var chr = null;
    for (var i = 0; i < enc_input.length;) {
        chr = enc_input[i++];
        if (chr < 0x80) {
            //asis
        }
        else if (chr < 0xe0) {
            chr = ((0x1f & chr) << 6) | (0x3f & enc_input[i++]);
        }
        else if (chr < 0xf0) {
            chr =
                ((0xf & chr) << 12) |
                    ((0x3f & enc_input[i++]) << 6) |
                    (0x3f & enc_input[i++]);
        }
        else if (chr < 0xf8) {
            chr =
                ((0x7 & chr) << 18) |
                    ((0x3f & enc_input[i++]) << 12) |
                    ((0x3f & enc_input[i++]) << 6) |
                    (0x3f & enc_input[i++]);
        }
        else if (chr < 0xfc) {
            chr =
                ((0x3 & chr) << 24) |
                    ((0x3f & enc_input[i++]) << 18) |
                    ((0x3f & enc_input[i++]) << 12) |
                    ((0x3f & enc_input[i++]) << 6) |
                    (0x3f & enc_input[i++]);
        }
        else {
            chr =
                ((0x1 & chr) << 30) |
                    ((0x3f & enc_input[i++]) << 24) |
                    ((0x3f & enc_input[i++]) << 18) |
                    ((0x3f & enc_input[i++]) << 12) |
                    ((0x3f & enc_input[i++]) << 6) |
                    (0x3f & enc_input[i++]);
        }
        decode_out = decode_out + String.fromCharCode(chr);
    }
    return decode_out;
};
/* istanbul ignore next*/
var decodeArray = function (enc_input) {
    var strtbl = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var decode_out = [];
    var c1;
    var c2;
    var c3;
    var c4;
    var b1;
    var b2;
    var b3;
    for (var i = 0; i < enc_input.length;) {
        c1 = strtbl.indexOf(enc_input.charAt(i++));
        c2 = strtbl.indexOf(enc_input.charAt(i++));
        c3 = strtbl.indexOf(enc_input.charAt(i++));
        c4 = strtbl.indexOf(enc_input.charAt(i++));
        if (c4 != 64) {
            b1 = (c1 << 2) | (c2 >> 4);
            b2 = ((c2 & 0xf) << 4) | (c3 >> 2);
            b3 = ((c3 & 0x3) << 6) | c4;
            decode_out.push(0xff & b1);
            decode_out.push(0xff & b2);
            decode_out.push(0xff & b3);
        }
        else if (c3 != 64) {
            b1 = (c1 << 2) | (c2 >> 4);
            b2 = ((c2 & 0xf) << 4) | (c3 >> 2);
            decode_out.push(0xff & b1);
            decode_out.push(0xff & b2);
        }
        else {
            b1 = (c1 << 2) | (c2 >> 4);
            decode_out.push(0xff & b1);
        }
    }
    return decode_out;
};
/**
 * BASE64
 * @constructor
 */
/* istanbul ignore next*/
var BASE64 = {
    decodeArray: function (s) {
        return new Uint8Array(decodeArray(s));
    },
    decode: function (s) {
        return utf8_decode(decodeArray(s));
    },
};


/***/ }),

/***/ "./ts/dash/core/Debug.ts":
/*!*******************************!*\
  !*** ./ts/dash/core/Debug.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_debug": function() { return /* binding */ _debug; },
/* harmony export */   "_error": function() { return /* binding */ _error; },
/* harmony export */   "_info": function() { return /* binding */ _info; },
/* harmony export */   "_log": function() { return /* binding */ _log; },
/* harmony export */   "_nullfunc": function() { return /* binding */ _nullfunc; },
/* harmony export */   "_warn": function() { return /* binding */ _warn; }
/* harmony export */ });
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Debug
 *
 * @module Debug（Debugモジュール）
 */
var _log = function (msg) {
    console.log(msg);
};
var _debug = function (msg) {
    console.debug(msg);
};
var _info = function (msg) {
    console.info(msg);
};
var _warn = function (msg) {
    console.warn(msg);
};
var _error = function (msg) {
    console.error(msg);
};
var _nullfunc = function () { };
/**
 * Debug
 * @constructor
 */
var Debug = /** @class */ (function () {
    function Debug() {
        this.mode = {
            log: true,
            debug: true,
            info: true,
            warn: true,
            error: true,
        };
        this.log = _log;
        this.debug = _debug;
        this.info = _info;
        this.warn = _warn;
        this.error = _error;
        this.nullfunc = _nullfunc;
    }
    Debug.prototype.setMode = function (mode) {
        //            var that = this;
        for (var key in mode) {
            //            Object.keys(mode).forEach(function(key) {
            if (key == 'log') {
                if (mode[key]) {
                    this.log = _log;
                }
                else {
                    this.log = _nullfunc;
                }
                this.mode[key] = mode[key];
            }
            else if (key == 'debug') {
                if (mode[key]) {
                    this.debug = _debug;
                }
                else {
                    this.debug = _nullfunc;
                }
                this.mode[key] = mode[key];
            }
            else if (key == 'info') {
                if (mode[key]) {
                    this.info = _info;
                }
                else {
                    this.info = _nullfunc;
                }
                this.mode[key] = mode[key];
            }
            else if (key == 'warn') {
                if (mode[key]) {
                    this.warn = _warn;
                }
                else {
                    this.warn = _nullfunc;
                }
                this.mode[key] = mode[key];
            }
            else if (key == 'error') {
                if (mode[key]) {
                    this.error = _error;
                }
                else {
                    this.error = _nullfunc;
                }
                this.mode[key] = mode[key];
            }
        }
    };
    Debug.prototype.getMode = function () {
        return this.mode;
    };
    return Debug;
}());
/* harmony default export */ __webpack_exports__["default"] = (Debug);


/***/ }),

/***/ "./ts/dash/core/ErrorHandler.ts":
/*!**************************************!*\
  !*** ./ts/dash/core/ErrorHandler.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * ErrorHandler
 *
 * @module ErrorHandler（ErrorHandlerモジュール）
 */
/**
 * ErrorHandler
 * @constructor
 */
var ErrorHandler = {
    capabilityError: function (eventBus, err) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'capability',
            event: err,
        });
    },
    downloadError: function (eventBus, id, url, request, _request) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'download',
            event: {
                id: id,
                url: url,
                request: request,
                _request: _request,
            },
        });
    },
    manifestError: function (eventBus, message, id, manifest) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'manifestError',
            event: {
                message: message,
                id: id,
                manifest: manifest,
            },
        });
    },
    // closedCaptionsError(
    //   eventBus: EventBus,
    //   message: string,
    //   id: string,
    //   ccContent: any
    // ): void {
    //   eventBus.dispatchEvent({
    //     type: 'error',
    //     error: 'cc',
    //     event: {
    //       message,
    //       id,
    //       cc: ccContent,
    //     },
    //   });
    // },
    mediaSourceError: function (eventBus, err) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'mediasource',
            event: err,
        });
    },
    mediaKeySessionError: function (eventBus, err) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'key_session',
            event: err,
        });
    },
    mediaKeyMessageError: function (eventBus, err) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'key_message',
            event: err,
        });
    },
    mediaKeySystemSelectionError: function (eventBus, err) {
        eventBus.dispatchEvent({
            type: 'error',
            error: 'key_system_selection',
            event: err,
        });
    },
};
/* harmony default export */ __webpack_exports__["default"] = (ErrorHandler);


/***/ }),

/***/ "./ts/dash/core/EventBus.ts":
/*!**********************************!*\
  !*** ./ts/dash/core/EventBus.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventBus": function() { return /* binding */ EventBus; }
/* harmony export */ });
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * EventBus
 *
 * @module EventBus（EventBusモジュール）
 */
var EventBus = /** @class */ (function () {
    /**
     * EventBus
     * @constructor
     */
    function EventBus() {
        var _this = this;
        /**
         * EventListenerの取得
         * @param {string} type イベントの種類
         * @param {boolean} useCapture
         */
        this.getListeners = function (type, useCapture) {
            var captype = "".concat(useCapture ? '1' : '0').concat(type);
            if (!(captype in _this.registrations)) {
                _this.registrations[captype] = [];
            }
            return _this.registrations[captype];
        };
        /**
         * EventListenerの登録
         * @param {string} type イベントの種類
         * @param {NXEventListener} listener 登録する関数
         * @param {boolean} useCapture
         */
        this.addEventListener = function (type, listener, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var listeners = _this.getListeners(type, useCapture);
            var idx = listeners.indexOf(listener);
            if (idx === -1) {
                listeners.push(listener);
            }
        };
        /**
         * EventListenerの削除
         * @param {string} type イベントの種類
         * @param {NXEventListener} listener 削除する関数
         * @param {boolean} useCapture
         */
        this.removeEventListener = function (type, listener, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var listeners = _this.getListeners(type, useCapture);
            var idx = listeners.indexOf(listener);
            if (idx !== -1) {
                listeners.splice(idx, 1);
            }
        };
        /**
         * EventListenerの起動
         * @param {ExEvent} evt イベント
         */
        this.dispatchEvent = function (evt) {
            var listeners = _this.getListeners(evt.type, false).slice();
            for (var i = 0; i < listeners.length; i++) {
                listeners[i].call(_this, evt);
            }
            return !evt.defaultPrevented;
        };
        /**
         * EventListenerのクリア(初期化)
         */
        this.clearAllEventListener = function () {
            _this.registrations = {};
        };
        this.registrations = {};
    }
    return EventBus;
}());



/***/ }),

/***/ "./ts/dash/core/LogHandler.ts":
/*!************************************!*\
  !*** ./ts/dash/core/LogHandler.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * LogHandler
 *
 * @module LogHandler（LogHandlerモジュール）
 */
/**
 * LogHandler
 * @constructor
 */
var LogHandler = {
    log: function (_msg, _val) { },
    log_A: function () { },
    log_V: function () { },
    log_V2: function (_msg) { },
    log_A2: function (_msg) { },
    log_d: function (_msg) { },
    log_V2Q: function (_msg) { },
    log_A2Q: function (_msg) { },
    log_item: function (_type, _msg) { },
    log_slider: function (_val, _num) { },
    log_DRM: function (_msg, _val) { },
    clearLogs: function () { },
};
/* harmony default export */ __webpack_exports__["default"] = (LogHandler);


/***/ }),

/***/ "./ts/dash/core/Utils.ts":
/*!*******************************!*\
  !*** ./ts/dash/core/Utils.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasProperty": function() { return /* binding */ hasProperty; }
/* harmony export */ });
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Utils
 *
 * @module Utils（Utilsモジュール）
 */
/**
 * Utils
 * @constructor
 */
var hasProperty = function (object, key) {
    return object instanceof Object && Object.prototype.hasOwnProperty.call(object, key);
};


/***/ }),

/***/ "./ts/dash/manifest/DashHandler.ts":
/*!*****************************************!*\
  !*** ./ts/dash/manifest/DashHandler.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashHandler": function() { return /* binding */ DashHandler; },
/* harmony export */   "Segment": function() { return /* binding */ Segment; },
/* harmony export */   "SegmentRequest": function() { return /* binding */ SegmentRequest; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _TimelineConverter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TimelineConverter */ "./ts/dash/manifest/TimelineConverter.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */





/**
 * DashHandler
 *
 * @module DashHandler（DashHandlerモジュール）
 */
/**
 * Segment
 * @constructor
 */
var Segment = /** @class */ (function () {
    function Segment() {
        this.indexRange = null;
        this.index = null;
        this.mediaRange = null;
        this.media = null;
        this.duration = NaN;
        // this is the time that should be inserted into the media url
        this.replacementTime = null;
        // this is the number that should be inserted into the media url
        this.replacementNumber = NaN;
        // This is supposed to match the time encoded in the media Segment
        this.mediaStartTime = NaN;
        // When the source buffer timeOffset is set to MSETimeOffset this is the
        // time that will match the seekTarget and video.currentTime
        this.presentationStartTime = NaN;
        // Do not schedule this segment until
        this.availabilityStartTime = NaN;
        // Ignore and  discard this segment after
        this.availabilityEndTime = NaN;
        // The index of the segment inside the availability window
        this.availabilityIdx = NaN;
        // For dynamic mpd's, this is the wall clock time that the video
        // element currentTime should be presentationStartTime
        this.wallStartTime = NaN;
        this.representation = null;
    }
    return Segment;
}());

/**
 * SegmentRequest
 * @constructor
 */
var SegmentRequest = /** @class */ (function () {
    function SegmentRequest() {
        this.ACTION_DOWNLOAD = 'download';
        this.ACTION_COMPLETE = 'complete';
        this.action = 'download';
        this.startTime = NaN;
        this.streamType = null;
        this.type = null;
        this.duration = NaN;
        this.timescale = NaN;
        this.range = null;
        this.url = null;
        this.baseURL = [];
        this.baseURLIdx = NaN;
        this.relativeURL = null;
        this.requestStartTime = NaN;
        this.firstByteTime = NaN;
        this.requestEndTime = NaN;
        this.total = NaN;
        this.loaded = NaN;
        this.loading = false;
        this.keep = false;
        this.quality = NaN;
        this.index = NaN;
        this.size = 0;
        this.code = null;
        this.bufferLevelAtStartDate = NaN;
        this.availabilityStartTime = null;
        this.availabilityEndTime = null;
        this.wallStartTime = null;
        this.bandwidth = null;
        this.MSETimeOffset = NaN;
        this.periodIdx = NaN;
        this.pStart = NaN;
        this.adaptationIdx = NaN;
    }
    return SegmentRequest;
}());

var zeroPadToLength = function (numStr, minStrLength) {
    while (numStr.length < minStrLength) {
        numStr = '0' + numStr;
    }
    return numStr;
};
var tmp64BitNumber = function (high, low) {
    return high * 4294967296 + low;
};
// const tmp64to32Bit = (num: number): { high: number; low: number } => {
//   const high: number = num / 4294967296;
//   const low = num & 0xffffffff;
//   return {
//     high,
//     low,
//   };
// };
var abortWrapper = function (f, c) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            c.aborted = true;
            reject(new Error('abort'));
        }, 3000);
        f.then(resolve, reject);
    });
};
var getNumberForSegment = function (segment, segmentIndex) {
    return segment.representation.startNumber + segmentIndex;
};
var baseUrlIndex = function (representation) {
    //const rnd= Math.floor(Math.random()*representation.BaseURL.length);
    //return rnd;
    var idx = representation.adaptation.period.selectedBaseURLIdx;
    return isNaN(idx) ? 0 : idx;
};
/**
 * DashHandler
 * @constructor
 */
var DashHandler = /** @class */ (function () {
    function DashHandler(params, eventBus, xhrCustom) {
        var _this = this;
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.timelineConverter = _TimelineConverter__WEBPACK_IMPORTED_MODULE_4__["default"];
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__["default"];
        this.replaceTokenForTemplate = function (url, token, value) {
            var startPos = 0;
            var endPos = 0;
            var tokenLen = token.length;
            var formatTag = '%0';
            var formatTagLen = formatTag.length;
            var formatTagPos;
            var specifier;
            var width;
            var paddedValue;
            // keep looping round until all instances of <token> have been
            // replaced. once that has happened, startPos below will be -1
            // and the completed url will be returned.
            while (true) {
                // eslint-disable-line no-constant-condition
                // check if there is a valid $<token>...$ identifier
                // if not, return the url as is.
                startPos = url.indexOf('$' + token);
                if (startPos < 0) {
                    return url;
                }
                // the next '$' must be the end of the identifer
                // if there isn't one, return the url as is.
                endPos = url.indexOf('$', startPos + tokenLen);
                if (endPos < 0) {
                    return url;
                }
                // now see if there is an additional format tag suffixed to
                // the identifier within the enclosing '$' characters
                formatTagPos = url.indexOf(formatTag, startPos + tokenLen);
                if (formatTagPos > startPos && formatTagPos < endPos) {
                    specifier = url.charAt(endPos - 1);
                    width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);
                    // support the minimum specifiers required by IEEE 1003.1
                    // (d, i , o, u, x, and X) for completeness
                    switch (specifier) {
                        // treat all int types as uint,
                        // hence deliberate fallthrough
                        case 'd':
                        case 'i':
                        case 'u':
                            paddedValue = zeroPadToLength(value.toString(), width);
                            break;
                        case 'x':
                            paddedValue = zeroPadToLength(value.toString(16), width);
                            break;
                        case 'X':
                            paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();
                            break;
                        case 'o':
                            paddedValue = zeroPadToLength(value.toString(8), width);
                            break;
                        default:
                            _this.NXDebug.log('Unsupported/invalid IEEE 1003.1 format identifier string in URL');
                            return url;
                    }
                }
                else {
                    paddedValue = value;
                }
                url =
                    url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);
            }
        };
        //NSV-a const replaceNumberForTemplate = (url, value) => {
        //NSV-a   const v = value.toString();
        //NSV-a   return url.split('$Number$').join(v);
        //NSV-a };
        //NSV-a
        //NSV-a const replaceTimeForTemplate = (url, value) => {
        //NSV-a   const v = value.toString();
        //NSV-a   return url.split('$Time$').join(v);
        //NSV-a };
        //NSV-a
        //NSV-a const replaceBandwidthForTemplate = (url, value) => {
        //NSV-a   const v = value.toString();
        //NSV-a   return url.split('$Bandwidth$').join(v);
        //NSV-a };
        //NSV-a
        //NSV-a const replaceIDForTemplate = (url, value) => {
        //NSV-a   if (value === null || url.indexOf('$RepresentationID$') === -1) {
        //NSV-a     return url;
        //NSV-a   }
        //NSV-a   const v = value.toString();
        //NSV-a   return url.split('$RepresentationID$').join(v);
        //NSV-a };
        //NSV-a const getRequestUrl = (destination, baseURL) => {
        //NSV-a   let url;
        //NSV-a   if (destination === baseURL) {
        //NSV-a     url = destination;
        //NSV-a   } else if (
        //NSV-a     destination.indexOf('http://') !== -1 ||
        //NSV-a     destination.indexOf('https://') !== -1
        //NSV-a   ) {
        //NSV-a     url = destination;
        //NSV-a   } else {
        //NSV-a     url = baseURL + destination;
        //NSV-a   }
        //NSV-a   return url;
        //NSV-a };
        this.getInitRequestUrl = function (destination, representation, _callback) {
            var callback = _callback || (function () { });
            var baseURL = representation.BaseURL[baseUrlIndex.call(_this, representation)].url;
            var url;
            if (destination !== null) {
                if (destination === baseURL) {
                    url = destination;
                }
                else if (destination.indexOf('http://') !== -1 ||
                    destination.indexOf('https://') !== -1) {
                    url = destination;
                }
                else {
                    url = baseURL + destination;
                }
                callback({
                    status: 'ok',
                    data: url,
                });
            }
            else {
                _this.loadInitialization.call(self, baseURL, function (d) {
                    if (d.status === 'ok') {
                        representation.range = d.data;
                        representation.initialization = baseURL;
                        callback({
                            status: 'ok',
                            data: baseURL,
                        });
                    }
                    else {
                        callback({
                            status: 'error',
                            msg: 'loadInitialization error',
                        });
                    }
                });
            }
        };
        this.generateInitRequest = function (representation, streamType) {
            var period;
            var request = new SegmentRequest();
            var presentationStartTime;
            period = representation.adaptation.period;
            request.streamType = streamType;
            request.type = 'Initialization Segment';
            request.baseURLIdx = baseUrlIndex.call(_this, representation);
            request.baseURL = representation.BaseURL;
            request.relativeURL = representation.initialization;
            request.range = representation.range;
            request.MSETimeOffset =
                period.offset - representation.presentationTimeOffset;
            presentationStartTime = period.start;
            request.availabilityStartTime =
                _this.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, _this.isDynamic);
            request.availabilityEndTime =
                _this.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, _this.isDynamic);
            request.quality = representation.index;
            request.periodIdx = period.index;
            request.pStart = period.start;
            request.adaptationIdx = representation.adaptation.index;
            request.representation = representation;
            return request;
        };
        this.getInit = function (representation, type, _callback) {
            var callback = _callback || (function () { });
            var request = null;
            var url = null;
            var self = _this;
            if (!representation) {
                callback({
                    status: 'error',
                    msg: ' no representation',
                });
            }
            if (representation.initialization) {
                request = _this.generateInitRequest.call(self, representation, type);
                callback({
                    status: 'ok',
                    data: request,
                });
            }
            else {
                url = representation.BaseURL[baseUrlIndex.call(_this, representation)].url;
                _this.loadInitialization.call(self, url, function (d) {
                    if (d.status === 'ok') {
                        representation.range = d.data;
                        representation.initialization = url;
                        request = _this.generateInitRequest.call(self, representation, type);
                        callback({
                            status: 'ok',
                            data: request,
                        });
                    }
                    else {
                        callback({
                            status: 'error',
                            msg: d.msg,
                        });
                    }
                });
            }
        };
        this.isMediaFinished = function (representation, index) {
            var sDuration;
            var period = representation.adaptation.period;
            var periodLen = representation.adaptation.period.mpd.periods.length;
            var isFinished = false;
            var seg;
            var fTime;
            if (_this.isDynamic && period.index == periodLen - 1) {
                isFinished = false;
            }
            else {
                if (index < 0) {
                    isFinished = false;
                }
                else if (index < representation.availableSegmentsNumber) {
                    seg = _this.getSegmentByIndex(index, representation);
                    if (seg) {
                        fTime =
                            seg.presentationStartTime -
                                (period.start + period.mpd.timestampOffsetFor32bitVE);
                        sDuration = representation.adaptation.period.duration;
                        _this.NXDebug.debug('[' +
                            representation.adaptation.type +
                            '] ' +
                            representation.segmentInfoType +
                            ': ' +
                            fTime +
                            ' / ' +
                            sDuration);
                        isFinished = fTime >= sDuration;
                    }
                }
                else {
                    isFinished = true;
                }
            }
            return isFinished;
        };
        this.getIndexBasedSegment = function (representation, index) {
            var seg = new Segment();
            var duration = representation.segmentDuration;
            var presentationStartTime = representation.adaptation.period.start + index * duration;
            var presentationEndTime = presentationStartTime + duration;
            seg.representation = representation;
            seg.duration = duration;
            seg.presentationStartTime =
                presentationStartTime > 0 ? presentationStartTime : 0;
            seg.mediaStartTime =
                _this.timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);
            seg.availabilityStartTime =
                _this.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, _this.isDynamic);
            seg.availabilityEndTime =
                _this.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, _this.isDynamic);
            seg.wallStartTime = _this.timelineConverter.calcWallTimeForSegment(seg, _this.isDynamic);
            seg.replacementNumber = getNumberForSegment(seg, index);
            seg.availabilityIdx = index;
            return seg;
        };
        /* istanbul ignore next */
        this.getSegmentsFromTimeline = function (representation, _callback) {
            var self = _this;
            var callback = _callback || (function () { });
            var isTemplate = representation.SegmentTemplate != null;
            var timeline;
            var tmedia;
            var list;
            var isAvailableSegmentNumberCalculated = representation.availableSegmentsNumber > 0;
            var segments = [];
            var fragments;
            var frag;
            var j;
            var repeat;
            var repeatEndTime;
            var nextFrag;
            var time = 0;
            var availabilityIdx = -1;
            var calculatedRange;
            var hasEnoughSegments;
            var startIdx;
            var endIdx;
            var fTimescale;
            var createSegment = function (s) {
                var media = isTemplate ? tmedia : list[availabilityIdx].media;
                return _this.getTimeBasedSegment.call(self, representation, time, s.d, fTimescale, media, s.mediaRange, availabilityIdx);
            };
            if (isTemplate) {
                timeline = representation.SegmentTemplate.SegmentTimeline;
                tmedia = representation.SegmentTemplate.media;
            }
            else {
                timeline = representation.SegmentList.SegmentTimeline;
                list = representation.SegmentList.SegmentURLs;
            }
            fTimescale = representation.timescale;
            fragments = timeline.S;
            calculatedRange = _this.decideSegmentListRangeForTimeline.call(self, representation);
            if (calculatedRange) {
                startIdx = calculatedRange.start;
                endIdx = calculatedRange.end;
            }
            else {
                //
            }
            for (var i = 0, len = fragments.length; i < len; i += 1) {
                frag = fragments[i];
                if (frag.d === 0) {
                    continue;
                }
                repeat = 0;
                if (frag.r != null) {
                    repeat = frag.r;
                }
                //For a repeated S element, t belongs only to the first segment
                if (frag.t != null) {
                    time = frag.t;
                }
                //This is a special case: "A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the
                // next MPD update."
                if (repeat < 0) {
                    nextFrag = fragments[i + 1];
                    repeatEndTime =
                        nextFrag && nextFrag.t != null
                            ? nextFrag.t / fTimescale
                            : representation.adaptation.period.duration;
                    repeat =
                        Math.ceil((repeatEndTime - time / fTimescale) / (frag.d / fTimescale)) - 1;
                }
                // if we have enough segments in the list, but we have not calculated the total number of the segments yet we
                // should continue the loop and calc the number. Once it is calculated, we can break the loop.
                if (hasEnoughSegments) {
                    if (isAvailableSegmentNumberCalculated)
                        break;
                    availabilityIdx += repeat + 1;
                    continue;
                }
                for (j = 0; j <= repeat; j += 1) {
                    availabilityIdx += 1;
                    if (calculatedRange) {
                        if (availabilityIdx > endIdx) {
                            hasEnoughSegments = true;
                            if (isAvailableSegmentNumberCalculated)
                                break;
                            continue;
                        }
                        if (availabilityIdx >= startIdx) {
                            segments.push(createSegment.call(self, frag));
                        }
                    }
                    else {
                        segments.push(createSegment.call(self, frag));
                    }
                    time += frag.d;
                }
            }
            if (!isAvailableSegmentNumberCalculated) {
                var f = fragments[0];
                var availabilityStartTime = _this.timelineConverter.calcPresentationTimeFromMediaTime(f.t / fTimescale, representation);
                var availabilityEndTime = _this.timelineConverter.calcPresentationTimeFromMediaTime((time - frag.d) / fTimescale, representation);
                representation.segmentAvailabilityRange = {
                    start: availabilityStartTime,
                    end: availabilityEndTime,
                };
                representation.availableSegmentsNumber = availabilityIdx + 1;
            }
            callback({
                status: 'ok',
                data: segments,
            });
        };
        this.getSegmentsFromTemplate = function (representation, _callback) {
            var segments = [];
            var self = _this;
            var callback = _callback || (function () { });
            var template = representation.SegmentTemplate;
            var segmentRange = null;
            var curSegments = representation.segments;
            var startIdx;
            var endIdx;
            var seg = null;
            var start;
            var url = null;
            start = representation.startNumber;
            _this.waitForAvailabilityWindow.call(self, representation, function (availabilityWindow) {
                representation.segmentAvailabilityRange = availabilityWindow;
                segmentRange = _this.decideSegmentListRangeForTemplate.call(self, representation);
                startIdx = segmentRange.start;
                endIdx = segmentRange.end;
                if (curSegments != null) {
                    var rmIdx = 0;
                    for (var i = 0; i < curSegments.length; i++) {
                        if (startIdx <= curSegments[i].availabilityIdx) {
                            rmIdx = i;
                            break;
                        }
                    }
                    if (rmIdx > 0) {
                        for (var i = 0; i < rmIdx; i++) {
                            curSegments.splice(0, rmIdx - 1);
                        }
                    }
                    segments = curSegments;
                    if (segments.length > 0) {
                        startIdx = segments[segments.length - 1].availabilityIdx + 1;
                    }
                }
                for (var i = startIdx; i < endIdx; i += 1) {
                    seg = _this.getIndexBasedSegment.call(self, representation, i);
                    seg.replacementTime =
                        (start + i - 1) * representation.segmentDuration;
                    url = template.media;
                    //url = replaceTokenForTemplate(url, "Number", seg.replacementNumber);
                    //url = replaceTokenForTemplate(url, "Time", seg.replacementTime);
                    seg.media = url;
                    segments.push(seg);
                    seg = null;
                }
                representation.availableSegmentsNumber = endIdx;
                callback({
                    status: 'ok',
                    data: segments,
                });
            });
        };
        this.decideSegmentListRangeForTemplate = function (representation) {
            var duration = representation.segmentDuration;
            var availabilityWindow = representation.segmentAvailabilityRange;
            var currentSegmentList = representation.segments;
            var period = representation.adaptation.period;
            var start;
            var end;
            var range;
            if (_this.isDynamic) {
                start = Math.floor((availabilityWindow.start - period.start) / duration);
                end = Math.ceil((availabilityWindow.end - period.start) / duration);
                range = {
                    start: start,
                    end: end,
                };
                return range;
            }
            //NSV-a Check This part should be reviewed .
            if (currentSegmentList) {
                //
            }
            else {
                //
            }
            start = Math.floor((availabilityWindow.start - period.start) / duration);
            end = Math.ceil((availabilityWindow.end - period.start) / duration);
            range = {
                start: start,
                end: end,
            };
            return range;
        };
        this.decideSegmentListRangeForTimeline = function (representation) {
            var originAvailabilityIdx = NaN;
            var currentSegmentList = representation.segments;
            var availabilityLowerLimit = 10;
            var availabilityUpperLimit = 10;
            var firstIdx = 0;
            var lastIdx = Number.POSITIVE_INFINITY;
            var start;
            var end;
            var range;
            var index = _this.requestStatus[representation.adaptation.type].index;
            if (_this.isDynamic) {
                range = {
                    start: firstIdx,
                    end: lastIdx,
                };
                return range;
            }
            if (!_this.isDynamic &&
                _this.requestStatus[representation.adaptation.type].requestedTime)
                return null;
            if (currentSegmentList) {
                if (index < 0)
                    return null;
                originAvailabilityIdx = index;
            }
            else {
                originAvailabilityIdx =
                    index >= 0 ? index : _this.isDynamic ? lastIdx : firstIdx;
            }
            // この if は通らない。
            /* istanbul ignore if */
            if (_this.isDynamic) {
                start = Math.max(originAvailabilityIdx - availabilityLowerLimit, firstIdx);
                end = Math.min(originAvailabilityIdx + availabilityUpperLimit, lastIdx);
            }
            else {
                start = firstIdx;
                end = lastIdx;
            }
            range = {
                start: start,
                end: end,
            };
            return range;
        };
        this.waitForAvailabilityWindow = function (representation, _callback) {
            var callback = _callback || (function () { });
            var range;
            var waitingTime;
            var getRange = function () {
                range = _this.timelineConverter.calcSegmentAvailabilityRange(representation, _this.isDynamic);
                if (range.end > 0) {
                    callback(range);
                }
                else {
                    waitingTime = Math.abs(range.end) * 1000;
                    setTimeout(getRange, waitingTime);
                }
            };
            getRange();
        };
        this.getTimeBasedSegment = function (representation, time, duration, fTimescale, url, range, index) {
            var scaledTime = time / fTimescale;
            //const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);
            var scaledDuration = duration / fTimescale;
            var presentationStartTime = _this.timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);
            var presentationEndTime = presentationStartTime + scaledDuration;
            var seg = new Segment();
            seg.representation = representation;
            seg.duration = scaledDuration;
            seg.mediaStartTime = scaledTime;
            seg.presentationStartTime = presentationStartTime;
            // For SegmentTimeline every segment is available at mpdLoadedTime
            seg.availabilityStartTime =
                representation.adaptation.period.mpd.manifest.mpdLoadedTime;
            //seg.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);
            seg.availabilityEndTime =
                _this.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, _this.isDynamic);
            // at this wall clock time, the video element currentTime should be seg.presentationStartTime
            seg.wallStartTime = _this.timelineConverter.calcWallTimeForSegment(seg, _this.isDynamic);
            seg.replacementTime = time;
            seg.replacementNumber = getNumberForSegment(seg, index);
            seg.timescale = fTimescale;
            //url = replaceTokenForTemplate(url, "Number", seg.replacementNumber);
            //url = replaceTokenForTemplate(url, "Time", seg.replacementTime);
            seg.media = url;
            seg.mediaRange = range;
            seg.availabilityIdx = index;
            return seg;
        };
        this.getSegmentsFromList = function (representation, _callback) {
            var self = _this;
            var segments = [];
            var callback = _callback || (function () { });
            var list = representation.SegmentList;
            var len = list.SegmentURLs.length;
            var seg;
            var s;
            var range;
            var startIdx;
            //let endIdx: number;
            var start;
            start = representation.startNumber;
            _this.waitForAvailabilityWindow.call(self, representation, function (availabilityWindow) {
                representation.segmentAvailabilityRange = availabilityWindow;
                range = _this.decideSegmentListRangeForTemplate.call(self, representation);
                startIdx = range.start;
                //endIdx = range.end;
                for (var i = 0; i < len; i += 1) {
                    s = list.SegmentURLs[i];
                    seg = _this.getIndexBasedSegment.call(self, representation, start + i - 1);
                    seg.replacementTime =
                        (start + i - 1) * representation.segmentDuration;
                    seg.media = s.media;
                    seg.mediaRange = s.mediaRange;
                    seg.index = s.index;
                    seg.indexRange = s.indexRange;
                    segments.push(seg);
                    seg = null;
                }
                representation.availableSegmentsNumber = len - startIdx;
                callback({
                    status: 'ok',
                    data: segments,
                });
            });
        };
        this.getSegmentsFromSource = function (representation, _callback) {
            var self = _this;
            var baseURL = representation.BaseURL[baseUrlIndex.call(_this, representation)].url;
            var callback = _callback || (function () { });
            var segments = [];
            var count = 0;
            var range = null;
            var s;
            var len;
            var seg;
            if (representation.indexRange) {
                range = representation.indexRange;
            }
            _this.loadSegments.call(self, baseURL, range, function (d) {
                if (d.status === 'ok') {
                    var fragments = d.data;
                    for (var i = 0, len_1 = fragments.length; i < len_1; i += 1) {
                        s = fragments[i];
                        seg = _this.getTimeBasedSegment.call(self, representation, s.startTime, s.duration, s.timescale, s.media, s.mediaRange, count);
                        if (seg.presentationStartTime >= 0) {
                            segments.push(seg);
                        }
                        else {
                            // eslint-disable-line no-empty
                        }
                        seg = null;
                        count += 1;
                    }
                    len = segments.length;
                    representation.segmentAvailabilityRange = {
                        start: segments[0].presentationStartTime,
                        end: segments[len - 1].presentationStartTime,
                    };
                    representation.availableSegmentsNumber = len;
                    callback({
                        status: 'ok',
                        data: segments,
                    });
                }
                else {
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        /* istanbul ignore next */
        this.getSegments = function (representation, _callback) {
            var callback = _callback || (function () { });
            var self = _this;
            // Already figure out the segments.
            if (!_this.isSegmentListUpdateRequired.call(self, representation)) {
                callback({
                    status: 'ok',
                    data: representation.segments,
                });
            }
            else {
                var segmentsCallback = function (d) {
                    if (d.status === 'ok') {
                        var segments = d.data;
                        representation.segments = segments;
                        if (segments.length > 0) {
                            representation.indexOffset = segments[0].availabilityIdx;
                        }
                        if (!_this.isDynamic) {
                            representation.lastRequestIndex = segments.length - 1;
                        }
                        else {
                            var period = representation.adaptation.period;
                            var periods = period.mpd.periods;
                            var liveEdgeS = NaN;
                            var liveEdge = NaN;
                            var updateRequired = false;
                            if (period.start == periods[0].start) {
                                if (segments.length > 0) {
                                    if (isNaN(period.mpd.liveEdgeS)) {
                                        liveEdgeS = segments[0].presentationStartTime;
                                        updateRequired = true;
                                    }
                                    else {
                                        if (period.mpd.liveEdgeS < segments[0].presentationStartTime) {
                                            liveEdgeS = segments[0].presentationStartTime;
                                            updateRequired = true;
                                        }
                                    }
                                }
                                else {
                                    updateRequired = false;
                                }
                            }
                            if (period.start == periods[periods.length - 1].start) {
                                var edge = void 0;
                                if (segments.length > 0) {
                                    edge =
                                        segments[segments.length - 1].presentationStartTime +
                                            segments[segments.length - 1].duration;
                                }
                                else {
                                    edge = period.start;
                                }
                                if (representation.segmentInfoType == 'SegmentTemplate') {
                                    edge = representation.segmentAvailabilityRange.now;
                                }
                                if (isNaN(period.mpd.liveEdge)) {
                                    liveEdge = edge;
                                    updateRequired = true;
                                }
                                else {
                                    if (period.mpd.liveEdge < edge) {
                                        liveEdge = edge;
                                        updateRequired = true;
                                    }
                                }
                            }
                            if (updateRequired)
                                _this.updateLiveEdge.call(self, period, liveEdgeS, liveEdge);
                        }
                        callback({
                            status: 'ok',
                            data: segments,
                        });
                    }
                    else {
                        callback({
                            status: 'error',
                            msg: 'getSegments null',
                        });
                    }
                };
                if (representation.segmentInfoType === 'SegmentTimeline') {
                    _this.getSegmentsFromTimeline.call(self, representation, segmentsCallback);
                }
                else if (representation.segmentInfoType === 'SegmentTemplate') {
                    _this.getSegmentsFromTemplate.call(self, representation, segmentsCallback);
                }
                else if (representation.segmentInfoType === 'SegmentList') {
                    _this.getSegmentsFromList.call(self, representation, segmentsCallback);
                }
                else {
                    _this.getSegmentsFromSource.call(self, representation, segmentsCallback);
                }
            }
        };
        //liveMulti
        this.updateLiveEdge = function (period, s, e) {
            var liveEdgeSUpdated = false;
            var liveEdgeEUpdated = false;
            if (!isNaN(s)) {
                period.mpd.liveEdgeS = s;
                liveEdgeSUpdated = true;
            }
            if (!isNaN(e)) {
                period.mpd.liveEdge = e;
                liveEdgeEUpdated = true;
                period.mpd.liveEdgeE = Math.max(period.mpd.liveEdge - period.mpd.suggestedPresentationDelay, !isNaN(period.mpd.liveEdgeS) ? period.mpd.liveEdgeS : 0);
            }
            _this.eventBus.dispatchEvent({
                type: 'liveEdgeUpdated',
                data: {
                    liveEdgeS: period.mpd.liveEdgeS,
                    liveEdgeE: period.mpd.liveEdgeE,
                    liveEdge: period.mpd.liveEdge,
                    liveEdgeSUpdated: liveEdgeSUpdated,
                    liveEdgeEUpdated: liveEdgeEUpdated,
                    targetLatency: period.mpd.suggestedPresentationDelay,
                },
            });
        };
        /* istanbul ignore next */
        this.updateForLiveEdgeMPD = function (type, period) {
            var self = _this;
            var periods = period.mpd.periods;
            var sp = periods[0];
            var ep = periods[periods.length - 1];
            var sr = sp
                .getPrimaryMediaData(type)
                .getRepresentations()[0];
            var er = ep
                .getPrimaryMediaData(type)
                .getRepresentations()[0];
            _this.getSegments.call(self, sr, function (d) {
                d; //dummy
                if (sp.start != ep.start) {
                    _this.getSegments.call(self, er, function (f) {
                        f;
                    });
                }
            });
        };
        //NSV-a //liveMulti
        //NSV-a const updateLiveEdgeForPeriod = representation => {
        //NSV-a     const lastIdx = representation.segments.length - 1;
        //NSV-a
        //NSV-a     let edge =
        //NSV-a       representation.segments[lastIdx].presentationStartTime +
        //NSV-a       representation.segments[lastIdx].duration;
        //NSV-a
        //NSV-a     const start = representation.segments[0].presentationStartTime;
        //NSV-a
        //NSV-a     if (!isNaN(representation.adaptation.period.end)) {
        //NSV-a       edge = Math.min(representation.adaptation.period.end, edge);
        //NSV-a     }
        //NSV-a
        //NSV-a     if (isDynamic) {
        //NSV-a       if (isNaN(representation.adaptation.period.liveEdge)) {
        //NSV-a         representation.adaptation.period.liveEdge = edge;
        //NSV-a       } else {
        //NSV-a         if (edge < representation.adaptation.period.liveEdge) {
        //NSV-a           representation.adaptation.period.liveEdge = edge;
        //NSV-a         }
        //NSV-a       }
        //NSV-a       if (isNaN(representation.adaptation.period.liveEdgeS)) {
        //NSV-a         representation.adaptation.period.liveEdgeS = start;
        //NSV-a       } else {
        //NSV-a         if (representation.adaptation.period.liveEdgeS < start) {
        //NSV-a           representation.adaptation.period.liveEdgeS = start;
        //NSV-a         }
        //NSV-a       }
        //NSV-a     }
        //NSV-a   };
        this.updateSegmentList = function (representation, _callback) {
            var self = _this;
            var segment;
            var ctime = -1;
            var currentIdx = _this.requestStatus[representation.adaptation.type].index;
            var periods = representation.adaptation.period.mpd.periods;
            var periodIdx = representation.adaptation.period.index;
            var callback = _callback || (function () { });
            if (_this.isDynamic && periodIdx == periods.length - 1) {
                if (representation.segments != null &&
                    representation.segments.length > 0 &&
                    currentIdx >= 0) {
                    representation.indexOffset = representation.segments[0].availabilityIdx;
                    while (currentIdx > 0) {
                        segment = _this.getSegmentByIndex(currentIdx, representation);
                        if (segment != null) {
                            ctime = segment.presentationStartTime;
                            break;
                        }
                        else {
                            currentIdx--;
                        }
                    }
                }
                else {
                    ctime = -1;
                }
            }
            representation.segments = null;
            if (_this.isDynamic && ctime >= 0) {
                _this.getSegments.call(self, representation, function (d) {
                    if (d.status === 'ok') {
                        representation.segments = d.data;
                        _this.requestStatus[representation.adaptation.type].index =
                            _this.getIndexForSegments.call(self, ctime, representation);
                        _this.requestStatus[representation.adaptation.type].requestedTime =
                            ctime;
                        _this.NXDebug.debug('[' +
                            representation.adaptation.type +
                            '] index:' +
                            _this.requestStatus[representation.adaptation.type].index +
                            ', ' +
                            _this.requestStatus[representation.adaptation.type]
                                .requestedTime +
                            '  ***** update index *****');
                        callback({
                            status: 'ok',
                            data: ctime,
                        });
                    }
                    else {
                        _this.NXDebug.debug('ERROR:' + d.msg);
                        ctime = -1;
                        _this.requestStatus[representation.adaptation.type] = {
                            index: -1,
                            requestedTime: null,
                        };
                        callback({
                            status: 'error',
                            msg: d.msg,
                        });
                    }
                });
            }
            else {
                _this.getSegments.call(self, representation, function (d) {
                    if (d.status === 'ok') {
                        representation.segments = d.data;
                        _this.requestStatus[representation.adaptation.type] = {
                            index: -1,
                            requestedTime: null,
                        };
                        callback({
                            status: 'ok',
                            data: ctime,
                        });
                    }
                    else {
                        _this.NXDebug.debug('ERROR:' + d.msg);
                        ctime = -1;
                        callback({
                            status: 'error',
                            msg: d.msg,
                        });
                    }
                });
            }
        };
        this.getIndexForSegments = function (time, representation) {
            var segments = representation.segments;
            var segmentLastIdx = segments.length - 1;
            var idx = -1;
            var frag;
            var ft;
            var fd;
            var epsilon = _this.epsilonVal[representation.adaptation.type];
            if (segments && segments.length > 0) {
                for (var i = segmentLastIdx; i >= 0; i--) {
                    frag = segments[i];
                    ft = frag.presentationStartTime;
                    fd = frag.duration;
                    if (time + epsilon >= ft && time - epsilon <= ft + fd) {
                        idx = frag.availabilityIdx;
                        break;
                    }
                }
                if (idx === -1) {
                    for (var i = segmentLastIdx; i >= 0; i--) {
                        frag = segments[i];
                        ft = frag.presentationStartTime;
                        fd = frag.duration;
                        if (time + _this.EPSILON >= ft && time - _this.EPSILON <= ft + fd) {
                            idx = frag.availabilityIdx;
                            break;
                        }
                        else if (i == segmentLastIdx && time - _this.EPSILON > ft + fd) {
                            idx = segmentLastIdx;
                        }
                    }
                }
            }
            if (idx === -1) {
                if (!isNaN(representation.segmentDuration)) {
                    idx = Math.floor(time / representation.segmentDuration);
                    _this.NXDebug.debug('#?#?#? idx: ' +
                        idx +
                        ' : ' +
                        time +
                        '/' +
                        representation.segmentDuration);
                    /*
                      for(let i=0;i<segments.length;i++){
                          NXDebug.debug("["+i+"] st:"+segments[i].presentationStartTime+"dur:"+segments[i].duration);
                      }
                    */
                }
                else {
                    _this.NXDebug.debug("Couldn't figure out a time! " + representation.adaptation.type);
                    _this.NXDebug.debug('Time: ' + time);
                }
            }
            return idx;
        };
        this.getSegmentByIndex = function (index, representation) {
            if (!representation || !representation.segments)
                return null;
            var ln = representation.segments.length;
            var seg;
            var targetIdx = index - representation.segments[0].availabilityIdx;
            if (targetIdx > -1 && targetIdx < ln) {
                if (representation.segments[targetIdx].availabilityIdx === index) {
                    return representation.segments[targetIdx];
                }
                else {
                    // eslint-disable-line no-empty
                }
            }
            else {
                return null;
            }
            for (var i = 0; i < ln; i += 1) {
                seg = representation.segments[i];
                if (seg.availabilityIdx === index) {
                    return seg;
                }
            }
            return null;
        };
        this.isSegmentListUpdateRequired = function (representation) {
            var updateRequired = false;
            var segments = representation.segments;
            var index = _this.requestStatus[representation.adaptation.type].index;
            if (!segments) {
                updateRequired = true;
            }
            else if (_this.isDynamic &&
                representation.segmentInfoType === 'SegmentTemplate') {
                updateRequired = true;
            }
            else if (index === -1) {
                updateRequired = false;
            }
            else {
                updateRequired = false;
            }
            return updateRequired;
        };
        this.getRequestForSegment = function (segment, type) {
            if (segment === null || segment === undefined) {
                return null;
            }
            var request = new SegmentRequest();
            var representation = segment.representation;
            var bandwidth = representation.bandwidth;
            var baseURLIdx = baseUrlIndex.call(_this, representation);
            var relativeURL = segment.media;
            var tokens = [
                {
                    name: 'Number',
                    value: segment.replacementNumber,
                },
                {
                    name: 'Time',
                    value: segment.replacementTime,
                },
                {
                    name: 'Bandwidth',
                    value: bandwidth,
                },
                {
                    name: 'RepresentationID',
                    value: representation.id,
                },
            ];
            tokens.forEach(function (token) {
                relativeURL = _this.replaceTokenForTemplate(relativeURL, token.name, token.value);
            });
            request.streamType = type;
            request.type = 'Media Segment';
            request.relativeURL = relativeURL;
            request.baseURL = representation.BaseURL;
            request.baseURLIdx = baseURLIdx;
            request.range = segment.mediaRange;
            request.startTime = segment.presentationStartTime;
            request.duration = segment.duration;
            request.timescale = segment.timescale || representation.timescale;
            request.availabilityStartTime = segment.availabilityStartTime;
            request.availabilityEndTime = segment.availabilityEndTime;
            request.wallStartTime = segment.wallStartTime;
            request.quality = representation.index;
            request.index = segment.availabilityIdx;
            request.bandwidth = representation.bandwidth;
            request.periodIdx = representation.adaptation.period.index;
            request.pStart = representation.adaptation.period.start;
            request.adaptationIdx = representation.adaptation.index;
            request.representation = representation;
            request.MSETimeOffset =
                representation.adaptation.period.offset -
                    representation.presentationTimeOffset;
            return request;
        };
        this.getForTime = function (representation, time, type, _loc, _callback) {
            var callback = _callback || (function () { });
            var request;
            var segment;
            var dIdx = {};
            var self = _this;
            if (!representation) {
                callback({
                    status: 'error',
                    msg: 'no representation',
                });
                return;
            }
            _this.requestStatus[type].requestedTime = time;
            _this.NXDebug.debug('[' + type + '] Getting the request for time: ' + time);
            _this.getSegments.call(self, representation, function (d) {
                if (d.status === 'ok') {
                    _this.requestStatus[type].index = _this.getIndexForSegments.call(self, time, representation);
                    dIdx[type] = _this.requestStatus[type].index;
                    if (_this.isMediaFinished.call(self, representation, dIdx[type])) {
                        request = new SegmentRequest();
                        request.action = request.ACTION_COMPLETE;
                        request.index = dIdx[type];
                        request.MSETimeOffset =
                            representation.adaptation.period.offset -
                                representation.presentationTimeOffset;
                        request.periodIdx = representation.adaptation.period.index;
                        request.pStart = representation.adaptation.period.start;
                        request.adaptationIdx = representation.adaptation.index;
                        request.representation = representation;
                        _this.NXDebug.log('[' + type + '] Signal complete. period:' + request.periodIdx);
                        callback({
                            status: 'ok',
                            data: request,
                        });
                    }
                    else {
                        segment = _this.getSegmentByIndex(dIdx[type], representation);
                        request = _this.getRequestForSegment.call(self, segment, type);
                        callback({
                            status: 'ok',
                            data: request,
                            time: time,
                        });
                    }
                }
                else {
                    _this.NXDebug.debug('ERROR:' + d.msg);
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        // setIndexForTime = (
        //   representation: Representation,
        //   time: number,
        //   type: string
        // ): void => {
        //   let newIndex: number = -1;
        //   const self = this;
        //   this.requestStatus[type].requestedTime = time;
        //   newIndex = this.getIndexForSegments.call(self, time, representation);
        //   if (newIndex != -1) {
        //     this.requestStatus[type].index = newIndex;
        //   } else {
        //     if (time < representation.segmentAvailabilityRange!.start) {
        //       this.requestStatus[type].index = 0;
        //     } else {
        //       this.requestStatus[type].index = representation.segments!.length - 1;
        //     }
        //   }
        //   this.NXDebug.debug(
        //     '[' +
        //       type +
        //       '] set index for time: ' +
        //       time +
        //       ', index=' +
        //       this.requestStatus[type].index
        //   );
        // };
        // getSegmentStartTimeAndDuration = (
        //   representation: Representation,
        //   time: number,
        //   _type: string
        // ): startDuration => {
        //   let segment: Nullable<Segment>;
        //   let idx: number;
        //   const self = this;
        //   if (!representation) {
        //     this.NXDebug.debug('no representation!!!');
        //     return {
        //       startTime: NaN,
        //       duration: NaN,
        //     };
        //   }
        //   idx = this.getIndexForSegments.call(self, time, representation);
        //   segment = this.getSegmentByIndex(idx, representation);
        //   if (segment) {
        //     return {
        //       startTime: segment.presentationStartTime,
        //       duration: segment.duration,
        //     };
        //   } else {
        //     return {
        //       startTime: time,
        //       duration: 0,
        //     };
        //   }
        // };
        this.isInitialIndex = function (type) {
            return _this.requestStatus[type].index === -1;
        };
        // getRequestStatus = (
        //   type: string
        // ): {
        //   requestedTime: Nullable<number>;
        //   index: number;
        // } => {
        //   return this.requestStatus[type];
        // };
        this.getNext = function (representation, type, _callback) {
            var callback = _callback || (function () { });
            var request;
            var segment = null;
            var dIdx = {};
            var self = _this;
            if (!representation) {
                callback({
                    status: 'error',
                    msg: 'no representation',
                });
            }
            if (_this.requestStatus[type].index === -1) {
                throw 'You must call getSegmentRequestForTime first.';
            }
            _this.requestStatus[type].requestedTime = null;
            _this.requestStatus[type].index += 1;
            dIdx[type] = _this.requestStatus[type].index;
            _this.getSegments.call(self, representation, function (d) {
                if (d.status === 'ok') {
                    if (_this.isMediaFinished.call(self, representation, dIdx[type])) {
                        request = new SegmentRequest();
                        request.action = request.ACTION_COMPLETE;
                        request.index = dIdx[type];
                        request.MSETimeOffset =
                            representation.adaptation.period.offset -
                                representation.presentationTimeOffset;
                        request.periodIdx = representation.adaptation.period.index;
                        request.pStart = representation.adaptation.period.start;
                        request.adaptationIdx = representation.adaptation.index;
                        request.representation = representation;
                        _this.NXDebug.log('[' + type + '] Signal complete. period:' + request.periodIdx);
                    }
                    else {
                        segment = _this.getSegmentByIndex(dIdx[type], representation);
                        _this.requestStatus[type].requestedTime =
                            segment != null ? segment.presentationStartTime : null;
                        request = _this.getRequestForSegment.call(self, segment, type);
                        if (!segment) {
                            _this.requestStatus[type].index -= 1;
                        }
                    }
                    callback({
                        status: 'ok',
                        data: request,
                        time: _this.requestStatus[type].requestedTime,
                    });
                }
                else {
                    _this.NXDebug.debug('ERROR:' + d.msg);
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        this.getSegmentCountForDuration = function (representation, requiredDuration, bufferedDuration, _callback) {
            var self = _this;
            var callback = _callback || (function () { });
            var remainingDuration;
            var segmentDuration;
            var segmentCount = 0;
            if (!representation) {
                callback({
                    status: 'error',
                    msg: 'no representation',
                });
            }
            _this.getSegments.call(self, representation, function (d) {
                if (d.status === 'ok') {
                    var segments = d.data;
                    segmentDuration = segments[0].duration;
                    if (bufferedDuration > requiredDuration + segmentDuration * 1.5) {
                        callback({
                            status: 'ok',
                            data: -1,
                        });
                    }
                    else {
                        (remainingDuration = Math.max(requiredDuration - bufferedDuration, 0)),
                            (segmentCount = Math.ceil(remainingDuration / segmentDuration));
                        callback({
                            status: 'ok',
                            data: segmentCount,
                        });
                    }
                }
                else {
                    _this.NXDebug.debug('ERROR:' + d.msg);
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        // getSegmentFirstStartTime = (
        //   representation: Representation,
        //   _callback: (res: ResponseData) => void
        // ): void => {
        //   const self = this;
        //   const callback: (res: ResponseData) => void = _callback || (() => {});
        //   let segmentStartTime: number;
        //   if (!representation) {
        //     callback({
        //       status: 'error',
        //       msg: 'no representation',
        //     });
        //   }
        //   this.getSegments.call(self, representation, (d) => {
        //     if (d.status === 'ok') {
        //       segmentStartTime = d.data[0].presentationStartTime;
        //       callback({
        //         status: 'ok',
        //         data: segmentStartTime,
        //       });
        //     } else {
        //       this.NXDebug.debug('ERROR:' + d.msg);
        //       callback({
        //         status: 'error',
        //         msg: d.msg,
        //       });
        //     }
        //   });
        // };
        this.getCurrentTime = function (representation, curTime, _callback) {
            var self = _this;
            var time;
            var bufferedIndex;
            var callback = _callback || (function () { });
            if (!representation) {
                callback({
                    status: 'error',
                    msg: 'no representation',
                });
            }
            bufferedIndex = _this.requestStatus[representation.adaptation.type].index;
            _this.getSegments.call(self, representation, function (d) {
                if (d.status === 'ok') {
                    var segments = d.data;
                    if (bufferedIndex < 0) {
                        if (!_this.isDynamic) {
                            time = curTime;
                        }
                        else {
                            time = curTime;
                        }
                    }
                    else {
                        bufferedIndex =
                            bufferedIndex < segments[0].availabilityIdx
                                ? segments[0].availabilityIdx
                                : Math.min(segments[segments.length - 1].availabilityIdx, bufferedIndex);
                        time = _this.getSegmentByIndex(bufferedIndex, representation).presentationStartTime;
                    }
                    callback({
                        status: 'ok',
                        data: time,
                    });
                }
                else {
                    _this.NXDebug.debug('ERROR:' + d.msg);
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        this.parseSIDX = function (ab, ab_first_byte_offset) {
            var d = new DataView(ab);
            var sidx = {};
            var pos = 0;
            var offset;
            var time;
            var sidxEnd;
            var ref_type;
            var ref_size;
            var ref_dur;
            var type;
            var size;
            var charCode;
            var firstOffset = -1;
            var sidxPos = -1;
            while ((sidxPos < 0 || firstOffset < 0) && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    charCode = d.getInt8(pos);
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }
                if (type !== 'moof' && type !== 'traf' && type !== 'sidx') {
                    // eslint-disable-line no-empty
                }
                else if (type === 'sidx') {
                    // reset the position to the beginning of the box...
                    // if we do not reset the position, the evaluation
                    // of sidxEnd to ab.byteLength will fail.
                    sidxPos = pos - 8;
                }
                else if (type === 'moof') {
                    firstOffset = pos - 8;
                }
                pos += size - 8;
            }
            if (sidxPos < 0) {
                sidx.reference_count = 0;
                return sidx;
            }
            pos = sidxPos;
            sidxEnd = d.getUint32(pos, false) + pos;
            if (sidxEnd > ab.byteLength) {
                throw 'sidx terminates after array buffer';
            }
            sidx.version = d.getUint8(pos + 8);
            pos += 12;
            // skipped reference_ID(32)
            sidx.timescale = d.getUint32(pos + 4, false);
            pos += 8;
            if (sidx.version === 0) {
                sidx.earliest_presentation_time = d.getUint32(pos, false);
                sidx.first_offset = d.getUint32(pos + 4, false);
                pos += 8;
            }
            else {
                sidx.earliest_presentation_time = tmp64BitNumber(d.getUint32(pos, false), d.getUint32(pos + 4, false));
                sidx.first_offset = tmp64BitNumber(d.getUint32(pos + 8, false), d.getUint32(pos + 12, false));
                pos += 16;
            }
            sidx.first_offset +=
                (firstOffset >= 0 ? firstOffset : sidxEnd) + (ab_first_byte_offset || 0);
            // skipped reserved(16)
            sidx.reference_count = d.getUint16(pos + 2, false);
            pos += 4;
            sidx.references = [];
            offset = sidx.first_offset;
            time = sidx.earliest_presentation_time;
            for (var i = 0; i < sidx.reference_count; i += 1) {
                ref_size = d.getUint32(pos, false);
                ref_type = ref_size >>> 31;
                ref_size = ref_size & 0x7fffffff;
                ref_dur = d.getUint32(pos + 4, false);
                pos += 12;
                sidx.references.push({
                    size: ref_size,
                    type: ref_type,
                    offset: offset,
                    duration: ref_dur,
                    time: time,
                    timescale: sidx.timescale,
                });
                offset += ref_size;
                time += ref_dur;
            }
            if (pos !== sidxEnd) {
                throw 'Error: final pos ' + pos + ' differs from SIDX end ' + sidxEnd;
            }
            return sidx;
        };
        this.parseSegments = function (data, media, offset) {
            var parsed;
            var ref;
            var segments;
            var segment;
            var start;
            var end;
            parsed = _this.parseSIDX.call(_this, data, offset);
            ref = parsed.references;
            segments = [];
            var t_time = 0;
            var t_dur = 0;
            var t_size = 0;
            var t_offset = 0;
            var t_timescale = 0;
            if (isNaN(_this.MIN_SEGSIZE_FORBASE)) {
                for (var i = 0, len = ref.length; i < len; i += 1) {
                    segment = new Segment();
                    segment.duration = ref[i].duration;
                    segment.media = media;
                    segment.startTime = ref[i].time;
                    segment.timescale = ref[i].timescale;
                    start = ref[i].offset;
                    end = ref[i].offset + ref[i].size - 1;
                    segment.mediaRange = start + '-' + end;
                    segments.push(segment);
                }
            }
            else {
                for (var i = 0, len = ref.length; i < len; i += 1) {
                    if (t_dur == 0) {
                        t_time = ref[i].time;
                        t_dur = ref[i].duration;
                        t_size = ref[i].size;
                        t_offset = ref[i].offset;
                        t_timescale = ref[i].timescale;
                    }
                    else {
                        t_dur += ref[i].duration;
                        t_size += ref[i].size;
                    }
                    if (t_dur / ref[i].timescale >= _this.MIN_SEGSIZE_FORBASE ||
                        i == ref.length - 1) {
                        segment = new Segment();
                        segment.duration = t_dur;
                        segment.media = media;
                        segment.startTime = t_time;
                        segment.timescale = t_timescale;
                        start = t_offset;
                        end = t_offset + t_size - 1;
                        segment.mediaRange = start + '-' + end;
                        segments.push(segment);
                        t_dur = 0;
                    }
                }
            }
            _this.NXDebug.debug('Parsed SIDX box: ' + segments.length + ' segments.');
            return segments;
        };
        this.requestWithRange = function (request, url, range, init) {
            var qrys = _this.commonQrys.concat();
            var hdrs = _this.commonHdrs.concat();
            if (range != null) {
                qrys.push({
                    name: 'range',
                    value: range,
                });
                hdrs.push({
                    name: 'Range',
                    value: 'bytes=' + range,
                });
            }
            request.url = url;
            _this.onPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: request,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            if (!_this.useFetch) {
                request.open('GET', request.url, true);
                request.responseType = 'arraybuffer';
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        request.setRequestHeader(hdr.name, hdr.value);
                    });
                }
                request.send(null);
            }
            else {
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        init.headers[hdr.name] = hdr.value;
                    });
                }
            }
        };
        this.findInit = function (data, info, _callback) {
            var callback = _callback || (function () { });
            var start;
            var end;
            var d = new DataView(data);
            var pos = 0;
            var type = '';
            var size = 0;
            var c;
            var request;
            var loaded = false;
            var irange;
            var self = _this;
            _this.NXDebug.log('Searching for initialization.');
            while (type !== 'moov' && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    c = d.getInt8(pos);
                    type += String.fromCharCode(c);
                    pos += 1;
                }
                if (type !== 'moov') {
                    pos += size - 8;
                }
            }
            if (type !== 'moov') {
                // Case 1
                // We didn't download enough bytes to find the moov.
                // TODO : Load more bytes.
                //        Be sure to detect EOF.
                //        Throw error is no moov is found in the entire file.
                //        Protection from loading the entire file?
                _this.NXDebug.log('Loading more bytes to find initialization.');
                info.range.start = 0;
                info.range.end = info.bytesLoaded + info.bytesToLoad;
                if (!_this.useFetch) {
                    request = new XMLHttpRequest();
                    request.onloadend = function () {
                        if (!loaded) {
                            callback({
                                status: 'error',
                                msg: 'Error loading initialization',
                            });
                        }
                    };
                    request.onload = function () {
                        loaded = true;
                        info.bytesLoaded = info.range.end;
                        _this.onSuccess({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.findInit.call(self, request.response, info, function (d) {
                            if (d.status === 'ok') {
                                callback({
                                    status: 'ok',
                                    data: d.data,
                                });
                            }
                            else {
                                callback({
                                    status: 'error',
                                    msg: 'Error loading initialization',
                                });
                            }
                        });
                    };
                    request.onerror = function () {
                        _this.onError({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        callback({
                            status: 'error',
                            msg: 'Error loading initialization',
                        });
                    };
                    _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, null);
                }
                else {
                    var acon = {
                        aborted: false,
                    };
                    var init = {
                        method: 'GET',
                        headers: {},
                        credentials: 'same-origin',
                    };
                    request = {};
                    _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, init);
                    abortWrapper(fetch(request.url, init), acon)
                        .then(function (res) {
                        info.bytesLoaded = info.range.end;
                        if (res.ok == true) {
                            return res.arrayBuffer();
                        }
                        else {
                            return Promise.reject(new Error('res.false'));
                        }
                    })
                        .then(function (ab) {
                        info.bytesLoaded = info.range.end;
                        _this.onSuccess({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.findInit.call(self, ab, info, function (d) {
                            if (d.status === 'ok') {
                                callback({
                                    status: 'ok',
                                    data: d.data,
                                });
                            }
                            else {
                                callback({
                                    status: 'error',
                                    msg: 'Error loading initialization',
                                });
                            }
                        });
                    })
                        .catch(function (_err) {
                        _this.onError({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        callback({
                            status: 'error',
                            msg: 'Error loading initialization',
                        });
                    });
                }
            }
            else {
                // Case 2
                // We have the entire range, so continue.
                start = pos - 8;
                end = start + size - 1;
                irange = start + '-' + end;
                _this.NXDebug.log('Found the initialization.  Range: ' + irange);
                callback({
                    status: 'ok',
                    data: irange,
                });
            }
        };
        this.loadInitializationX = function (media, _callback) {
            var callback = _callback || (function () { });
            var request = new XMLHttpRequest();
            var needFailureReport = true;
            var self = _this;
            var info = {
                url: media,
                range: {},
                searching: false,
                bytesLoaded: 0,
                bytesToLoad: 1500,
                request: request,
            };
            _this.NXDebug.log('Start searching for initialization.');
            info.range.start = 0;
            info.range.end = info.bytesToLoad;
            request.onload = function () {
                if (request.status < 200 || request.status > 299) {
                    return;
                }
                needFailureReport = false;
                info.bytesLoaded = info.range.end;
                _this.onSuccess({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                _this.findInit.call(self, request.response, info, function (d) {
                    if (d.status === 'ok') {
                        callback({
                            status: 'ok',
                            data: d.data,
                        });
                    }
                    else {
                        callback({
                            status: 'error',
                            msg: 'findInit error',
                        });
                    }
                });
            };
            request.onloadend = request.onerror = function () {
                if (!needFailureReport) {
                    return;
                }
                needFailureReport = false;
                _this.onError({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                _this.errHandler.downloadError(_this.eventBus, 'initialization', info.url, request);
                callback({
                    status: 'error',
                    msg: 'initialization load error',
                });
            };
            _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, null);
            _this.NXDebug.log('Perform init search: ' + info.url);
        };
        this.loadInitializationF = function (media, _callback) {
            var callback = _callback || (function () { });
            var acon = {
                aborted: false,
            };
            var request = {};
            var init = {
                method: 'GET',
                headers: {},
                credentials: 'same-origin',
            };
            var self = _this;
            var info = {
                url: media,
                range: {},
                searching: false,
                bytesLoaded: 0,
                bytesToLoad: 1500,
                request: request,
            };
            _this.NXDebug.log('Start searching for initialization.');
            info.range.start = 0;
            info.range.end = info.bytesToLoad;
            _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, init);
            _this.NXDebug.log('Perform init search: ' + info.url);
            abortWrapper(fetch(request.url, init), acon)
                .then(function (res) {
                if (res.ok == true) {
                    return res.arrayBuffer();
                }
                else {
                    return Promise.reject(new Error('res.false'));
                }
            })
                .then(function (ab) {
                info.bytesLoaded = info.range.end;
                _this.onSuccess({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                _this.findInit.call(self, ab, info, function (d) {
                    if (d.status === 'ok') {
                        callback({
                            status: 'ok',
                            data: d.data,
                        });
                    }
                    else {
                        callback({
                            status: 'error',
                            msg: 'findInit error',
                        });
                    }
                });
            })
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                .catch(function (_err) {
                _this.onError({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                _this.errHandler.downloadError(_this.eventBus, 'initialization', info.url, request);
                callback({
                    status: 'error',
                    msg: 'initialization load error',
                });
            });
        };
        this.loadInitialization = function (media, _callback) {
            return _this.useFetch
                ? _this.loadInitializationF(media, _callback)
                : _this.loadInitializationX(media, _callback);
        };
        /* istanbul ignore next */
        this.extractChunk = function (q, tlen, inEventList, avtype) {
            var sidxs = [];
            var u8s = q.progress;
            var offset = q.chunkEnd;
            var pos = offset;
            var type;
            var size;
            var charCode;
            var emsgs = [];
            var curChunkEnd = offset;
            var nextChunkEnd = 0;
            var curChunkDur = q.chunkDur;
            var nextChunkDur = 0;
            var chunkDur = 0;
            var chunkStartTime = 0;
            var curChunkStartTime = q.chunkStartTime;
            var nextChunkStartTime = -1;
            var defaultSampleDuration = 0;
            var d = function (pos) {
                var len = 0;
                for (var i = 0; i < u8s.length; i++) {
                    len += u8s[i].length;
                    if (pos < len) {
                        return u8s[i][u8s[i].length - (len - pos)];
                    }
                }
                return null;
            };
            var set = function (data, pos) {
                var len = 0;
                var clen = 0;
                for (var i = 0; i < u8s.length; i++) {
                    clen = u8s[i].length;
                    if (pos < len + clen) {
                        u8s[i][pos - len] = data;
                        return;
                    }
                    len += clen;
                }
            };
            var getBytes = function (u8s, offset, size) {
                var len = 0;
                var pos = offset;
                var out;
                var clen = 0;
                var osize = 0;
                if (tlen - offset < size) {
                    return null;
                }
                out = new Uint8Array(size);
                for (var i = 0; i < u8s.length; i++) {
                    clen = u8s[i].length;
                    while (pos < len + clen) {
                        out[osize] = u8s[i][pos - len];
                        osize++;
                        if (osize == size) {
                            return out;
                        }
                        pos++;
                    }
                    len += clen;
                }
                return null;
            };
            var getUint32 = function (b, pos) {
                return ((b(pos) & 0xff) * Math.pow(2, 24) +
                    (((b(pos + 1) & 0xff) << 16) |
                        ((b(pos + 2) & 0xff) << 8) |
                        (b(pos + 3) & 0xff)));
            };
            var getUint16 = function (b, pos) {
                return ((b(pos) & 0xff) << 8) | (b(pos + 1) & 0xff);
            };
            var getInt32 = function (b, pos) {
                var tdv = new DataView(new ArrayBuffer(4));
                tdv.setUint8(0, b(pos));
                tdv.setUint8(1, b(pos + 1));
                tdv.setUint8(2, b(pos + 2));
                tdv.setUint8(3, b(pos + 3));
                return tdv.getInt32(0);
            };
            var version;
            var end;
            var _loop_1 = function () {
                size = getUint32(d, pos); // subtract 8 for including the size and type
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    charCode = d(pos);
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }
                if (type !== 'emsg' &&
                    type !== 'moof' &&
                    type !== 'traf' &&
                    type !== 'tfdt' &&
                    type !== 'tfhd' &&
                    type !== 'trun' &&
                    type !== 'mdat' &&
                    type !== 'sidx') {
                    pos += size - 8;
                }
                else if (type === 'emsg') {
                    var e = {};
                    version = d(pos);
                    e.typePos = pos - 4;
                    e.data = getBytes(u8s, pos - 8, size);
                    if (version == 1) {
                        _this.parseEmsg(e.data, 0, e.data.length, NaN, inEventList);
                        set(0x66, e.typePos);
                        set(0x72, e.typePos + 1);
                        set(0x65, e.typePos + 2);
                        set(0x65, e.typePos + 3);
                    }
                    else {
                        emsgs.push(e);
                    }
                    pos += size - 8;
                }
                else if (type === 'sidx') {
                    if (_this.deleteUnnecessaryBox == true) {
                        var s = {};
                        s.typePos = pos - 4;
                        sidxs.push(s);
                    }
                    pos += size - 8;
                }
                else if (type === 'moof') {
                    // eslint-disable-line no-empty
                }
                else if (type === 'traf') {
                    // eslint-disable-line no-empty
                }
                else if (type == 'tfdt') {
                    var baseMediaDecodeTime = 0;
                    end = pos + size - 8;
                    version = d(pos);
                    pos += 1;
                    pos += 3; // skip flag (24)
                    if (version == 0) {
                        baseMediaDecodeTime = getUint32(d, pos);
                    }
                    else {
                        baseMediaDecodeTime = tmp64BitNumber(getUint32(d, pos), getUint32(d, pos + 4));
                    }
                    var ttime_1 = baseMediaDecodeTime / q.params.timescale + q.offset;
                    chunkStartTime += ttime_1;
                    emsgs.forEach(function (e) {
                        e.startTime = ttime_1;
                        _this.parseEmsg(e.data, 0, e.data.length, e.startTime, inEventList);
                        set(0x66, e.typePos);
                        set(0x72, e.typePos + 1);
                        set(0x65, e.typePos + 2);
                        set(0x65, e.typePos + 3);
                    });
                    emsgs = [];
                    pos = end;
                }
                else if (type === 'tfhd') {
                    var flags_l = void 0;
                    end = pos + size - 8;
                    pos += 1; //version
                    pos += 2; //flags_h
                    flags_l = d(pos);
                    pos++;
                    pos += 4; // trackID
                    if (flags_l & 0x01) {
                        pos += 8; //base_data_offset;
                    }
                    if (flags_l & 0x02) {
                        pos += 4; //sample_description_index;
                    }
                    if (flags_l & 0x08) {
                        defaultSampleDuration = getUint32(d, pos);
                        pos += 4; //default_sample_duration
                    }
                    else {
                        defaultSampleDuration = q.params.dsd;
                    }
                    if (flags_l & 0x10) {
                        pos += 4; //default_sample_size
                    }
                    if (flags_l & 0x20) {
                        if (avtype == 'audio') {
                            if ((d(pos) & 0x01) == 1) {
                                //sample_depends_on
                                set(d(pos) + 1, pos);
                            }
                            if ((d(pos + 1) & 0x01) == 1) {
                                //sample_is_non_sync_sample;
                                set(d(pos + 1) - 1, pos + 1);
                            }
                        }
                        pos += 4; //default_sample_flag
                    }
                    pos = end;
                }
                else if (type === 'trun') {
                    var sampleCount = void 0;
                    var dflags = void 0;
                    var sflags = void 0;
                    var fflags = void 0;
                    var cflags = void 0;
                    end = pos + size - 8;
                    version = d(pos);
                    pos += 1; //version
                    var flags_h = getUint16(d, pos);
                    pos += 2;
                    var flags_l = d(pos);
                    pos += 1;
                    dflags = flags_h & 0x01;
                    sflags = flags_h & 0x02;
                    fflags = flags_h & 0x04;
                    cflags = flags_h & 0x08;
                    sampleCount = getUint32(d, pos);
                    pos += 4;
                    if (flags_l & 0x01) {
                        pos += 4; //data_offset
                    }
                    if (flags_l & 0x04) {
                        pos += 4; //first_sample_flags
                    }
                    if (!dflags) {
                        chunkDur =
                            (defaultSampleDuration * sampleCount) / q.params.timescale;
                        if (cflags) {
                            //composition_time_offset of first sample
                            //pos += 4 * ((sflags != 0) + (fflags != 0));
                            if (sflags) {
                                pos += 4; //sample_size
                            }
                            if (fflags) {
                                pos += 4; //sample_flags
                            }
                            chunkStartTime +=
                                (version
                                    ? getInt32(d, pos) / q.params.timescale
                                    : getUint32(d, pos)) / q.params.timescale;
                        }
                    }
                    else {
                        var tdur = 0;
                        for (var i = 0; i < sampleCount; i++) {
                            tdur += getUint32(d, pos);
                            pos += 4;
                            if (sflags) {
                                pos += 4; //sample_size
                            }
                            if (fflags) {
                                pos += 4; //sample_flags
                            }
                            if (cflags) {
                                if (i == 0) {
                                    chunkStartTime +=
                                        (version
                                            ? getInt32(d, pos) / q.params.timescale
                                            : getUint32(d, pos)) / q.params.timescale;
                                }
                                pos += 4; //sample_composition_time_offset
                            }
                        }
                        chunkDur = tdur / q.params.timescale;
                    }
                    pos = end;
                }
                else if (type === 'mdat') {
                    end = pos + size - 8;
                    if (end <= tlen) {
                        curChunkEnd = end;
                        curChunkDur += chunkDur;
                        if (curChunkStartTime < 0)
                            curChunkStartTime = chunkStartTime;
                    }
                    else {
                        nextChunkEnd = end;
                        nextChunkDur = chunkDur;
                        nextChunkStartTime = chunkStartTime;
                    }
                    pos = end;
                    if (_this.deleteUnnecessaryBox == true) {
                        sidxs.forEach(function (s) {
                            set(0x66, s.typePos);
                            set(0x72, s.typePos + 1);
                            set(0x65, s.typePos + 2);
                            set(0x65, s.typePos + 3);
                        });
                        sidxs = [];
                    }
                }
            };
            while (pos + 8 < tlen) {
                _loop_1();
            }
            return {
                curChunkEnd: curChunkEnd,
                nextChunkEnd: nextChunkEnd,
                curChunkDur: curChunkDur,
                nextChunkDur: nextChunkDur,
                curChunkStartTime: curChunkStartTime,
                nextChunkStartTime: nextChunkStartTime,
            };
        };
        this.parseEmsg = function (data, offset, size, startTime, inEventList) {
            var i = offset;
            var expTwo = Math.pow(256, 2);
            var expThree = Math.pow(256, 3);
            var segmentStarttime = Math.max(isNaN(startTime) ? 0 : startTime, 0);
            var version = data[i + 8];
            var getEvent = function (list, id) {
                for (var i_1 = 0; i_1 < list.length; i_1++) {
                    if (list[i_1].id != null && list[i_1].id == id)
                        return true;
                }
                return false;
            };
            // emsg-box: http://standards.iso.org/ittf/PubliclyAvailableStandards/c068960_ISO_IEC_14496-12_2015.zip
            var schemeIdUri = undefined;
            var value = undefined;
            var timescale = 1;
            var presentationTimeDelta = 0;
            var duration = 0;
            var id = 0;
            var messageData = undefined;
            var presentationTime = 0;
            var de = {};
            var ne = false;
            var _eventList;
            var eventBox = [];
            var arrIndex = 0;
            var j;
            if (version == 0) {
                eventBox = ['', '', 0, 0, 0, 0];
                arrIndex = 0;
                j = i + 12; //fullbox header is 12 bytes, thats why we start at 12
                while (j < size + i) {
                    // == string terminates with 0, this indicates end of attribute == //
                    if (arrIndex === 0 || arrIndex == 1) {
                        if (data[j] !== 0) {
                            eventBox[arrIndex] += String.fromCharCode(data[j]);
                        }
                        else {
                            arrIndex += 1;
                        }
                        j += 1;
                    }
                    else if (arrIndex == 6) {
                        eventBox[arrIndex] = data.subarray(j, size);
                        j = size + i;
                    }
                    else {
                        eventBox[arrIndex] =
                            data[j] * expThree +
                                data[j + 1] * expTwo +
                                data[j + 2] * 256 +
                                data[j + 3] * 1;
                        j += 4;
                        arrIndex += 1;
                    }
                }
                // MpegDashEvent in W3C MediaTimedEvent: https://w3c.github.io/me-media-timed-events/#mpeg-dash
                schemeIdUri = eventBox[0];
                value = eventBox[1];
                timescale = eventBox[2];
                presentationTimeDelta = eventBox[3];
                duration = eventBox[4];
                id = eventBox[5];
                messageData = eventBox[6];
                presentationTime =
                    (segmentStarttime * timescale + presentationTimeDelta) / timescale;
                //de = {},
                //ne=false,
                //_eventList;
            }
            else {
                eventBox = [0, 0, 0, 0, '', ''];
                arrIndex = 0;
                j = i + 12; //fullbox header is 12 bytes, thats why we start at 12
                while (j < size + i) {
                    // == string terminates with 0, this indicates end of attribute == //
                    if (arrIndex === 4 || arrIndex == 5) {
                        if (data[j] !== 0) {
                            eventBox[arrIndex] += String.fromCharCode(data[j]);
                        }
                        else {
                            arrIndex += 1;
                        }
                        j += 1;
                    }
                    else if (arrIndex == 6) {
                        eventBox[arrIndex] = data.subarray(j, size);
                        j = size + i;
                    }
                    else if (arrIndex == 1) {
                        var h = data[j] * expThree +
                            data[j + 1] * expTwo +
                            data[j + 2] * 256 +
                            data[j + 3] * 1;
                        var l = data[j + 4] * expThree +
                            data[j + 5] * expTwo +
                            data[j + 6] * 256 +
                            data[j + 7] * 1;
                        eventBox[arrIndex] = tmp64BitNumber(h, l);
                        j += 8;
                        arrIndex += 1;
                    }
                    else {
                        eventBox[arrIndex] =
                            data[j] * expThree +
                                data[j + 1] * expTwo +
                                data[j + 2] * 256 +
                                data[j + 3] * 1;
                        j += 4;
                        arrIndex += 1;
                    }
                }
                schemeIdUri = eventBox[4];
                value = eventBox[5];
                timescale = eventBox[0];
                presentationTime = eventBox[1] / timescale;
                duration = eventBox[2];
                id = eventBox[3];
                messageData = eventBox[6];
                presentationTimeDelta = 0;
            }
            de.schemeIdUri = schemeIdUri;
            de.value = value;
            de.timescale = timescale;
            de.duration = duration;
            de.id = id;
            de.presentationTime = presentationTime;
            de.messageData = messageData;
            de.presentationTimeDelta = presentationTimeDelta;
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(inEventList, schemeIdUri)) {
                if (getEvent(inEventList[schemeIdUri], de.id) == false) {
                    inEventList[schemeIdUri].push(de);
                    _eventList = inEventList[schemeIdUri];
                    ne = true;
                }
            }
            else {
                inEventList[schemeIdUri] = [];
                inEventList[schemeIdUri].push(de);
                _eventList = inEventList[schemeIdUri];
                ne = true;
            }
            if (ne) {
                _this.eventBus.dispatchEvent({
                    type: 'DASHEVENT_RECEIVED',
                    data: {
                        type: 'inband',
                        event: de,
                        eventList: _eventList,
                        index: _eventList.length - 1,
                    },
                });
            }
            data[i + 4] = 0x66;
            data[i + 5] = 0x72;
            data[i + 6] = 0x65;
            data[i + 7] = 0x65; //convert to free
        };
        /* istanbul ignore next */
        this.extractIDRinMOOF = function (u8, _timescale, codecs) {
            var d = u8;
            var pos = 0;
            var timescale = _timescale || 1;
            var type;
            var size;
            var charCode;
            var moofs = [];
            var moofCnt = 0;
            var getUint32 = function (_b, pos) {
                return (d[pos] & 0xff) * Math.pow(2, 24) +
                    (((d[pos + 1] & 0xff) << 16) |
                        ((d[pos + 2] & 0xff) << 8) |
                        (d[pos + 3] & 0xff));
            };
            var getUint16 = function (b, pos) {
                return ((b[pos] & 0xff) << 8) | (b[pos + 1] & 0xff);
            };
            var setUint32 = function (b, pos, v) {
                //b[pos] = (v>>24)&0xFF;
                b[pos] = (v / Math.pow(2, 24)) & 0xff;
                b[pos + 1] = (v >> 16) & 0xff;
                b[pos + 2] = (v >> 8) & 0xff;
                b[pos + 3] = v & 0xff;
            };
            var setUint16 = function (b, pos, v) {
                b[pos] = (v >> 8) & 0xff;
                b[pos + 1] = v & 0xff;
            };
            var end;
            var version;
            var flags_h;
            var flags_l;
            var cp;
            while (pos < d.length) {
                size = getUint32(d, pos); // subtract 8 for including the size and type
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    charCode = d[pos];
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }
                if (type !== 'moof' &&
                    type !== 'traf' &&
                    type !== 'tfhd' &&
                    type !== 'tfdt' &&
                    type !== 'trun' &&
                    type !== 'mdat' &&
                    type != 'senc' &&
                    type != 'saio') {
                    pos += size - 8;
                }
                else if (type === 'moof') {
                    var offset = pos - 8;
                    moofs.push({
                        offset: offset,
                    });
                    moofs[moofCnt].moofPos = offset;
                    moofs[moofCnt].moofSize = size;
                    moofCnt++;
                }
                else if (type === 'traf') {
                    moofs[moofCnt - 1].trafPos = pos - 8;
                    moofs[moofCnt - 1].trafSize = size;
                }
                else if (type === 'tfhd') {
                    end = pos + size - 8;
                    pos += 1; //version
                    flags_h = getUint16(d, pos);
                    pos += 2;
                    flags_l = d[pos];
                    pos++;
                    pos += 4; // trackID
                    if (flags_l & 0x01) {
                        pos += 8; //base_data_offset;
                    }
                    if (flags_l & 0x02) {
                        pos += 4; //sample_description_index;
                    }
                    if (flags_l & 0x08) {
                        moofs[moofCnt - 1].defaultSampleDuration = getUint32(d, pos);
                        pos += 4; //default_sample_duration
                    }
                    if (flags_l & 0x10) {
                        moofs[moofCnt - 1].defaultSampleSize = getUint32(d, pos);
                        pos += 4; //default_sample_size
                    }
                    if (flags_l & 0x20) {
                        moofs[moofCnt - 1].defaultSampleFlags = getUint32(d, pos);
                        pos += 4;
                    }
                    pos = end;
                }
                else if (type === 'tfdt') {
                    var baseMediaDecodeTime = 0;
                    end = pos + size - 8;
                    version = d[pos];
                    pos += 1;
                    pos += 3; // skip flag (24)
                    if (version == 0) {
                        baseMediaDecodeTime = getUint32(d, pos);
                    }
                    else {
                        baseMediaDecodeTime = tmp64BitNumber(getUint32(d, pos), getUint32(d, pos + 4));
                    }
                    var ttime = baseMediaDecodeTime / timescale;
                    moofs[moofCnt - 1].time = ttime;
                    pos = end;
                }
                else if (type === 'trun') {
                    moofs[moofCnt - 1].trunPos = pos - 8;
                    moofs[moofCnt - 1].trunSize = size;
                    end = pos + size - 8;
                    version = d[pos];
                    pos += 1;
                    flags_h = getUint16(d, pos);
                    flags_l = d[pos + 2];
                    pos += 3;
                    var sampleCount = getUint32(d, pos);
                    var dataOffset = 0;
                    var firstSampleFlags = 0;
                    var dflags = flags_h & 0x01;
                    var sflags = flags_h & 0x02;
                    var fflags = flags_h & 0x04;
                    var cflags = flags_h & 0x08;
                    var poffset = void 0;
                    if (!fflags) {
                        var nTrunArray = new ArrayBuffer(size + sampleCount * 4);
                        var nTrun = new Uint8Array(nTrunArray);
                        var raps = 0;
                        cp = 0;
                        setUint32(nTrun, cp, size + sampleCount * 4);
                        cp += 4;
                        setUint32(nTrun, cp, 0x7472756e);
                        cp += 4;
                        nTrun[cp] = version;
                        cp += 1;
                        setUint16(nTrun, cp, flags_h + 0x4);
                        cp += 2;
                        nTrun[cp] = flags_l - 0x4;
                        cp++;
                        setUint32(nTrun, cp, sampleCount);
                        cp += 4;
                        pos += 4;
                        if (flags_l & 0x01) {
                            dataOffset = getUint32(d, pos);
                            pos += 4;
                            setUint32(nTrun, cp, dataOffset + sampleCount * 4);
                            cp += 4;
                        }
                        if (flags_l & 0x04) {
                            firstSampleFlags = getUint32(d, pos);
                            pos += 4;
                        }
                        poffset = dataOffset + moofs[moofCnt - 1].moofPos;
                        for (var i = 0; i < sampleCount; i++) {
                            var sz = 0;
                            if (dflags) {
                                setUint32(nTrun, cp, getUint32(d, pos));
                                pos += 4;
                                cp += 4;
                            }
                            if (sflags) {
                                sz = getUint32(d, pos);
                                pos += 4;
                                setUint32(nTrun, cp, sz);
                                cp += 4;
                            }
                            //mdat
                            var mp = poffset;
                            var nsize = void 0;
                            var nal_unit_type = void 0;
                            while (mp < poffset + sz) {
                                nsize = getUint32(d, mp);
                                mp += 4;
                                if (codecs.indexOf('avc') > -1) {
                                    nal_unit_type = d[mp] & 0x1f;
                                    if (nal_unit_type == 5) {
                                        setUint32(nTrun, cp, firstSampleFlags);
                                        cp += 4;
                                        raps++;
                                        break;
                                    }
                                    else if (nal_unit_type == 1) {
                                        if (i == 0) {
                                            setUint32(nTrun, cp, firstSampleFlags);
                                            raps++;
                                        }
                                        else if (moofs[moofCnt - 1].defaultSampleFlags) {
                                            setUint32(nTrun, cp, moofs[moofCnt - 1].defaultSampleFlags);
                                        }
                                        else {
                                            setUint32(nTrun, cp, 65536);
                                        }
                                        cp += 4;
                                        break;
                                    }
                                    else {
                                        // eslint-disable-line no-empty
                                    }
                                }
                                else {
                                    nal_unit_type = (d[mp] >> 1) & 0x3f;
                                    if (nal_unit_type == 19 || nal_unit_type == 20) {
                                        setUint32(nTrun, cp, firstSampleFlags);
                                        cp += 4;
                                        raps++;
                                        break;
                                    }
                                    else if (nal_unit_type < 19) {
                                        if (i == 0) {
                                            setUint32(nTrun, cp, firstSampleFlags);
                                            raps++;
                                        }
                                        else if (moofs[moofCnt - 1].defaultSampleFlags) {
                                            setUint32(nTrun, cp, moofs[moofCnt - 1].defaultSampleFlags);
                                        }
                                        else {
                                            setUint32(nTrun, cp, 65536);
                                        }
                                        cp += 4;
                                        break;
                                    }
                                    else {
                                        // eslint-disable-line no-empty
                                    }
                                }
                                mp += nsize;
                            }
                            poffset += sz;
                            if (cflags) {
                                setUint32(nTrun, cp, getUint32(d, pos));
                                pos += 4;
                                cp += 4;
                            }
                        }
                        if (raps < 2) {
                            return u8;
                        }
                        // pad (NULL);
                        setUint32(nTrun, cp, 0);
                        pos += 4;
                        moofs[moofCnt - 1].trunExp = fflags ? 0 : sampleCount * 4;
                        moofs[moofCnt - 1].modTrun = nTrun;
                        pos = end;
                        moofs[moofCnt - 1].trunEnd = pos;
                    }
                    else {
                        return u8;
                    }
                }
                else if (type === 'senc') {
                    moofs[moofCnt - 1].sencPos = pos - 8;
                    moofs[moofCnt - 1].sencSize = size;
                    pos = pos - 8 + size;
                }
                else if (type === 'saio') {
                    end = pos - 8 + size;
                    moofs[moofCnt - 1].checkSaio = true;
                    moofs[moofCnt - 1].saioPos = pos - 8;
                    moofs[moofCnt - 1].saioSize = size;
                    var entryCount = void 0;
                    version = d[pos];
                    pos++;
                    flags_h = getUint16(d, pos);
                    pos += 2;
                    flags_l = d[pos];
                    pos++;
                    if (flags_l & 0x01) {
                        pos += 8;
                    }
                    entryCount = getUint32(d, pos);
                    pos += 4;
                    if (entryCount > 1) {
                        return u8;
                    }
                    moofs[moofCnt - 1].saioOffsetPos = pos;
                    moofs[moofCnt - 1].saioVersion = version;
                    pos = end;
                }
                else if (type === 'mdat') {
                    moofs[moofCnt - 1].mdatPos = pos - 8;
                    moofs[moofCnt - 1].mdatSize = size;
                    pos = pos - 8 + size;
                }
            }
            var modSize = 0;
            for (var i = 0; i < moofs.length; i++) {
                modSize += moofs[i].moofSize + moofs[i].mdatSize + moofs[i].trunExp;
            }
            var modArray = new ArrayBuffer(modSize);
            var modData = new Uint8Array(modArray);
            cp = 0;
            for (var i = 0; i < moofs.length; i++) {
                var m = moofs[i];
                var tmp = void 0;
                var newPos = cp;
                tmp = u8.subarray(m.moofPos, m.trunPos);
                modData.set(tmp, cp);
                setUint32(modData, newPos, m.moofSize + m.trunExp);
                setUint32(modData, newPos + m.trafPos - m.moofPos, m.trafSize + m.trunExp);
                cp += tmp.length;
                modData.set(m.modTrun, cp);
                cp += m.modTrun.length;
                if (m.trunEnd != m.mdatPos) {
                    tmp = u8.subarray(m.trunEnd, m.mdatPos);
                    modData.set(tmp, cp);
                    if (m.checkSaio) {
                        if (m.sencPos < m.trunPos) {
                            // eslint-disable-line no-empty
                        }
                        else {
                            var tmpPos = void 0;
                            var soffset = 0;
                            tmpPos =
                                m.trunPos < m.saioPos
                                    ? m.saioOffsetPos - m.trunEnd + cp
                                    : m.saioOffsetPos - m.moofPos + newPos;
                            if (m.saioVersion == 0) {
                                soffset = getUint32(modData, tmpPos);
                                setUint32(modData, tmpPos, soffset + m.trunExp);
                            }
                            else {
                                soffset = getUint32(modData, tmpPos + 4);
                                setUint32(modData, tmpPos + 4, soffset + m.trunExp);
                            }
                        }
                    }
                    cp += m.mdatPos - m.trunEnd;
                }
                tmp = u8.subarray(m.mdatPos, m.mdatPos + m.mdatSize);
                modData.set(tmp, cp);
                cp += m.mdatSize;
            }
            u8 = void 0;
            return modData;
        };
        // decodeDTS = (
        //   ab: ArrayBuffer,
        //   dur: number,
        //   _timescale: number
        // ): Array<Moof> => {
        //   const d: DataView = new DataView(ab);
        //   let pos: number = 0;
        //   const timescale: number = _timescale || 1;
        //   let offset: number;
        //   let type: string;
        //   let size: number;
        //   let charCode: number;
        //   const moofs: Array<Moof> = [];
        //   let moofCnt: number = 0;
        //   while (pos < d.byteLength) {
        //     size = d.getUint32(pos); // subtract 8 for including the size and type
        //     pos += 4;
        //     type = '';
        //     for (let i = 0; i < 4; i += 1) {
        //       charCode = d.getInt8(pos);
        //       type += String.fromCharCode(charCode);
        //       pos += 1;
        //     }
        //     if (type !== 'moof' && type !== 'traf' && type !== 'tfdt') {
        //       pos += size - 8;
        //     } else if (type === 'moof') {
        //       offset = pos - 8;
        //       if (moofCnt == 0) {
        //         moofs.push({
        //           offset: 0,
        //         });
        //       } else {
        //         moofs.push({
        //           offset,
        //         });
        //       }
        //       moofCnt++;
        //     } else if (type === 'tfdt') {
        //       const end = pos + size - 8;
        //       const version = d.getUint8(pos);
        //       let baseMediaDecodeTime = 0;
        //       pos += 1;
        //       pos += 3; // skip flag (24)
        //       if (version == 0) {
        //         baseMediaDecodeTime = d.getUint32(pos, false);
        //       } else {
        //         baseMediaDecodeTime = tmp64BitNumber(
        //           d.getUint32(pos, false),
        //           d.getUint32(pos + 4, false)
        //         );
        //       }
        //       const ttime = baseMediaDecodeTime / timescale;
        //       moofs[moofCnt - 1].time = ttime;
        //       if (moofCnt > 1) {
        //         moofs[moofCnt - 2].dur = ttime - moofs[moofCnt - 2].time!;
        //         moofs[moofCnt - 2].size =
        //           moofs[moofCnt - 1].offset - moofs[moofCnt - 2].offset;
        //       }
        //       pos = end;
        //     }
        //   }
        //   if (moofCnt == 1) {
        //     moofs[0].dur = dur;
        //     moofs[0].size = d.byteLength;
        //   } else if (moofCnt > 1) {
        //     let tdur = 0;
        //     let tsize = 0;
        //     for (let i = 0; i < moofCnt - 1; i++) {
        //       tdur += moofs[i].dur!;
        //       tsize += moofs[i].size!;
        //     }
        //     moofs[moofCnt - 1].dur = dur - tdur;
        //     moofs[moofCnt - 1].size = d.byteLength - tsize;
        //   }
        //   return moofs;
        // };
        this.parseFragment = function (data, _timescale, dsd, mseTimeOffset, mtype, inEventList) {
            var pos = 0;
            var timescale = _timescale || 1;
            var offset;
            var type;
            var size;
            var charCode;
            var moofs = [];
            var emsgs = [];
            var moofCnt = 0;
            var startTime = 0;
            var defaultSampleDuration = 0;
            var getUint32 = function (b, pos) {
                return (b[pos] & 0xff) * Math.pow(2, 24) +
                    (((b[pos + 1] & 0xff) << 16) |
                        ((b[pos + 2] & 0xff) << 8) |
                        (b[pos + 3] & 0xff));
            };
            var getUint16 = function (b, pos) {
                return ((b[pos] & 0xff) << 8) | (b[pos + 1] & 0xff);
            };
            var getInt32 = function (b, pos) {
                var tdv = new DataView(new ArrayBuffer(4));
                tdv.setUint8(0, b[pos]);
                tdv.setUint8(1, b[pos + 1]);
                tdv.setUint8(2, b[pos + 2]);
                tdv.setUint8(3, b[pos + 3]);
                return tdv.getInt32(0);
            };
            var version;
            var end;
            while (pos < data.length) {
                size = getUint32(data, pos); // subtract 8 for including the size and type
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    charCode = data[pos];
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }
                if (type !== 'emsg' &&
                    type !== 'moof' &&
                    type !== 'traf' &&
                    type !== 'tfdt' &&
                    type !== 'tfhd' &&
                    type !== 'trun' &&
                    type !== 'sidx') {
                    pos += size - 8;
                }
                else if (type === 'emsg') {
                    var e = {};
                    e.sizePos = pos - 8;
                    e.size = size;
                    emsgs.push(e);
                    pos += size - 8;
                }
                else if (type === 'sidx') {
                    if (_this.deleteUnnecessaryBox == true) {
                        data[pos - 4] = 0x66;
                        data[pos - 3] = 0x72;
                        data[pos - 2] = 0x65;
                        data[pos - 1] = 0x65;
                    }
                    pos += size - 8;
                }
                else if (type === 'moof') {
                    offset = pos - 8;
                    if (moofCnt == 0) {
                        moofs.push({
                            time: 0,
                            offset: 0,
                        });
                    }
                    else {
                        moofs.push({
                            time: 0,
                            offset: offset,
                        });
                    }
                    moofCnt++;
                }
                else if (type === 'tfdt') {
                    var version_1 = data[pos];
                    var baseMediaDecodeTime = 0;
                    end = pos + size - 8;
                    pos += 1;
                    pos += 3; // skip flag (24)
                    if (version_1 == 0) {
                        baseMediaDecodeTime = getUint32(data, pos);
                    }
                    else {
                        baseMediaDecodeTime = tmp64BitNumber(getUint32(data, pos), getUint32(data, pos + 4));
                    }
                    startTime += baseMediaDecodeTime / timescale + mseTimeOffset;
                    moofs[moofCnt - 1].time += startTime;
                    if (moofCnt > 1) {
                        moofs[moofCnt - 2].size =
                            moofs[moofCnt - 1].offset - moofs[moofCnt - 2].offset;
                    }
                    if (emsgs.length > 0) {
                        emsgs.forEach(function (e) {
                            _this.parseEmsg(data, e.sizePos, e.size, startTime, inEventList);
                        });
                        emsgs = [];
                    }
                    pos = end;
                }
                else if (type === 'tfhd') {
                    var flags_l = void 0;
                    end = pos + size - 8;
                    pos += 1; //version
                    pos += 2; //flags_h
                    flags_l = data[pos];
                    pos++;
                    pos += 4; // trackID
                    if (flags_l & 0x01) {
                        pos += 8; //base_data_offset;
                    }
                    if (flags_l & 0x02) {
                        pos += 4; //sample_description_index;
                    }
                    if (flags_l & 0x08) {
                        defaultSampleDuration = getUint32(data, pos);
                        pos += 4; //default_sample_duration
                    }
                    else {
                        defaultSampleDuration = dsd;
                    }
                    if (flags_l & 0x10) {
                        pos += 4; //default_sample_size
                    }
                    if (flags_l & 0x20) {
                        if (mtype == 'audio') {
                            if ((data[pos] & 0x01) == 1) {
                                //sample_depends_on
                                data[pos] += 1;
                            }
                            if ((data[pos + 1] & 0x01) == 1) {
                                //sample_is_non_sync_sample
                                data[pos + 1] -= 1;
                            }
                        }
                        pos += 4; //default_sample_flag
                    }
                    moofs[moofCnt - 1].defaultSampleDuration = defaultSampleDuration;
                    pos = end;
                }
                else if (type === 'trun') {
                    var sampleCount = void 0;
                    var dflags = void 0;
                    var sflags = void 0;
                    var fflags = void 0;
                    var cflags = void 0;
                    var chunkDur = 0;
                    var cto = 0;
                    end = pos + size - 8;
                    version = data[pos];
                    pos += 1; //version
                    var flags_h = getUint16(data, pos);
                    pos += 2;
                    var flags_l = data[pos];
                    pos += 1;
                    dflags = flags_h & 0x01;
                    sflags = flags_h & 0x02;
                    fflags = flags_h & 0x04;
                    cflags = flags_h & 0x08;
                    sampleCount = getUint32(data, pos);
                    pos += 4;
                    if (flags_l & 0x01) {
                        pos += 4; //data_offset
                    }
                    if (flags_l & 0x04) {
                        pos += 4; //first_sample_flags
                    }
                    if (!dflags) {
                        chunkDur =
                            (moofs[moofCnt - 1].defaultSampleDuration * sampleCount) /
                                timescale;
                        //composition_time_offset of first sample
                        if (cflags) {
                            //pos += 4 * ((sflags != 0) + (fflags != 0));
                            if (sflags) {
                                pos += 4; //sample_size
                            }
                            if (fflags) {
                                pos += 4; //sample_flags
                            }
                            cto =
                                (version
                                    ? getInt32(data, pos) / timescale
                                    : getUint32(data, pos)) / timescale;
                            startTime += cto;
                            moofs[moofCnt - 1].time += cto;
                        }
                        //
                    }
                    else {
                        var tdur = 0;
                        for (var i = 0; i < sampleCount; i++) {
                            tdur += getUint32(data, pos);
                            pos += 4;
                            if (sflags) {
                                pos += 4; //sample_size
                            }
                            if (fflags) {
                                pos += 4; //sample_flags
                            }
                            if (cflags) {
                                if (i == 0) {
                                    cto =
                                        (version
                                            ? getInt32(data, pos) / timescale
                                            : getUint32(data, pos)) / timescale;
                                    startTime += cto;
                                    moofs[moofCnt - 1].time += cto;
                                }
                                pos += 4; //sample_composition_time_offset
                            }
                        }
                        chunkDur = tdur / timescale;
                    }
                    moofs[moofCnt - 1].dur = chunkDur;
                    pos = end;
                }
            }
            if (moofCnt == 1) {
                //moofs[0].dur = dur;
                moofs[0].size = data.length;
            }
            else if (moofCnt > 1) {
                moofs[moofCnt - 1].size = data.length - moofs[moofCnt - 1].offset;
            }
            return moofs;
        };
        // shiftDTS = (
        //   data: Uint8Array,
        //   MSETimeOffset: number,
        //   _timescale: number,
        //   tolerance: number
        // ): Uint8Array => {
        //   const ab: ArrayBuffer = new ArrayBuffer(data.length);
        //   const ab8: Uint8Array = new Uint8Array(ab);
        //   const d: DataView = new DataView(ab);
        //   const sidx: SIdx = {};
        //   let pos: number = 0;
        //   let timescale: number = _timescale || 1;
        //   let sidxEnd: number;
        //   let type: string;
        //   let size: number;
        //   let charCode: number;
        //   let end: number;
        //   ab8.set(data);
        //   while (pos < d.byteLength) {
        //     size = d.getUint32(pos); // subtract 8 for including the size and type
        //     pos += 4;
        //     type = '';
        //     for (let i = 0; i < 4; i += 1) {
        //       charCode = d.getInt8(pos);
        //       type += String.fromCharCode(charCode);
        //       pos += 1;
        //     }
        //     if (
        //       type !== 'moof' &&
        //       type !== 'traf' &&
        //       type !== 'sidx' &&
        //       type !== 'tfdt'
        //     ) {
        //       pos += size - 8;
        //     } else if (type === 'sidx') {
        //       end = pos + size - 8;
        //       pos -= 8;
        //       //pos += size - 8;
        //       sidxEnd = d.getUint32(pos, false) + pos;
        //       if (sidxEnd > ab.byteLength) {
        //         throw 'sidx terminates after array buffer';
        //       }
        //       sidx.version = d.getUint8(pos + 8);
        //       pos += 12;
        //       // skipped reference_ID(32)
        //       sidx.timescale = d.getUint32(pos + 4, false);
        //       timescale = sidx.timescale;
        //       pos += 8;
        //       if (sidx.version === 0) {
        //         sidx.earliest_presentation_time = d.getUint32(pos, false);
        //         sidx.first_offset = d.getUint32(pos + 4, false);
        //         pos += 8;
        //       } else {
        //         sidx.earliest_presentation_time = tmp64BitNumber(
        //           d.getUint32(pos, false),
        //           d.getUint32(pos + 4, false)
        //         );
        //         sidx.first_offset = tmp64BitNumber(
        //           d.getUint32(pos + 8, false),
        //           d.getUint32(pos + 12, false)
        //         );
        //         pos += 16;
        //       }
        //       pos = end;
        //     } else if (type === 'tfdt') {
        //       end = pos + size - 8;
        //       const version = d.getUint8(pos);
        //       let baseMediaDecodeTime = 0;
        //       pos += 1;
        //       pos += 3; // skip flag (24)
        //       if (version == 0) {
        //         baseMediaDecodeTime = d.getUint32(pos, false);
        //       } else {
        //         baseMediaDecodeTime = tmp64BitNumber(
        //           d.getUint32(pos, false),
        //           d.getUint32(pos + 4, false)
        //         );
        //         const modTime = baseMediaDecodeTime + timescale * MSETimeOffset;
        //         const tmp32bit = tmp64to32Bit(modTime);
        //         d.setUint32(pos, tmp32bit.high);
        //         d.setUint32(pos + 4, tmp32bit.low);
        //         this.NXDebug.log(
        //           'TFDT: version:' +
        //             version +
        //             ', scale:' +
        //             timescale +
        //             ', dts:' +
        //             baseMediaDecodeTime +
        //             ', modi:' +
        //             modTime
        //         );
        //         this.logHandler.log(
        //           'TFDT: version:' +
        //             version +
        //             ', scale:' +
        //             timescale +
        //             ', dts:' +
        //             baseMediaDecodeTime +
        //             ', modi:' +
        //             modTime
        //         );
        //       }
        //       this.NXDebug.log(
        //         'TFDT: version:' +
        //           version +
        //           ', scale:' +
        //           timescale +
        //           ', dts:' +
        //           baseMediaDecodeTime +
        //           ', tolerance:' +
        //           timescale * tolerance
        //       );
        //       this.logHandler.log(
        //         'TFDT: version:' +
        //           version +
        //           ', scale:' +
        //           timescale +
        //           ', dts:' +
        //           baseMediaDecodeTime +
        //           ', tolerance:' +
        //           timescale * tolerance
        //       );
        //       pos = end;
        //     }
        //   }
        //   return new Uint8Array(ab);
        // };
        this.checkAndConvertCodecType = function (d) {
            var getUint32 = function (pos) {
                return ((d[pos] & 0xff) << 24) |
                    ((d[pos + 1] & 0xff) << 16) |
                    ((d[pos + 2] & 0xff) << 8) |
                    (d[pos + 3] & 0xff);
            };
            for (var i = 0; i < d.length - 4; i++) {
                if (getUint32(i) === 0x68657631) {
                    d[i] = 0x68;
                    d[i + 1] = 0x76;
                    d[i + 2] = 0x63;
                    d[i + 3] = 0x31;
                    _this.logHandler.log('#### convert HEV1 to  HVC1 #####');
                    break;
                }
            }
            return d;
        };
        this.getMoovParams = function (d, mtype) {
            var type;
            var size;
            var charCode;
            var pos = 0;
            var end;
            var timescale = 0;
            var defaultSampleDuration = 0;
            var version;
            var getUint32 = function (pos) {
                return (d[pos] & 0xff) * Math.pow(2, 24) +
                    (((d[pos + 1] & 0xff) << 16) |
                        ((d[pos + 2] & 0xff) << 8) |
                        (d[pos + 3] & 0xff));
            };
            while (pos < d.length) {
                size = getUint32(pos);
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    charCode = d[pos];
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }
                if (type !== 'moov' &&
                    type !== 'trak' &&
                    type !== 'mdia' &&
                    type !== 'mdhd' &&
                    type !== 'mvex' &&
                    type !== 'trex' &&
                    type !== 'edts') {
                    pos += size - 8;
                }
                else if (type == 'edts') {
                    if (_this.deleteUnnecessaryBox == true) {
                        d[pos - 4] = 0x66;
                        d[pos - 3] = 0x72;
                        d[pos - 2] = 0x65;
                        d[pos - 1] = 0x65;
                    }
                    pos += size - 8;
                }
                else if (type == 'mdhd') {
                    end = pos + size - 8;
                    version = d[pos];
                    pos++;
                    pos += 3; // flags
                    if (version == 1) {
                        pos += 8; //creation_time
                        pos += 8; //modification_time
                    }
                    else {
                        pos += 4; //creation_time
                        pos += 4; //modification_time
                    }
                    timescale = getUint32(pos);
                    if (defaultSampleDuration != 0)
                        break;
                    pos = end;
                }
                else if (type == 'trex') {
                    end = pos + size - 8;
                    version = d[pos];
                    pos++;
                    pos += 11; // flags(24), track_ID(32), default_sample_description_index(32)
                    defaultSampleDuration = getUint32(pos);
                    pos += 4;
                    //// default_sample_flags
                    if (mtype == 'audio') {
                        if ((d[pos] & 0x01) == 1) {
                            //sample_depends_on
                            d[pos] += 1;
                        }
                        pos++;
                        if ((d[pos] & 0x01) == 1) {
                            //sample_is_non_sync_sample
                            d[pos] -= 1;
                        }
                    }
                    if (timescale != 0)
                        break;
                    pos = end;
                }
            }
            return {
                timescale: timescale,
                dsd: defaultSampleDuration,
            };
        };
        //NSV-a const getTimescale = d => {
        //NSV-a   let i;
        //NSV-a   let type;
        //NSV-a   let size;
        //NSV-a   let charCode;
        //NSV-a   let pos = 0;
        //NSV-a
        //NSV-a   const getUint32 = pos => (d[pos] & 0xff) * 2 ** 24 +
        //NSV-a   (((d[pos + 1] & 0xff) << 16) |
        //NSV-a     ((d[pos + 2] & 0xff) << 8) |
        //NSV-a     (d[pos + 3] & 0xff));
        //NSV-a
        //NSV-a   while (pos < d.length) {
        //NSV-a     size = getUint32(pos);
        //NSV-a     pos += 4;
        //NSV-a
        //NSV-a     type = '';
        //NSV-a
        //NSV-a     for (i = 0; i < 4; i += 1) {
        //NSV-a       charCode = d[pos];
        //NSV-a       type += String.fromCharCode(charCode);
        //NSV-a       pos += 1;
        //NSV-a     }
        //NSV-a
        //NSV-a     if (
        //NSV-a       type !== 'moov' &&
        //NSV-a       type !== 'trak' &&
        //NSV-a       type !== 'mdia' &&
        //NSV-a       type !== 'mdhd'
        //NSV-a     ) {
        //NSV-a       pos += size - 8;
        //NSV-a     } else if (type == 'mdhd') {
        //NSV-a       let version;
        //NSV-a       let timescale;
        //NSV-a
        //NSV-a       version = d[pos];
        //NSV-a       pos++;
        //NSV-a       pos += 3; // flags
        //NSV-a
        //NSV-a       if (version == 1) {
        //NSV-a         pos += 8; //creation_time
        //NSV-a         pos += 8; //modification_time
        //NSV-a       } else {
        //NSV-a         pos += 4; //creation_time
        //NSV-a         pos += 4; //modification_time
        //NSV-a       }
        //NSV-a       timescale = getUint32(pos);
        //NSV-a       return timescale;
        //NSV-a     }
        //NSV-a   }
        //NSV-a };
        //NSV-a const getDefaultSampleDuration = d => {
        //NSV-a   let i;
        //NSV-a   let type;
        //NSV-a   let size;
        //NSV-a   let charCode;
        //NSV-a   let pos = 0;
        //NSV-a
        //NSV-a   const getUint32 = pos => (d[pos] & 0xff) * 2 ** 24 +
        //NSV-a   (((d[pos + 1] & 0xff) << 16) |
        //NSV-a     ((d[pos + 2] & 0xff) << 8) |
        //NSV-a     (d[pos + 3] & 0xff));
        //NSV-a
        //NSV-a   while (pos < d.length) {
        //NSV-a     size = getUint32(pos);
        //NSV-a     pos += 4;
        //NSV-a
        //NSV-a     type = '';
        //NSV-a
        //NSV-a     for (i = 0; i < 4; i += 1) {
        //NSV-a       charCode = d[pos];
        //NSV-a       type += String.fromCharCode(charCode);
        //NSV-a       pos += 1;
        //NSV-a     }
        //NSV-a
        //NSV-a     if (type !== 'moov' && type !== 'mvex' && type !== 'trex') {
        //NSV-a       pos += size - 8;
        //NSV-a     } else if (type == 'trex') {
        //NSV-a       let defaultSampleDuration;
        //NSV-a
        //NSV-a       pos++;
        //NSV-a       pos += 11; // flags(24), track_ID(32), default_sample_description_index(32)
        //NSV-a       defaultSampleDuration = getUint32(pos);
        //NSV-a       return defaultSampleDuration;
        //NSV-a     }
        //NSV-a   }
        //NSV-a
        //NSV-a   return 0;
        //NSV-a };
        this.getInitializationDataX = function (representation, convertCodecType, initData, _callback) {
            var callback = _callback || (function () { });
            var self = _this;
            var request = new XMLHttpRequest();
            var needFailureReport = true;
            var initURL;
            _this.getInitRequestUrl(representation.initialization, representation, function (d) {
                if (d.status === 'ok') {
                    initURL = d.data;
                    request.onload = function () {
                        if (request.status < 200 || request.status > 299) {
                            return;
                        }
                        needFailureReport = false;
                        initData[representation.index] = {};
                        if (convertCodecType === undefined) {
                            initData[representation.index].data = new Uint8Array(request.response);
                        }
                        else {
                            initData[representation.index].data =
                                _this.checkAndConvertCodecType.call(self, new Uint8Array(request.response));
                        }
                        initData[representation.index].params = _this.getMoovParams.call(self, initData[representation.index].data, representation.adaptation.type);
                        callback({
                            status: 'ok',
                            data: initData[representation.index],
                        });
                    };
                    request.onloadend = request.onerror = function () {
                        if (!needFailureReport) {
                            return;
                        }
                        _this.onError({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        needFailureReport = false;
                        callback({
                            status: 'error',
                            msg: 'getInitializationData failed',
                        });
                    };
                    _this.requestWithRange(request, initURL, representation.range != null ? representation.range : null, null);
                }
                else {
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        this.getInitializationDataF = function (representation, convertCodecType, initData, _callback) {
            var callback = _callback || (function () { });
            var self = _this;
            var request = {};
            var init = {
                method: 'GET',
                headers: {},
                credentials: 'same-origin',
            };
            var initURL;
            _this.getInitRequestUrl(representation.initialization, representation, function (d) {
                if (d.status === 'ok') {
                    initURL = d.data;
                    _this.requestWithRange(request, initURL, representation.range != null ? representation.range : null, init);
                    fetch(request.url, init)
                        .then(function (res) {
                        if (res.ok == true) {
                            return res.arrayBuffer();
                        }
                        else {
                            return Promise.reject(new Error('res.false'));
                        }
                    })
                        .then(function (ab) {
                        _this.onSuccess({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        initData[representation.index] = {};
                        if (convertCodecType === undefined) {
                            initData[representation.index].data = new Uint8Array(ab);
                        }
                        else {
                            initData[representation.index].data =
                                _this.checkAndConvertCodecType.call(self, new Uint8Array(ab));
                        }
                        initData[representation.index].params = _this.getMoovParams.call(self, initData[representation.index].data, representation.adaptation.type);
                        callback({
                            status: 'ok',
                            data: initData[representation.index],
                        });
                    })
                        .catch(function (_err) {
                        _this.onError({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        callback({
                            status: 'error',
                            msg: 'getInitializationData failed',
                        });
                    });
                }
                else {
                    callback({
                        status: 'error',
                        msg: d.msg,
                    });
                }
            });
        };
        this.getInitializationData = function (representation, convertCodecType, initData, _callback) {
            _this.useFetch
                ? _this.getInitializationDataF(representation, convertCodecType, initData, _callback)
                : _this.getInitializationDataX(representation, convertCodecType, initData, _callback);
        };
        this.getFillerData = function (protection, type, codec, mode, _callback) {
            var callback = _callback || (function () { });
            var request;
            var needFailureReport = true;
            var fillerURL = '';
            if (mode == 'SILA_INSERT_MODE') {
                if (type === 'video') {
                    if (codec.indexOf('avc') > 0) {
                        if (protection) {
                            fillerURL = 'asset/b2k_ff_i05.dat';
                        }
                        else {
                            fillerURL = 'asset/b2k_no_i05.dat';
                        }
                    }
                    else if (codec.indexOf('hvc') > 0) {
                        if (protection) {
                            fillerURL = 'asset/b4k_ff_v_vc_i05.dat';
                        }
                        else {
                            fillerURL = 'asset/b4k_no_v_vc_i05.dat';
                        }
                    }
                    else if (codec.indexOf('hev') > 0) {
                        if (protection) {
                            fillerURL = 'asset/b4k_ff_v_ev_i05.dat';
                        }
                        else {
                            fillerURL = 'asset/b4k_no_v_ev_i05.dat';
                        }
                    }
                }
                else {
                    if (protection) {
                        fillerURL = 'asset/si_ff_a.dat';
                    }
                    else {
                        fillerURL = 'asset/si_no_a.dat';
                    }
                }
            }
            else if (mode == 'FILL_UP_THE_HEAD') {
                if (type === 'video') {
                    if (codec.indexOf('avc') > 0) {
                        if (protection) {
                            fillerURL = 'asset/b2k_ff_v_i10.dat';
                        }
                        else {
                            fillerURL = 'asset/b2k_no_v_i10.dat';
                        }
                    }
                    else if (codec.indexOf('hvc') > 0) {
                        if (protection) {
                            fillerURL = 'asset/b4k_ff_v_vc_i10.dat';
                        }
                        else {
                            fillerURL = 'asset/b4k_no_v_vc_i10.dat';
                        }
                    }
                    else if (codec.indexOf('hev') > 0) {
                        if (protection) {
                            fillerURL = 'asset/b4k_ff_v_ev_i10.dat';
                        }
                        else {
                            fillerURL = 'asset/b4k_no_v_ev_i10.dat';
                        }
                    }
                }
                else {
                    if (protection) {
                        fillerURL = 'asset/b4k_ff_a_i10.dat';
                    }
                    else {
                        fillerURL = 'asset/b4k_no_a_i10.dat';
                    }
                }
            }
            if (!_this.useFetch) {
                request = new XMLHttpRequest();
                request.onload = function () {
                    if (request.status < 200 || request.status > 299) {
                        return;
                    }
                    _this.onSuccess({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    needFailureReport = false;
                    callback({
                        status: 'ok',
                        data: request.response,
                    });
                };
                request.onloadend = request.onerror = function () {
                    if (!needFailureReport) {
                        return;
                    }
                    needFailureReport = false;
                    _this.onError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    callback({
                        status: 'error',
                        msg: 'getFillerData failed',
                    });
                };
                _this.requestWithRange(request, fillerURL, null, null);
            }
            else {
                var init = {
                    method: 'GET',
                    headers: {},
                    credentials: 'same-origin',
                };
                request = {};
                _this.requestWithRange(request, fillerURL, null, init);
                fetch(request.url, init)
                    .then(function (res) {
                    if (res.ok == true) {
                        return res.arrayBuffer();
                    }
                    else {
                        return Promise.reject(new Error('res.false'));
                    }
                })
                    .then(function (ab) {
                    _this.onSuccess({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    callback({
                        status: 'ok',
                        data: ab,
                    });
                })
                    .catch(function (_err) {
                    // eslint-disable-line no-unused-vars
                    _this.onError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    callback({
                        status: 'error',
                        msg: 'getFillerData failed',
                    });
                });
            }
        };
        this.getDummyData = function (protection, type, _callback) {
            var callback = _callback || (function () { });
            var request;
            var needFailureReport = true;
            var dmyURL = '';
            if (type === 'video') {
                if (protection) {
                    dmyURL = 'asset/b20_ff_v_i20_05.dat';
                }
                else {
                    dmyURL = 'asset/b20_no_v_i20_i05.dat';
                }
            }
            else {
                // eslint-disable-line no-empty
            }
            if (!_this.useFetch) {
                request = new XMLHttpRequest();
                request.onload = function () {
                    if (request.status < 200 || request.status > 299) {
                        return;
                    }
                    _this.onSuccess({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    needFailureReport = false;
                    callback({
                        status: 'ok',
                        data: request.response,
                    });
                };
                request.onloadend = request.onerror = function () {
                    if (!needFailureReport) {
                        return;
                    }
                    _this.onError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    needFailureReport = false;
                    callback({
                        status: 'error',
                        msg: 'getDummyData failed',
                    });
                };
                _this.requestWithRange(request, dmyURL, null, null);
            }
            else {
                var init = {
                    method: 'GET',
                    headers: {},
                    credentials: 'same-origin',
                };
                request = {};
                _this.requestWithRange(request, dmyURL, null, init);
                fetch(request.url, init)
                    .then(function (res) {
                    if (res.ok == true) {
                        return res.arrayBuffer();
                    }
                    else {
                        return Promise.reject(new Error('res.false'));
                    }
                })
                    .then(function (ab) {
                    _this.onSuccess({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    callback({
                        status: 'ok',
                        data: ab,
                    });
                })
                    .catch(function (_err) {
                    // eslint-disable-line no-unused-vars
                    _this.onError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    callback({
                        status: 'error',
                        msg: 'getDummyData failed',
                    });
                });
            }
        };
        /* istanbul ignore next */
        this.findSIDX = function (data, info, _callback) {
            var callback = _callback || (function () { });
            var d = new DataView(data);
            var request;
            var pos = 0;
            var type = '';
            var size = 0;
            var bytesAvailable;
            var sidxBytes;
            var sidxSlice;
            var sidxOut;
            var c;
            var needFailureReport = true;
            var parsed;
            var ref;
            var loadMultiSidx = false;
            var self = _this;
            _this.NXDebug.log('Searching for SIDX box.');
            _this.NXDebug.log(info.bytesLoaded + ' bytes loaded.');
            while (type !== 'sidx' && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;
                type = '';
                for (var i = 0; i < 4; i += 1) {
                    c = d.getInt8(pos);
                    type += String.fromCharCode(c);
                    pos += 1;
                }
                if (type !== 'sidx') {
                    pos += size - 8;
                }
            }
            bytesAvailable = d.byteLength - pos;
            if (type !== 'sidx') {
                // Case 1
                // We didn't download enough bytes to find the sidx.
                // TODO : Load more bytes.
                //        Be sure to detect EOF.
                //        Throw error is no sidx is found in the entire file.
                //        Protection from loading the entire file?
                callback({
                    status: 'error',
                    msg: "We didn't download enough bytes to find the sidx.",
                });
            }
            else if (bytesAvailable < size - 8) {
                // Case 2
                // We don't have the entire box.
                // Increase the number of bytes to read and load again.
                _this.NXDebug.log("Found SIDX but we don't have all of it.");
                info.range.start = 0;
                info.range.end = info.bytesLoaded + (size - bytesAvailable);
                if (!_this.useFetch) {
                    request = new XMLHttpRequest();
                    request.onload = function () {
                        if (request.status < 200 || request.status > 299) {
                            return;
                        }
                        needFailureReport = false;
                        info.bytesLoaded = info.range.end;
                        _this.onSuccess({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.findSIDX.call(self, request.response, info, function (d) {
                            if (d.status === 'ok') {
                                callback({
                                    status: 'ok',
                                    data: d.data,
                                });
                            }
                            else {
                                callback({
                                    status: 'error',
                                    msg: 'find SIDX error',
                                });
                            }
                        });
                    };
                    request.onloadend = request.onerror = function () {
                        if (!needFailureReport) {
                            return;
                        }
                        needFailureReport = false;
                        _this.onError({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.errHandler.downloadError(_this.eventBus, 'SIDX', info.url, request);
                        callback({
                            status: 'error',
                            msg: 'findSIDX request error',
                        });
                    };
                    _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, null);
                }
                else {
                    var init = {
                        method: 'GET',
                        headers: {},
                        credentials: 'same-origin',
                    };
                    request = {};
                    _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, init);
                    fetch(request.url, init)
                        .then(function (res) {
                        if (res.ok == true) {
                            return res.arrayBuffer();
                        }
                        else {
                            return Promise.reject(new Error('res.false'));
                        }
                    })
                        .then(function (ab) {
                        info.bytesLoaded = info.range.end;
                        _this.onSuccess({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.findSIDX.call(self, ab, info, function (d) {
                            if (d.status === 'ok') {
                                callback({
                                    status: 'ok',
                                    data: d.data,
                                });
                            }
                            else {
                                callback({
                                    status: 'error',
                                    msg: 'find SIDX error',
                                });
                            }
                        });
                    })
                        .catch(function (_err) {
                        // eslint-disable-line no-unused-vars
                        _this.onError({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.errHandler.downloadError(_this.eventBus, 'SIDX', info.url, request);
                        callback({
                            status: 'error',
                            msg: 'findSIDX request error',
                        });
                    });
                }
            }
            else {
                // Case 3
                // We have the entire box, so parse it and continue.
                info.range.start = pos - 8;
                info.range.end = info.range.start + size;
                _this.NXDebug.log('Found the SIDX box.  Start: ' +
                    info.range.start +
                    ' | End: ' +
                    info.range.end);
                sidxBytes = new ArrayBuffer(info.range.end - info.range.start);
                sidxOut = new Uint8Array(sidxBytes);
                sidxSlice = new Uint8Array(data, info.range.start, info.range.end - info.range.start);
                sidxOut.set(sidxSlice);
                parsed = _this.parseSIDX.call(_this, sidxBytes, info.range.start);
                // We need to check to see if we are loading multiple sidx.
                // For now just check the first reference and assume they are all the same.
                // TODO : Can the referenceTypes be mixed?
                // TODO : Load them all now, or do it as needed?
                ref = parsed.references;
                if (ref !== null && ref !== undefined && ref.length > 0) {
                    loadMultiSidx = ref[0].type === 1;
                }
                if (loadMultiSidx) {
                    _this.NXDebug.log('Initiate multiple SIDX load.');
                    var ss = void 0;
                    var se = void 0;
                    var r = void 0;
                    var segs_1;
                    var sidxs_1 = new Array(ref.length);
                    var sidxsCount_1 = ref.length;
                    var _loop_2 = function (j, len) {
                        ss = ref[j].offset;
                        se = ref[j].offset + ref[j].size - 1;
                        r = ss + '-' + se;
                        _this.loadSegments.call(self, info.url, r, function (d) {
                            if (d.status === 'ok') {
                                sidxsCount_1--;
                                sidxs_1[j] = d.data;
                            }
                            else {
                                sidxsCount_1--;
                            }
                            if (sidxsCount_1 === 0) {
                                segs_1 = [];
                                for (var jj = 0; jj < sidxs_1.length; jj++) {
                                    segs_1 = segs_1.concat(sidxs_1[jj]);
                                }
                                callback({
                                    status: 'ok',
                                    data: segs_1,
                                });
                            }
                        });
                    };
                    for (var j = 0, len = ref.length; j < len; j += 1) {
                        _loop_2(j, len);
                    }
                }
                else {
                    _this.NXDebug.log('Parsing segments from SIDX.');
                    callback({
                        status: 'ok',
                        data: _this.parseSegments.call(self, sidxBytes, info.url, info.range.start),
                    });
                }
            }
        };
        this.loadSegments = function (media, theRange, _callback) {
            var callback = _callback || (function () { });
            var request;
            var parts;
            var needFailureReport = true;
            var self = _this;
            var info = {
                url: media,
                range: {},
                searching: false,
                bytesLoaded: 0,
                bytesToLoad: 1500,
                request: request,
            };
            // We might not know exactly where the sidx box is.
            // Load the first n bytes (say 1500) and look for it.
            if (theRange === null) {
                _this.NXDebug.log('No known range for SIDX request.');
                info.searching = true;
                info.range.start = 0;
                info.range.end = info.bytesToLoad;
            }
            else {
                parts = theRange.split('-');
                info.range.start = parseFloat(parts[0]);
                info.range.end = parseFloat(parts[1]);
            }
            if (!_this.useFetch) {
                request = new XMLHttpRequest();
                request.onload = function () {
                    var path = info.url.split('/');
                    _this.logHandler.log_d(request.status +
                        ': ' +
                        path[path.length - 1] +
                        ' , ' +
                        info.range.start +
                        '-' +
                        info.range.end +
                        ' sidx');
                    if (request.status < 200 || request.status > 299) {
                        return;
                    }
                    needFailureReport = false;
                    _this.onSuccess({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    // If we didn't know where the SIDX box was, we have to look for it.
                    // Iterate over the data checking out the boxes to find it.
                    if (info.searching) {
                        info.bytesLoaded = info.range.end;
                        _this.findSIDX.call(self, request.response, info, function (d) {
                            callback(d);
                        });
                    }
                    else {
                        callback({
                            status: 'ok',
                            data: _this.parseSegments.call(self, request.response, info.url, info.range.start),
                        });
                    }
                };
                request.onloadend = request.onerror = function () {
                    if (!needFailureReport) {
                        return;
                    }
                    needFailureReport = false;
                    _this.onError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    _this.errHandler.downloadError(_this.eventBus, 'SIDX', info.url, request);
                    callback({
                        status: 'error',
                        msg: 'loadSegments error',
                    });
                };
                _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, null);
                _this.NXDebug.debug('Perform SIDX load: ' + info.url);
            }
            else {
                var init = {
                    method: 'GET',
                    headers: {},
                    credentials: 'same-origin',
                };
                request = {};
                _this.requestWithRange(request, info.url, info.range.start + '-' + info.range.end, init);
                _this.NXDebug.debug('Perform SIDX load: ' + info.url);
                fetch(request.url, init)
                    .then(function (res) {
                    if (res.ok == true) {
                        return res.arrayBuffer();
                    }
                    else {
                        return Promise.reject(new Error('res.false'));
                    }
                })
                    .then(function (ab) {
                    // If we didn't know where the SIDX box was, we have to look for it.
                    // Iterate over the data checking out the boxes to find it.
                    if (info.searching) {
                        info.bytesLoaded = info.range.end;
                        _this.onSuccess({
                            status: request.status,
                            req: request,
                            xhr: request,
                        });
                        _this.findSIDX.call(self, ab, info, function (d) {
                            callback(d);
                        });
                    }
                    else {
                        callback({
                            status: 'ok',
                            data: _this.parseSegments.call(self, ab, info.url, info.range.start),
                        });
                    }
                })
                    .catch(function (_err) {
                    // eslint-disable-line no-unused-vars
                    _this.onError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    _this.errHandler.downloadError(_this.eventBus, 'SIDX', info.url, request);
                    callback({
                        status: 'error',
                        msg: 'loadSegments error',
                    });
                });
            }
        };
        this.setupRequestStatus = function (type, _index, _loc) {
            var index = _index || -1;
            _this.requestStatus[type] = {
                index: index,
                requestedTime: null,
            };
        };
        this.setIsDynamic = function (value) {
            _this.isDynamic = value;
        };
        this.setEpsilonFor = function (type, tolerance) {
            _this.epsilonVal[type] = tolerance;
        };
        this.getInitRequest = this.getInit;
        this.getSegmentRequestForTime = this.getForTime;
        this.getNextSegmentRequest = this.getNext;
        //const EPSILON = 0.003,
        this.EPSILON = 0.2;
        this.MIN_SEGSIZE_FORBASE = params.MIN_SEGSIZE_FORBASE || NaN;
        this.deleteUnnecessaryBox = params.DELETE_UNNECESSARY_BOX || false;
        this.epsilonVal = {};
        this.requestStatus = {};
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.commonQrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(xhrCustom, 'query')
            ? xhrCustom['query']
            : [];
        this.commonHdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(xhrCustom, 'header')
            ? xhrCustom['header']
            : [];
        this.onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(xhrCustom, 'onPrepare')
            ? xhrCustom['onPrepare']
            : function () { };
        this.onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(xhrCustom, 'onSuccess')
            ? xhrCustom['onSuccess']
            : function () { };
        this.onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(xhrCustom, 'onError')
            ? xhrCustom['onError']
            : function () { };
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.eventBus = eventBus;
    }
    return DashHandler;
}());



/***/ }),

/***/ "./ts/dash/manifest/ManifestModel.ts":
/*!*******************************************!*\
  !*** ./ts/dash/manifest/ManifestModel.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AdaptationSet": function() { return /* binding */ AdaptationSet; },
/* harmony export */   "BaseURL": function() { return /* binding */ BaseURL; },
/* harmony export */   "MILLISECONDS_IN_SECONDS": function() { return /* binding */ MILLISECONDS_IN_SECONDS; },
/* harmony export */   "MINUTES_IN_HOUR": function() { return /* binding */ MINUTES_IN_HOUR; },
/* harmony export */   "ManifestModel": function() { return /* binding */ ManifestModel; },
/* harmony export */   "SECONDS_IN_DAY": function() { return /* binding */ SECONDS_IN_DAY; },
/* harmony export */   "SECONDS_IN_HOUR": function() { return /* binding */ SECONDS_IN_HOUR; },
/* harmony export */   "SECONDS_IN_MIN": function() { return /* binding */ SECONDS_IN_MIN; },
/* harmony export */   "SECONDS_IN_MONTH": function() { return /* binding */ SECONDS_IN_MONTH; },
/* harmony export */   "SECONDS_IN_YEAR": function() { return /* binding */ SECONDS_IN_YEAR; },
/* harmony export */   "ServiceDescription": function() { return /* binding */ ServiceDescription; }
/* harmony export */ });
/* harmony import */ var _core_Base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base64 */ "./ts/dash/core/Base64.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _Mpd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Mpd */ "./ts/dash/manifest/Mpd.ts");
/* harmony import */ var _Period__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Period */ "./ts/dash/manifest/Period.ts");
/* harmony import */ var _Representation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Representation */ "./ts/dash/manifest/Representation.ts");
/* harmony import */ var _TimelineConverter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TimelineConverter */ "./ts/dash/manifest/TimelineConverter.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */









var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
var SECONDS_IN_DAY = 24 * 60 * 60;
var SECONDS_IN_HOUR = 60 * 60;
var SECONDS_IN_MIN = 60;
var MINUTES_IN_HOUR = 60;
var MILLISECONDS_IN_SECONDS = 1000;
var durationRegex = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+-])([0-9]{2})([0-9]{2}))?/;
// NSV-a const numericRegex: RegExp = /^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$/;
var frameRateRegex = /^([0-9]+[.]?[0-9]*)\/?([0-9]*)/;
/**
 * ManifestModel
 *
 * @module ManifestModel（ManifestModelモジュール）
 */
/**
 * BaseURL
 * @constructor
 */
var BaseURL = /** @class */ (function () {
    function BaseURL() {
        this.url = null;
        this.availabilityTimeOffset = null;
    }
    BaseURL.prototype.copy = function () {
        var b = new BaseURL();
        b.url = this.url;
        b.availabilityTimeOffset = this.availabilityTimeOffset;
        return b;
    };
    return BaseURL;
}());

/**
 * ServiceDescription
 * @constructor
 */
var ServiceDescription = /** @class */ (function () {
    function ServiceDescription() {
        'use strict';
        this.id = NaN;
    }
    return ServiceDescription;
}());

/**
 * AdaptationSet
 * @constructor
 */
var AdaptationSet = /** @class */ (function () {
    function AdaptationSet() {
        this.period = null;
        this.id = null;
        this.index = -1;
        this.representations = null;
        this.contentProtections = null;
        this.hasMpdPssh = false;
        this.BaseURL = [];
        this.Role = null;
        this.lang = null;
        this.transferCharacteristics = 1;
        this.colourPrimaries = 1;
        this.availabilityTimeOffset = 0;
        this.hasMpdData = false;
    }
    AdaptationSet.prototype.getCodec = function () {
        var representation = this.representations[this.representations.length - 1];
        var codec = representation.mimeType + ';codecs="' + representation.codecs + '"';
        return codec;
    };
    AdaptationSet.prototype.getFrameRate = function () {
        return this.representations[0].frameRate;
    };
    AdaptationSet.prototype.getAudioSamplingRate = function () {
        return this.representations[0].audioSamplingRate;
    };
    AdaptationSet.prototype.getMimeType = function () {
        return this.representations[0].mimeType;
    };
    AdaptationSet.prototype.getIsMain = function () {
        return this.Role === 'main';
    };
    AdaptationSet.prototype.getRole = function () {
        return this.Role ? this.Role : 'none';
    };
    AdaptationSet.prototype.getContentProtectionData = function () {
        if (this.contentProtections != null &&
            this.contentProtections.length !== 0) {
            return this.contentProtections;
        }
        else {
            return null;
        }
    };
    AdaptationSet.prototype.getRepresentations = function () {
        return this.representations;
    };
    return AdaptationSet;
}());

/**
 * DashEvent
 * @constructor
 */
//export class DashEvent {
//  duration: number;
//  presentationTime: number;
//  id: number;
//  messageData: string;
//  eventStream: Nullable<NXEventStream>;
//  presentationTimeDelta: number;
//
//  constructor() {
//    this.duration = NaN;
//    this.presentationTime = NaN;
//    this.id = NaN;
//    this.messageData = '';
//    this.eventStream = null;
//    this.presentationTimeDelta = NaN; // Specific EMSG Box paramater
//  }
//}
/**
 * EventStream
 * @constructor
 */
//export class EventStream {
//  adaptionSet: Nullable<AdaptationSet>;
//  representation: Nullable<Representation>;
//  period: Nullable<Period>;
//  timescale: number;
//  value: string;
//  schemeIdUri: string;
//
//  constructor() {
//    this.adaptionSet = null;
//    this.representation = null;
//    this.period = null;
//    this.timescale = 1;
//    this.value = '';
//    this.schemeIdUri = '';
//  }
//}
/**
 * ManifestModel
 * @constructor
 */
var ManifestModel = /** @class */ (function () {
    function ManifestModel(params, eventBus, xhrCustom) {
        var _this = this;
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__["default"];
        this.timelineConverter = _TimelineConverter__WEBPACK_IMPORTED_MODULE_7__["default"];
        this.parseBaseUrl = function (url) {
            var base = null;
            if (url != null && url.indexOf('/') !== -1) {
                if (url.indexOf('?') !== -1) {
                    url = url.substring(0, url.indexOf('?'));
                }
                base = url.substring(0, url.lastIndexOf('/') + 1);
            }
            return base;
        };
        this.parseDuration = function (pt) {
            var match = durationRegex.exec(pt);
            if (!match) {
                return null;
            }
            return (parseFloat(match[2] || '0') * SECONDS_IN_YEAR +
                parseFloat(match[4] || '0') * SECONDS_IN_MONTH +
                parseFloat(match[6] || '0') * SECONDS_IN_DAY +
                parseFloat(match[8] || '0') * SECONDS_IN_HOUR +
                parseFloat(match[10] || '0') * SECONDS_IN_MIN +
                parseFloat(match[12] || '0'));
        };
        this.parseDateTime = function (dt) {
            var match = datetimeRegex.exec(dt);
            if (!match) {
                return null;
            }
            // If the string does not contain a timezone offset different browsers can interpret it either
            // as UTC or as a local time so we have to parse the string manually to normalize the given date value for
            // all browsers
            var utcDate = Date.UTC(parseInt(match[1], 10), parseInt(match[2], 10) - 1, // months start from zero
            parseInt(match[3], 10), parseInt(match[4], 10), parseInt(match[5], 10), (match[6] && parseInt(match[6], 10)) || 0, (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0);
            // If the date has timezone offset take it into account as well
            if (match[9] && match[10]) {
                var timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);
                utcDate +=
                    (match[8] === '+' ? -1 : +1) *
                        timezoneOffset *
                        SECONDS_IN_MIN *
                        MILLISECONDS_IN_SECONDS;
            }
            return new Date(utcDate);
        };
        this.parseFrameRate = function (fr) {
            var match = frameRateRegex.exec(fr);
            if (!match) {
                return null;
            }
            return parseFloat(match[1]) / (parseFloat(match[2]) || 1);
        };
        //NSV-a const parseNumeric = (str) => {
        //NSV-a   const match = numericRegex.exec(str);
        //NSV-a   if (!match) {
        //NSV-a     return null;
        //NSV-a   }
        //NSV-a   return parseFloat(str);
        //NSV-a };
        this.parseString = function (str) { return str; };
        this.float3 = function (num) { return Math.round(num * 1000) / 1000; };
        this.abortWrapper = function (f, c) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    c.aborted = true;
                    reject(new Error('abort'));
                }, 3000);
                f.then(resolve, reject);
            });
        };
        this.parseSegmentTimeline = function (sNode) {
            var SegmentTimeline = {};
            var S = [];
            for (var i = 0; i < sNode.length; i++) {
                var t = sNode[i].getAttribute('t')
                    ? parseInt(sNode[i].getAttribute('t'))
                    : null;
                var d = sNode[i].getAttribute('d')
                    ? parseInt(sNode[i].getAttribute('d'))
                    : null;
                var r = sNode[i].getAttribute('r')
                    ? parseInt(sNode[i].getAttribute('r'))
                    : null;
                S.push({
                    t: t,
                    d: d,
                    r: r,
                });
            }
            SegmentTimeline.S = S;
            return SegmentTimeline;
        };
        this.parseSegmentTemplate = function (aset, templateNode, isRepresentation) {
            var templateParseAttrs = {
                timescale: parseFloat,
                duration: parseFloat,
                startNumber: parseInt,
                media: _this.parseString,
                initialization: _this.parseString,
                presentationTimeOffset: parseInt,
                availabilityTimeOffset: parseFloat,
            };
            var template = {};
            for (var attr in templateParseAttrs) {
                if (templateNode.getAttribute(attr)) {
                    template[attr] = templateParseAttrs[attr](templateNode.getAttribute(attr));
                }
                else if (isRepresentation &&
                    (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset, 'SegmentTemplate') &&
                    (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset.SegmentTemplate, attr)) {
                    template[attr] = aset.SegmentTemplate[attr];
                }
                //NXDebug.debug("attr:::"+attr+","+template[attr]);
            }
            var timelineNode = templateNode.getElementsByTagName('SegmentTimeline')[0];
            if (timelineNode) {
                template.SegmentTimeline = _this.parseSegmentTimeline(timelineNode.getElementsByTagName('S'));
            }
            if (isRepresentation &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset, 'SegmentTemplate') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset.SegmentTemplate, 'SegmentTimeline')) {
                template.SegmentTimeline = aset.SegmentTemplate.SegmentTimeline;
            }
            return template;
        };
        this.parseSegmentList = function (aset, listNode) {
            var listParseAttrs = {
                timescale: parseFloat,
                duration: parseFloat,
                startNumber: parseInt,
                presentationTimeOffset: parseInt,
            };
            var list = {};
            for (var attr in listParseAttrs) {
                if (listNode.getAttribute(attr)) {
                    list[attr] = listParseAttrs[attr](listNode.getAttribute(attr));
                }
                else if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset, attr)) {
                    list[attr] = aset[attr];
                }
                //NXDebug.debug("attr:::"+attr+","+list[attr]);
            }
            var initialization = listNode.getElementsByTagName('Initialization')[0];
            if (initialization) {
                if (initialization.getAttribute('sourceURL')) {
                    list.Initialization = {};
                    list.Initialization.sourceURL =
                        initialization.getAttribute('sourceURL');
                    _this.NXDebug.info(list.Initialization.sourceURL);
                }
            }
            var urlNode = listNode.getElementsByTagName('SegmentURL');
            //tmplate.SegmentTimeline = [];
            var SegmentURLs = [];
            for (var i = 0; i < urlNode.length; i++) {
                var media = urlNode[i].getAttribute('media')
                    ? urlNode[i].getAttribute('media')
                    : null;
                var mediaRange = urlNode[i].getAttribute('mediaRange')
                    ? urlNode[i].getAttribute('mediaRange')
                    : null;
                var index = urlNode[i].getAttribute('index')
                    ? parseInt(urlNode[i].getAttribute('index'))
                    : null;
                var indexRange = urlNode[i].getAttribute('indexRange')
                    ? parseInt(urlNode[i].getAttribute('indexRange'))
                    : null;
                SegmentURLs.push({
                    media: media,
                    mediaRange: mediaRange,
                    index: index,
                    indexRange: indexRange,
                });
            }
            list.SegmentURLs = SegmentURLs;
            var timelineNode = listNode.getElementsByTagName('SegmentTimeline')[0];
            if (timelineNode) {
                list.SegmentTimeline = _this.parseSegmentTimeline(timelineNode.getElementsByTagName('S'));
            }
            return list;
        };
        this.parseContentProtection = function (contentProtectionNode) {
            var contentProtectionParseAttrs = {
                schemeIdUri: _this.parseString,
                value: _this.parseString,
                'cenc:default_KID': _this.parseString,
            };
            var contentProtection = {};
            //let msprNode: Element;
            var mspr_pro;
            var nodes;
            //let psshNode: Element;
            var pssh;
            for (var attr in contentProtectionParseAttrs) {
                if (contentProtectionNode.getAttribute(attr)) {
                    contentProtection[attr] = contentProtectionParseAttrs[attr](contentProtectionNode.getAttribute(attr));
                    //NXDebug.debug("attr:::"+attr+","+contentProtection[attr]);
                }
            }
            nodes = contentProtectionNode.childNodes;
            for (var i = 0; i < nodes.length; i++) {
                //if (nodes[i].nodeName == 'cenc:pssh') {
                if (nodes[i].nodeName == 'cenc:pssh' ||
                    nodes[i].nodeName == 'CENC:PSSH') {
                    pssh = nodes[i].textContent.replace(/\s+/g, '');
                    contentProtection.pssh = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(pssh);
                    //} else if (nodes[i].nodeName == 'mspr:pro') {
                }
                else if (nodes[i].nodeName == 'mspr:pro' ||
                    nodes[i].nodeName == 'MSPR:PRO') {
                    mspr_pro = nodes[i].textContent.replace(/\s+/g, '');
                    contentProtection.pro = mspr_pro;
                    //} else if (nodes[i].nodeName == 'pro') {
                }
                else if (nodes[i].nodeName == 'pro' || nodes[i].nodeName == 'PRO') {
                    mspr_pro = nodes[i].textContent.replace(/\s+/g, '');
                    contentProtection.pro = mspr_pro;
                }
            }
            return contentProtection;
        };
        /* istanbul ignore next */
        this.parseRepresentation = function (rep, aset, commonParseAttrs, _offset) {
            var representationParseAttributes = {
                id: _this.parseString,
                bandwidth: parseFloat,
                height: parseInt,
                width: parseInt,
                availabilityTimeOffset: parseFloat,
            };
            var representation = new _Representation__WEBPACK_IMPORTED_MODULE_6__.Representation();
            var attr;
            representation.adaptation = aset;
            for (attr in commonParseAttrs) {
                if (rep.hasAttribute(attr) && rep.getAttribute(attr)) {
                    representation[attr] = commonParseAttrs[attr](rep.getAttribute(attr));
                }
                else if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset.attrs, attr)) {
                    representation[attr] = aset.attrs[attr];
                }
            }
            for (attr in representationParseAttributes) {
                if (rep.hasAttribute(attr) && rep.getAttribute(attr)) {
                    representation[attr] = representationParseAttributes[attr](rep.getAttribute(attr));
                }
            }
            if (!(0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset, 'type')) {
                aset.mimeType = representation.mimeType;
                if (aset.mimeType.indexOf('video') !== -1) {
                    aset.type = 'video';
                }
                else if (aset.mimeType.indexOf('audio') !== -1) {
                    aset.type = 'audio';
                }
                else if (aset.mimeType.indexOf('text') !== -1) {
                    aset.type = 'audio';
                }
                else if (aset.mimeType.indexOf('vtt') !== -1 ||
                    aset.mimeType.indexOf('ttml') !== -1) {
                    aset.type = 'text';
                }
                else {
                    aset.type = '???';
                }
            }
            var segmentNode = rep.childNodes;
            var segmentTypeIsNotDefined = true;
            var segmentInfo;
            for (var i = 0; i < segmentNode.length; i++) {
                if (segmentNode[i].nodeName == 'BaseURL') {
                    var url = segmentNode[i].textContent;
                    var baseURL = new BaseURL();
                    if (url.indexOf('http://') === 0 || url.indexOf('https://') === 0) {
                        baseURL.url = url;
                        attr = segmentNode[i].getAttribute('availabilityTimeOffset');
                        if (attr) {
                            baseURL.availabilityTimeOffset = parseFloat(attr);
                        }
                        representation.BaseURL.push(baseURL);
                    }
                    else {
                        for (var bb = 0; bb < aset.BaseURL.length; bb++) {
                            baseURL = aset.BaseURL[bb].copy();
                            baseURL.url = baseURL.url + url;
                            attr = segmentNode[i].getAttribute('availabilityTimeOffset');
                            if (attr) {
                                baseURL.availabilityTimeOffset = parseFloat(attr);
                            }
                            representation.BaseURL.push(baseURL);
                        }
                    }
                }
                else if (segmentNode[i].nodeName == 'SegmentBase') {
                    representation.segmentInfoType = 'SegmentBase';
                    segmentInfo = {};
                    segmentInfo.indexRange = segmentNode[i].getAttribute('indexRange');
                    if (segmentNode[i].getAttribute('presentationTimeOffset')) {
                        segmentInfo.presentationTimeOffset = parseInt(segmentNode[i].getAttribute('presentationTimeOffset'));
                    }
                    if (segmentNode[i].getElementsByTagName('Initialization')
                        .length > 0) {
                        var initialization = {};
                        initialization.range = segmentNode[i]
                            .getElementsByTagName('Initialization')[0]
                            .getAttribute('range');
                        segmentInfo.Initialization = initialization;
                    }
                    segmentTypeIsNotDefined = false;
                }
                else if (segmentNode[i].nodeName == 'SegmentTemplate') {
                    segmentInfo = _this.parseSegmentTemplate(aset, segmentNode[i], true);
                    representation.SegmentTemplate = segmentInfo;
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'SegmentTimeline')) {
                        representation.segmentInfoType = 'SegmentTimeline';
                    }
                    else {
                        representation.segmentInfoType = 'SegmentTemplate';
                    }
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'initialization')) {
                        representation.initialization = segmentInfo
                            .initialization.split('$Bandwidth$')
                            .join(String(representation.bandwidth))
                            .split('$RepresentationID$')
                            .join(representation.id);
                    }
                    segmentTypeIsNotDefined = false;
                }
                else if (segmentNode[i].nodeName == 'SegmentList') {
                    representation.segmentInfoType = 'SegmentList';
                    segmentInfo = _this.parseSegmentList(aset, segmentNode[i]);
                    representation.SegmentList = segmentInfo;
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'startNumber')) {
                        representation.startNumber = segmentInfo.startNumber;
                    }
                    segmentTypeIsNotDefined = false;
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'SegmentTimeline')) {
                        representation.segmentInfoType = 'SegmentTimeline';
                    }
                    else {
                        representation.segmentInfoType = 'SegmentList';
                    }
                }
                else if (segmentNode[i].nodeName == 'ContentProtection') {
                    var contentProtection = _this.parseContentProtection(segmentNode[i]);
                    aset.contentProtections.push(contentProtection);
                    if (contentProtection.pssh) {
                        aset.hasMpdData = true;
                    }
                }
                else if (segmentNode[i].nodeName == 'EssentialProperty') {
                    if (segmentNode[i].getAttribute('schemeIdUri') ==
                        'urn:mpeg:mpegB:cicp:ColourPrimaries') {
                        representation.colourPrimaries = parseInt(segmentNode[i].getAttribute('value'));
                    }
                    if (segmentNode[i].getAttribute('schemeIdUri') ==
                        'urn:mpeg:mpegB:cicp:TransferCharacteristics') {
                        representation.transferCharacteristics = parseInt(segmentNode[i].getAttribute('value'));
                    }
                }
                else if (segmentNode[i].nodeName == 'ProducerReferenceTime') {
                    if (segmentNode[i].getAttribute('id')) {
                        representation.producerReferenceTime.id = segmentNode[i].getAttribute('id');
                    }
                    if (segmentNode[i].getAttribute('inband')) {
                        representation.producerReferenceTime.inband = Boolean(segmentNode[i].getAttribute('inband'));
                    }
                    if (segmentNode[i].getAttribute('type')) {
                        representation.producerReferenceTime.type = segmentNode[i].getAttribute('type');
                    }
                    if (segmentNode[i].getAttribute('wallClockTime')) {
                        representation.producerReferenceTime.wallClockTime = new Date(_this
                            .parseDateTime(segmentNode[i].getAttribute('wallClockTime'))
                            .getTime());
                    }
                    if (segmentNode[i].getAttribute('presentationTime')) {
                        representation.producerReferenceTime.presentationTime = parseFloat(segmentNode[i].getAttribute('presentationTime'));
                    }
                }
            }
            if (_this.supported_colour_primaries.indexOf(representation.colourPrimaries) <
                0 ||
                _this.supported_transfer_characteristics.indexOf(representation.transferCharacteristics) < 0) {
                return null;
            }
            if (representation.BaseURL.length === 0) {
                aset.BaseURL.forEach(function (b) {
                    representation.BaseURL.push(b.copy());
                });
            }
            for (var i = 0; i < representation.BaseURL.length; i++) {
                representation.BaseURL[i].url = representation.BaseURL[i]
                    .url.split('$Bandwidth$')
                    .join(String(representation.bandwidth))
                    .split('$RepresentationID$')
                    .join(representation.id);
            }
            if (segmentTypeIsNotDefined) {
                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(aset, 'SegmentTemplate')) {
                    segmentInfo = aset.SegmentTemplate;
                    representation.SegmentTemplate = segmentInfo;
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'SegmentTimeline')) {
                        representation.segmentInfoType = 'SegmentTimeline';
                    }
                    else {
                        representation.segmentInfoType = 'SegmentTemplate';
                    }
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'initialization')) {
                        representation.initialization = segmentInfo
                            .initialization.split('$Bandwidth$')
                            .join(String(representation.bandwidth))
                            .split('$RepresentationID$')
                            .join(representation.id);
                    }
                }
                else {
                    _this.NXDebug.debug('can not decide Segment Type');
                    if (!isNaN(aset.period.selectedBaseURLIdx)) {
                        segmentInfo = representation.BaseURL[aset.period.selectedBaseURLIdx];
                    }
                    else {
                        segmentInfo = representation.BaseURL[0];
                    }
                    representation.segmentInfoType = 'BaseURL';
                }
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'Initialization')) {
                var initialization = segmentInfo.Initialization;
                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(initialization, 'sourceURL')) {
                    representation.initialization = initialization.sourceURL;
                }
                else if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(initialization, 'range')) {
                    if (!isNaN(aset.period.selectedBaseURLIdx)) {
                        representation.initialization =
                            representation.BaseURL[aset.period.selectedBaseURLIdx].url;
                    }
                    else {
                        representation.initialization = representation.BaseURL[0].url;
                    }
                    representation.range = initialization.range;
                }
            }
            else if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(representation, 'mimeType') &&
                (representation.mimeType === 'text/vtt' ||
                    representation.mimeType === 'application/ttml+xml')) {
                if (!isNaN(aset.period.selectedBaseURLIdx)) {
                    representation.initialization =
                        representation.BaseURL[aset.period.selectedBaseURLIdx].url;
                }
                else {
                    representation.initialization = representation.BaseURL[0].url;
                }
                representation.range = '0'; //representation.range = 0;
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'timescale')) {
                representation.timescale = segmentInfo.timescale;
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'duration')) {
                // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation
                // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about
                // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration
                // exceeds @maxSegmentDuration
                representation.segmentDuration =
                    segmentInfo.duration / representation.timescale;
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'startNumber')) {
                representation.startNumber = segmentInfo.startNumber;
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'indexRange')) {
                representation.indexRange = segmentInfo.indexRange;
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'presentationTimeOffset')) {
                representation.presentationTimeOffset =
                    segmentInfo.presentationTimeOffset / representation.timescale;
            }
            else {
                representation.presentationTimeOffset = _offset;
            }
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(segmentInfo, 'availabilityTimeOffset')) {
                representation.availabilityTimeOffset =
                    segmentInfo.availabilityTimeOffset;
            }
            else if (representation.BaseURL[aset.period.selectedBaseURLIdx]
                .availabilityTimeOffset) {
                representation.availabilityTimeOffset =
                    representation.BaseURL[aset.period.selectedBaseURLIdx].availabilityTimeOffset;
            }
            else if (representation.adaptation.availabilityTimeOffset) {
                representation.availabilityTimeOffset =
                    representation.adaptation.availabilityTimeOffset;
            }
            if (representation.adaptation.period.mpd.type === 'dynamic' &&
                representation.presentationTimeOffset != 0) {
                representation.timestampOffsetFor32bitVE = _offset;
            }
            else {
                if (representation.segmentInfoType === 'SegmentTemplate') {
                    representation.timestampOffsetFor32bitVE = _offset;
                }
                else if (representation.segmentInfoType === 'SegmentTimeline') {
                    var S = representation.SegmentTemplate != null
                        ? representation.SegmentTemplate.SegmentTimeline.S
                        : representation.SegmentList.SegmentTimeline.S;
                    if ((representation.adaptation.period.mpd.type === 'dynamic' &&
                        _this.SET_1STSEG_TIME_ZERO) ||
                        representation.adaptation.period.mpd.type === 'static') {
                        representation.timestampOffsetFor32bitVE =
                            S[0].t / representation.timescale;
                    }
                    else {
                        representation.timestampOffsetFor32bitVE = 0;
                    }
                    if (representation.presentationTimeOffset != 0) {
                        representation.timestampOffsetFor32bitVE = _offset;
                    }
                }
                else {
                    representation.timestampOffsetFor32bitVE = _offset;
                }
            }
            return representation;
        };
        /* istanbul ignore next */
        this.parseEventStream = function (eventNode, eventList) {
            var schemeIdUri;
            var timescale = 1;
            var value;
            var getEvent = function (list, id) {
                for (var i = 0; i < list.length; i++) {
                    if (list[i].id != null && list[i].id == id)
                        return true;
                }
                return false;
            };
            if (eventNode.getAttribute('schemeIdUri')) {
                schemeIdUri = eventNode.getAttribute('schemeIdUri');
            }
            else {
                throw 'Invalid EventStream. SchemeIdUri has to be set';
            }
            if (eventNode.getAttribute('timescale')) {
                timescale = parseInt(eventNode.getAttribute('timescale'));
            }
            if (eventNode.getAttribute('value')) {
                value = eventNode.getAttribute('value');
            }
            var eNodes = eventNode.childNodes;
            for (var i = 0; i < eNodes.length; i++) {
                if (eNodes[i].nodeName == 'Event') {
                    var de = {};
                    de.schemeIdUri = schemeIdUri;
                    de.timescale = timescale;
                    de.value = value;
                    de.presentationTime = 0;
                    de.duration = NaN;
                    de.messageData = null;
                    if (eNodes[i].getAttribute('presentationTime')) {
                        de.presentationTime =
                            parseFloat(eNodes[i].getAttribute('presentationTime')) / timescale;
                    }
                    if (eNodes[i].getAttribute('duration')) {
                        de.duration =
                            parseFloat(eNodes[i].getAttribute('duration')) /
                                timescale;
                    }
                    if (eNodes[i].getAttribute('id')) {
                        de.id = eNodes[i].getAttribute('id');
                    }
                    de.messageData = eNodes[i].childNodes;
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(eventList, schemeIdUri)) {
                        if (getEvent(eventList[schemeIdUri], de.id) == false) {
                            eventList[schemeIdUri].push(de);
                        }
                    }
                    else {
                        eventList[schemeIdUri] = [];
                        eventList[schemeIdUri].push(de);
                    }
                }
            }
        };
        //NSV-a const parseRole = (node) => {
        //NSV-a   const role = {};
        //NSV-a   const roleAttributes = {
        //NSV-a     schemeIdUri: parseString,
        //NSV-a     value: parseString,
        //NSV-a   };
        //NSV-a
        //NSV-a   for (const attr in roleAttributes) {
        //NSV-a     if (node.hasAttribute(attr) && node.getAttribute(attr)) {
        //NSV-a       role[attr] = roleAttributes[attr](node.getAttribute(attr));
        //NSV-a     }
        //NSV-a   }
        //NSV-a   return role;
        //NSV-a };
        /* istanbul ignore next */
        this.MpdParser = function (data, manifest, baseUrl, _offset, _callback) {
            var parser = new DOMParser();
            var callback = _callback || (function () { });
            var dom = parser.parseFromString(data, 'text/xml');
            ///// MPD START /////
            var mpd = new _Mpd__WEBPACK_IMPORTED_MODULE_4__.Mpd();
            var mpdNode = dom.getElementsByTagName('MPD')[0];
            var mpdParseAttributes = {
                'xmlns:xsi': _this.parseString,
                xmlns: _this.parseString,
                'xsi:schemaLocation': _this.parseString,
                type: _this.parseString,
                minBufferTime: _this.parseDuration,
                profiles: _this.parseString,
                minimumUpdatePeriod: _this.parseDuration,
            };
            var attr;
            var baseURL;
            for (attr in mpdParseAttributes) {
                if (mpdNode.getAttribute(attr)) {
                    mpd[attr] = mpdParseAttributes[attr](mpdNode.getAttribute(attr));
                    _this.NXDebug.log('mpd: ' + attr + ':' + mpd[attr]);
                }
            }
            attr = mpdNode.getAttribute('availabilityStartTime');
            mpd.availabilityStartTime = attr
                ? new Date(_this.parseDateTime(attr).getTime())
                : new Date(manifest.mpdLoadedTime.getTime());
            attr = mpdNode.getAttribute('publishTime');
            if (attr) {
                mpd.publishTime = new Date(_this.parseDateTime(attr).getTime());
                _this.NXDebug.info('publishTime:::' + mpd.publishTime);
            }
            attr = mpdNode.getAttribute('availabilityEndTime');
            if (attr) {
                mpd.availabilityEndTime = new Date(_this.parseDateTime(attr).getTime());
            }
            attr = mpdNode.getAttribute('suggestedPresentationDelay');
            if (attr) {
                mpd.suggestedPresentationDelay = _this.parseDuration(attr);
            }
            /*
            if (!isNaN(this.DEFAULT_PRESENTATION_DELAY)) {
              mpd.suggestedPresentationDelay = this.DEFAULT_PRESENTATION_DELAY;
            } else if (attr) {
              mpd.suggestedPresentationDelay = this.parseDuration(attr)!;
            }
            */
            attr = mpdNode.getAttribute('timeShiftBufferDepth');
            if (attr) {
                mpd.timeShiftBufferDepth = _this.parseDuration(attr);
            }
            attr = mpdNode.getAttribute('maxSegmentDuration');
            if (attr) {
                mpd.maxSegmentDuration = _this.parseDuration(attr);
            }
            attr = mpdNode.getAttribute('mediaPresentationDuration');
            if (attr) {
                mpd.mediaPresentationDuration = _this.parseDuration(attr);
            }
            mpd.checkTime = NaN;
            mpd.BaseURL = [];
            ///Location
            if (mpdNode.getElementsByTagName('Location').length > 0) {
                var locationNode = mpdNode.getElementsByTagName('Location')[0];
                manifest.Location = locationNode.textContent;
            }
            ///BaseURL
            var baseUrlCand = mpdNode.childNodes;
            for (var i = 0; i < baseUrlCand.length; i++) {
                if (baseUrlCand[i].nodeName === 'BaseURL') {
                    var url = baseUrlCand[i].textContent;
                    var burl = url.indexOf('http://') === 0 || url.indexOf('https://') === 0
                        ? url
                        : baseUrl + url;
                    baseURL = new BaseURL();
                    baseURL.url = burl;
                    attr = baseUrlCand[i].getAttribute('availabilityTimeOffset');
                    if (attr) {
                        baseURL.availabilityTimeOffset = parseFloat(attr);
                    }
                    mpd.BaseURL.push(baseURL);
                }
            }
            if (mpd.BaseURL.length === 0) {
                baseURL = new BaseURL();
                baseURL.url = baseUrl;
                baseURL.availabilityTimeOffset = 0;
                mpd.BaseURL.push(baseURL);
            }
            ///ServiceDescription
            var sdNode = mpdNode.getElementsByTagName('ServiceDescription');
            if (sdNode) {
                var latencyNode, rateNode; //var sd;
                for (var i = 0; i < sdNode.length; i++) {
                    if (sdNode[i].getElementsByTagName('Latency').length > 0) {
                        latencyNode = sdNode[i].getElementsByTagName('Latency')[0];
                        mpd.targetLatency = latencyNode.getAttribute('target') || NaN;
                        mpd.targetLatencyMin = latencyNode.getAttribute('min') || NaN;
                        mpd.targetLatencyMax = latencyNode.getAttribute('max') || NaN;
                        mpd.referenceIdPRT = latencyNode.getAttribute('referenceId') || NaN;
                    }
                    if (sdNode[i].getElementsByTagName('PlaybackRate').length > 0) {
                        rateNode = sdNode[i].getElementsByTagName('PlaybackRate')[0];
                        mpd.playbackRateMin = rateNode.getAttribute('min') || NaN;
                        mpd.playbackRateMax = rateNode.getAttribute('max') || NaN;
                    }
                }
            }
            //
            if (!isNaN(_this.DEFAULT_PRESENTATION_DELAY)) {
                mpd.suggestedPresentationDelay = _this.DEFAULT_PRESENTATION_DELAY;
            }
            else if (!isNaN(mpd.targetLatency)) {
                mpd.suggestedPresentationDelay = mpd.targetLatency / 1000;
            }
            if (mpd.type == 'dynamic') {
                if (mpd.suggestedPresentationDelay < mpd.minBufferTime) {
                    mpd.minBufferTime = mpd.suggestedPresentationDelay;
                }
            }
            mpd.manifest = manifest;
            ///// MPD END /////
            _this.parsePeriod(mpd, mpdNode.getElementsByTagName('Period'), function (d) {
                mpd.periods = d.data;
                var commonParseAttributes = {
                    profiles: _this.parseString,
                    width: parseInt,
                    height: parseInt,
                    sar: _this.parseString,
                    frameRate: _this.parseFrameRate,
                    audioSamplingRate: parseFloat,
                    mimeType: _this.parseString,
                    lang: _this.parseString,
                    segmentProfiles: _this.parseString,
                    codecs: _this.parseString,
                    maximumSAPPeriod: parseFloat,
                    startsWithSap: parseInt,
                    maxPlayoutRate: parseFloat,
                    codingDependency: _this.parseString,
                    scanType: _this.parseString,
                    FramePacking: _this.parseString,
                    AudioChannelConfiguration: _this.parseString,
                    availabilityTimeOffset: parseFloat,
                };
                for (var i = 0; i < mpd.periods.length; i++) {
                    mpd.periods[i].adaptationSets = [];
                    var asetsCandidateNode = mpd.periods[i].childNodes;
                    var hasAudio = false;
                    var hasVideo = false;
                    var _loop_1 = function (j) {
                        var adaptationNode = asetsCandidateNode[j];
                        var aset = new AdaptationSet();
                        aset.period = mpd.periods[i];
                        aset.index = j;
                        aset.attrs = {};
                        aset.id = adaptationNode.getAttribute('id')
                            ? adaptationNode.getAttribute('id')
                            : aset.index;
                        aset.lang = adaptationNode.getAttribute('lang')
                            ? adaptationNode.getAttribute('lang')
                            : null;
                        aset.childNodes = adaptationNode.childNodes;
                        for (var attr_1 in commonParseAttributes) {
                            if (adaptationNode.getAttribute(attr_1)) {
                                aset.attrs[attr_1] = commonParseAttributes[attr_1](adaptationNode.getAttribute(attr_1));
                            }
                        }
                        aset.representations = [];
                        aset.contentProtections = [];
                        for (var k = 0; k < aset.childNodes.length; k++) {
                            if (aset.childNodes[k].nodeName == 'BaseURL') {
                                var url = aset.childNodes[k].textContent;
                                var baseURL_1 = {};
                                if (url.indexOf('http://') === 0 ||
                                    url.indexOf('https://') === 0) {
                                    baseURL_1['url'] = url;
                                    attr = aset.childNodes[k].getAttribute('availabilityTimeOffset');
                                    if (attr == typeof String) {
                                        baseURL_1['availabilityTimeOffset'] = parseFloat(attr);
                                    }
                                    aset.BaseURL.push(baseURL_1);
                                }
                                else {
                                    for (var bb = 0; bb < mpd.periods[i].BaseURL.length; bb++) {
                                        baseURL_1 = mpd.periods[i].BaseURL[bb].copy();
                                        baseURL_1.url = baseURL_1.url + url;
                                        attr = aset.childNodes[k].getAttribute('availabilityTimeOffset');
                                        if (attr == typeof String) {
                                            baseURL_1['availabilityTimeOffset'] = parseFloat(attr);
                                        }
                                        aset.BaseURL.push(baseURL_1);
                                    }
                                }
                            }
                        }
                        if (aset.BaseURL.length === 0) {
                            mpd.periods[i].BaseURL.forEach(function (b) {
                                aset.BaseURL.push(b.copy());
                            });
                        }
                        for (var k = 0; k < aset.childNodes.length; k++) {
                            if (aset.childNodes[k].nodeName == 'Representation') {
                                var representation = _this.parseRepresentation(aset.childNodes[k], aset, commonParseAttributes, _offset);
                                if (representation != null)
                                    aset.representations.push(representation);
                            }
                            else if (aset.childNodes[k].nodeName == 'ContentProtection') {
                                var contentProtection = aset.childNodes[k];
                                contentProtection =
                                    _this.parseContentProtection(contentProtection);
                                aset.contentProtections.push(contentProtection);
                                if (contentProtection.pssh) {
                                    aset.hasMpdPssh = true;
                                }
                            }
                            else if (aset.childNodes[k].nodeName == 'SegmentTemplate') {
                                aset.SegmentTemplate = _this.parseSegmentTemplate(aset, aset.childNodes[k], false);
                            }
                            else if (aset.childNodes[k].nodeName == 'Role') {
                                aset.Role = aset.childNodes[k].getAttribute('value');
                            }
                            else if (aset.childNodes[k].nodeName == 'EssentialProperty') {
                                if (aset.childNodes[k].getAttribute('schemeIdUri') ==
                                    'urn:mpeg:mpegB:cicp:ColourPrimaries') {
                                    aset.colourPrimaries = parseInt(aset.childNodes[k].getAttribute('value'));
                                }
                                if (aset.childNodes[k].getAttribute('schemeIdUri') ==
                                    'urn:mpeg:mpegB:cicp:TransferCharacteristics') {
                                    aset.transferCharacteristics = parseInt(aset.childNodes[k].getAttribute('value'));
                                }
                            }
                            else {
                                // eslint-disable-line no-empty
                            }
                        }
                        if (aset.type == 'video' &&
                            (_this.supported_colour_primaries.indexOf(aset.colourPrimaries) <
                                0 ||
                                _this.supported_transfer_characteristics.indexOf(aset.transferCharacteristics) < 0)) {
                            _this.logHandler.log('ColourPrimaries=' +
                                aset.colourPrimaries +
                                ' and/or TransferCharacteristics=' +
                                aset.transferCharacteristics +
                                'are not supported');
                            return "continue";
                        }
                        else if (aset.type == 'audio' && _this.unuseAudio == true) {
                            return "continue";
                        }
                        else if (aset.representations.length === 0) {
                            _this.logHandler.log('!!!!!!!!!!no representations found!!!!!');
                            _this.NXDebug.log('no representations found!!!');
                            return "continue";
                        }
                        else {
                            // eslint-disable-line no-empty
                        }
                        _this.setIndexForRepresentation.call(_this, aset);
                        mpd.periods[i].adaptationSets.push(aset);
                        if (aset.type === 'video')
                            hasVideo = true;
                        if (aset.type === 'audio')
                            hasAudio = true;
                        aset = null;
                    };
                    for (var j = 0; j < asetsCandidateNode.length; j++) {
                        _loop_1(j);
                    }
                    if (hasVideo && hasAudio) {
                        mpd.periods[i].type = 'video/audio';
                    }
                    else if (hasVideo) {
                        mpd.periods[i].type = 'video';
                    }
                    else if (hasAudio) {
                        mpd.periods[i].type = 'audio';
                    }
                }
                mpd.timestampOffsetFor32bitVE = _this.setTimestampOffsetFor32bitVE(mpd.periods);
                _this.NXDebug.log(String(mpd.timestampOffsetFor32bitVE));
                callback({
                    data: mpd,
                });
            });
        };
        this.setTimestampOffsetFor32bitVE = function (ps) {
            var period = ps[0];
            var j;
            var s;
            var de;
            if (_this.timestampOffsetFor32bitVE == -1) {
                var asets = period.adaptationSets;
                var m = 0xffffffffffffffff;
                for (var i = 0; i < asets.length; i++) {
                    var reps = asets[i].representations;
                    for (j = 0; j < reps.length; j++) {
                        if (m > reps[j].timestampOffsetFor32bitVE) {
                            m = reps[j].timestampOffsetFor32bitVE;
                        }
                    }
                }
                _this.timestampOffsetFor32bitVE = m + period.start;
            }
            if (_this.timestampOffsetFor32bitVE != 0) {
                for (var i = 0; i < ps.length; i++) {
                    ps[i].start = _this.float3(ps[i].start - _this.timestampOffsetFor32bitVE);
                    ps[i].offset = _this.float3(ps[i].offset - _this.timestampOffsetFor32bitVE);
                    ps[i].end = _this.float3(ps[i].end - _this.timestampOffsetFor32bitVE);
                    for (s in ps[i].outEventList) {
                        for (j = 0; j < ps[i].outEventList[s].length; j++) {
                            de = ps[i].outEventList[s][j];
                            de.presentationTime += ps[i].start;
                        }
                    }
                }
            }
            for (var i = 0; i < ps.length; i++) {
                for (s in ps[i].outEventList) {
                    var list = ps[i].outEventList[s];
                    var length_1 = list.length;
                    j = 0;
                    while (j < length_1) {
                        de = list[j];
                        _this.eventBus.dispatchEvent({
                            type: 'DASHEVENT_RECEIVED',
                            data: {
                                type: 'outband',
                                event: de,
                                eventList: list,
                                index: i,
                            },
                        });
                        if (list.length < length_1) {
                            length_1 = list.length;
                        }
                        else {
                            j++;
                        }
                    }
                }
            }
            return _this.timestampOffsetFor32bitVE;
        };
        this.processAdaptation = function (adaptation) {
            if (adaptation.representations !== undefined &&
                adaptation.representations !== null) {
                adaptation.representations.sort(function (a, b) { return a.bandwidth - b.bandwidth; });
            }
            return adaptation;
        };
        this.setIndexForRepresentation = function (adaptation) {
            var a = _this.processAdaptation(adaptation);
            var min = _this.minBandwidth[a.type];
            var max = _this.maxBandwidth[a.type];
            var minIdx = -1;
            var maxIdx = -1;
            if (!isNaN(min)) {
                for (var i = 0; i < a.representations.length; i++) {
                    if (min <= a.representations[i].bandwidth) {
                        minIdx = i;
                        break;
                    }
                }
                if (minIdx == -1) {
                    minIdx = a.representations.length - 1;
                }
                if (minIdx > 0) {
                    a.representations.splice(0, minIdx);
                }
            }
            if (!isNaN(max)) {
                for (var i = a.representations.length - 1; i >= 0; i--) {
                    if (a.representations[i].bandwidth < max) {
                        maxIdx = i;
                        break;
                    }
                }
                if (maxIdx == -1) {
                    maxIdx = 0;
                }
                if (maxIdx < a.representations.length - 1) {
                    a.representations.splice(maxIdx + 1);
                }
            }
            for (var i = 0; i < a.representations.length; i++) {
                a.representations[i].index = i;
            }
        };
        this.getRefreshDelay = function (manifest) {
            var delay = 2;
            var minDelay = 2;
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(manifest.mpd, 'minimumUpdatePeriod')) {
                //delay = Math.min(manifest.mpd.minimumUpdatePeriod,minDelay);
                delay = manifest.mpd.minimumUpdatePeriod || minDelay;
            }
            return delay;
        };
        this.internalParse = function (data, baseUrl, _callback) {
            var manifest = null;
            var callback = _callback || (function () { });
            try {
                manifest = {};
                manifest.mpdLoadedTime = new Date();
                _this.getServerTime.call(_this, function (_) {
                    _this.MpdParser.call(_this, data, manifest, baseUrl, 0, function (d) {
                        manifest.mpd = d.data;
                        _this.NXDebug.log('MPD');
                        _this.NXDebug.log('Parsing complete: ');
                        callback(manifest);
                    });
                });
            }
            catch (_err) {
                _this.errHandler.manifestError(_this.eventBus, 'parsing the manifest failed', 'parse', data);
                manifest = null;
                callback(null);
            }
        };
        this.setManifestData = function (url, data) {
            var baseUrl = _this.parseBaseUrl(url);
            var self = _this;
            var manifest = null;
            _this.manifestText = data;
            _this.internalParse.call(self, data, baseUrl, function (d) {
                if (d != null) {
                    manifest = d;
                    manifest.mpdUrl = url;
                    self.setValue(manifest);
                }
                else {
                    self.setValue(null);
                }
            });
        };
        /* istanbul ignore next */
        this.getRemotePeriodsX = function (url, pid, remainingAttempts) {
            var request = new XMLHttpRequest();
            var needFailureReport = true;
            var self = _this;
            var aborted = false;
            var qrys = _this.xlinkCommonQrys.concat();
            var hdrs = _this.xlinkCommonHdrs.concat();
            var rPeriodsTxt = null;
            var timeoutTimer = setTimeout(function () {
                _this.logHandler.log('RemotePeriod request aborted!!!');
                _this.NXDebug.debug('RemotePeriod request aborted!!!');
                aborted = true;
                request.abort();
            }, 1000);
            var onload = function () {
                if (request.status < 200 || request.status > 299) {
                    return;
                }
                if (request.responseText.length === 0) {
                    _this.logHandler.log('!!! Load mpd size : ' +
                        request.responseText.length +
                        ' !!!! remainingAttempts:' +
                        remainingAttempts);
                    return;
                }
                _this.xlinkOnSuccess({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                needFailureReport = false;
                rPeriodsTxt = request.responseText;
                rPeriodsTxt = '<root>' + rPeriodsTxt + '</root>';
                try {
                    var parser = new DOMParser();
                    var dom = parser.parseFromString(rPeriodsTxt, 'text/xml');
                    var rperiods = dom.getElementsByTagName('Period');
                    _this.NXDebug.info(String(rperiods));
                    if (rperiods) {
                        //
                    }
                    _this.eventBus.dispatchEvent({
                        type: 'LOAD_RPERIODS_END',
                        data: {
                            success: true,
                            pid: pid,
                            result: rperiods,
                        },
                    });
                    return;
                }
                catch (e) {
                    _this.eventBus.dispatchEvent({
                        type: 'LOAD_RPERIODS_END',
                        data: {
                            success: false,
                            pid: pid,
                            result: null,
                        },
                    });
                    return;
                }
            };
            var report = function () {
                if (aborted) {
                    _this.logHandler.log('remoteperiods request is aborted.' + needFailureReport);
                }
                if (timeoutTimer != null) {
                    clearTimeout(timeoutTimer);
                }
                if (!needFailureReport) {
                    // eslint-disable-line no-empty
                }
                else {
                    _this.xlinkOnError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    needFailureReport = false;
                    if (remainingAttempts > 0) {
                        _this.NXDebug.log('Failed loading remoteperiods: ' +
                            url +
                            ', retry in ' +
                            _this.RETRY_INTERVAL +
                            'ms' +
                            ' attempts: ' +
                            remainingAttempts);
                        remainingAttempts--;
                        setTimeout(function () {
                            _this.getRemotePeriods.call(self, url, pid, remainingAttempts);
                        }, _this.RETRY_INTERVAL);
                    }
                    else {
                        _this.NXDebug.log('Failed loading remoteperiods: ' + url + ' no retry attempts left');
                        _this.errHandler.downloadError(_this.eventBus, 'manifest', url, request);
                        _this.eventBus.dispatchEvent({
                            type: 'LOAD_RPERIODS_END',
                            data: {
                                success: false,
                                pid: pid,
                                result: null,
                            },
                        });
                    }
                }
            };
            request.url = url;
            _this.xlinkOnPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: request,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            try {
                request.onload = onload;
                request.onloadend = report;
                request.onerror = report;
                request.open('GET', request.url, true);
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        request.setRequestHeader(hdr.name, hdr.value);
                    });
                }
                request.send();
            }
            catch (e) {
                request.onerror(e);
            }
        };
        /* istanbul ignore next */
        this.getRemotePeriodsF = function (url, pid, remainingAttempts) {
            var request = {};
            var init = {
                method: 'GET',
                headers: {},
                credentials: 'same-origin',
            };
            var self = _this;
            var acon = {
                aborted: false,
            };
            var qrys = _this.xlinkCommonQrys.concat();
            var hdrs = _this.xlinkCommonHdrs.concat();
            var rPeriodsTxt = null;
            request.url = url;
            _this.xlinkOnPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: request,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            if (hdrs.length > 0) {
                hdrs.forEach(function (hdr) {
                    init.headers[hdr.name] = hdr.value;
                });
            }
            _this.abortWrapper(fetch(request.url, init), acon)
                .then(function (res) {
                request.status = res.status;
                if (res.ok == true) {
                    return res.text();
                }
                else {
                    return Promise.reject(new Error('res.false'));
                }
            })
                .then(function (responseText) {
                if (responseText.length == 0) {
                    _this.logHandler.log('!!! Load mpd size : ' +
                        responseText.length +
                        ' !!!! remainingAttempts:' +
                        remainingAttempts);
                    return Promise.reject(new Error('size0'));
                }
                _this.xlinkOnSuccess({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                rPeriodsTxt = responseText;
                rPeriodsTxt = '<root>' + rPeriodsTxt + '</root>';
                try {
                    var parser = new DOMParser();
                    var dom = parser.parseFromString(rPeriodsTxt, 'text/xml');
                    var rperiods = dom.getElementsByTagName('Period');
                    _this.NXDebug.info(String(rperiods));
                    if (rperiods) {
                        //
                    }
                    _this.eventBus.dispatchEvent({
                        type: 'LOAD_RPERIODS_END',
                        data: {
                            success: true,
                            pid: pid,
                            result: rperiods,
                        },
                    });
                    return;
                }
                catch (e) {
                    _this.eventBus.dispatchEvent({
                        type: 'LOAD_RPERIODS_END',
                        data: {
                            success: false,
                            pid: pid,
                            result: null,
                        },
                    });
                    return;
                }
            })
                // eslint-disable-next-line no-unused-vars
                .catch(function (_err) {
                if (acon.aborted) {
                    _this.logHandler.log('remoteperiods request is aborted.');
                    request.status = -1;
                }
                _this.xlinkOnError({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                if (remainingAttempts > 0) {
                    _this.NXDebug.log('Failed loading remoteperiods: ' +
                        url +
                        ', retry in ' +
                        _this.RETRY_INTERVAL +
                        'ms' +
                        ' attempts: ' +
                        remainingAttempts);
                    remainingAttempts--;
                    setTimeout(function () {
                        _this.getRemotePeriods.call(self, url, pid, remainingAttempts);
                    }, _this.RETRY_INTERVAL);
                }
                else {
                    _this.NXDebug.log('Failed loading remoteperiods: ' + url + ' no retry attempts left');
                    _this.errHandler.downloadError(_this.eventBus, 'manifest', url, request);
                    _this.eventBus.dispatchEvent({
                        type: 'LOAD_RPERIODS_END',
                        data: {
                            success: false,
                            pid: pid,
                            result: null,
                        },
                    });
                }
                return;
            });
        };
        this.getRemotePeriods = function (url, pid, remainingAttempts) {
            return _this.useFetch
                ? _this.getRemotePeriodsF(url, pid, remainingAttempts)
                : _this.getRemotePeriodsX(url, pid, remainingAttempts);
        };
        this.getServerTimeX = function (_callback) {
            var callback = _callback || (function () { });
            if (isNaN(_this.clientServerTimeShift)) {
                var req_1 = new XMLHttpRequest();
                var isSuccessful_1 = false;
                var st_1 = new Date().getTime();
                var url = window.location.href;
                url = url.indexOf('?') > -1 ? url + '&_t=' + st_1 : url + '?_t=' + st_1;
                req_1.open('HEAD', url, true);
                req_1.onload = function () {
                    isSuccessful_1 = true;
                    var sDate = req_1.getResponseHeader('Date');
                    var cur = new Date().getTime();
                    var rtt = cur - st_1;
                    var t = 0;
                    if (sDate != null) {
                        t =
                            Math.ceil((new Date(sDate).getTime() + rtt / 2 - new Date().getTime()) /
                                1000) * 1000;
                        if (t > Math.abs(2)) {
                            _this.clientServerTimeShift = t;
                        }
                        else {
                            _this.clientServerTimeShift = 0;
                        }
                    }
                    else {
                        _this.clientServerTimeShift = 0;
                    }
                    callback(true);
                };
                req_1.onloadend = req_1.onerror = function () {
                    if (!isSuccessful_1) {
                        _this.clientServerTimeShift = 0;
                        callback(true);
                    }
                };
                req_1.send();
            }
            else {
                callback(true);
            }
        };
        this.getServerTimeF = function (_callback) {
            var callback = _callback || (function () { });
            if (isNaN(_this.clientServerTimeShift)) {
                var st_2 = new Date().getTime();
                var url = window.location.href;
                var init = {
                    method: 'HEAD',
                    credentials: 'same-origin',
                    //signal: signal
                };
                url = url.indexOf('?') > -1 ? url + '&_t=' + st_2 : url + '?_t=' + st_2;
                fetch(url, init)
                    .then(function (res) {
                    var sDate = res.headers.get('Date');
                    var cur = new Date().getTime();
                    var rtt = cur - st_2;
                    var t = 0;
                    if (sDate != null) {
                        t =
                            Math.ceil((new Date(sDate).getTime() + rtt / 2 - new Date().getTime()) /
                                1000) * 1000;
                        if (t > Math.abs(2)) {
                            _this.clientServerTimeShift = t;
                        }
                        else {
                            _this.clientServerTimeShift = 0;
                        }
                    }
                    else {
                        _this.clientServerTimeShift = 0;
                    }
                    callback(true);
                })
                    // eslint-disable-next-line no-unused-vars
                    .catch(function (_err) {
                    _this.clientServerTimeShift = 0;
                    callback(true);
                });
            }
            else {
                callback(true);
            }
        };
        this.getServerTime = function (_callback) {
            return _this.useFetch
                ? _this.getServerTimeF(_callback)
                : _this.getServerTimeX(_callback);
        };
        /* istanbul ignore next */
        this.doLoadX = function (url, remainingAttempts) {
            var baseUrl = _this.parseBaseUrl(url);
            var request = new XMLHttpRequest();
            var needFailureReport = true;
            var self = _this;
            var mnfst = null;
            var aborted = false;
            var success = false;
            var qrys = _this.mpdCommonQrys.concat();
            var hdrs = _this.mpdCommonHdrs.concat();
            var timeoutTimer = setTimeout(function () {
                _this.logHandler.log('MPD request aborted!!!');
                _this.NXDebug.debug('MPD request aborted!!!');
                aborted = true;
                request.abort();
            }, 1000);
            var onload = function () {
                _this.lastMpdLoadedTime = new Date().getTime();
                if (request.status < 200 || request.status > 299) {
                    return;
                }
                if (request.responseText.length === 0) {
                    _this.logHandler.log('!!! Load mpd size : ' +
                        request.responseText.length +
                        ' !!!! remainingAttempts:' +
                        remainingAttempts);
                    return;
                }
                if (_this.manifestText == request.responseText) {
                    return;
                }
                _this.mpdOnSuccess({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                needFailureReport = false;
                _this.manifestText = request.responseText;
                _this.internalParse.call(self, request.responseText, baseUrl, function (d) {
                    if (d != null) {
                        mnfst = d;
                        mnfst.mpdUrl = url;
                        success = true;
                        _this.eventBus.dispatchEvent({
                            type: 'LOAD_MANIFEST_END',
                            data: {
                                success: success,
                                result: mnfst,
                            },
                        });
                        return;
                    }
                    else {
                        success = false;
                    }
                });
            };
            var report = function () {
                if (aborted) {
                    _this.logHandler.log('manifest request is aborted.' + needFailureReport);
                }
                if (timeoutTimer != null) {
                    clearTimeout(timeoutTimer);
                }
                if (!needFailureReport) {
                    // eslint-disable-line no-empty
                }
                else {
                    _this.mpdOnError({
                        status: request.status,
                        req: request,
                        xhr: request,
                    });
                    needFailureReport = false;
                    if (remainingAttempts > 0) {
                        _this.NXDebug.log('Failed loading manifest: ' +
                            url +
                            ', retry in ' +
                            _this.RETRY_INTERVAL +
                            'ms' +
                            ' attempts: ' +
                            remainingAttempts);
                        remainingAttempts--;
                        setTimeout(function () {
                            _this.doLoad.call(self, url, remainingAttempts);
                        }, _this.RETRY_INTERVAL);
                    }
                    else {
                        _this.NXDebug.log('Failed loading manifest: ' + url + ' no retry attempts left');
                        _this.errHandler.downloadError(_this.eventBus, 'manifest', url, request);
                        _this.eventBus.dispatchEvent({
                            type: 'LOAD_MANIFEST_END',
                            data: {
                                success: false,
                                result: null,
                            },
                        });
                    }
                }
            };
            request.url = url;
            _this.mpdOnPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: request,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            try {
                request.onload = onload;
                request.onloadend = report;
                request.onerror = report;
                request.open('GET', request.url, true);
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        request.setRequestHeader(hdr.name, hdr.value);
                    });
                }
                request.send();
            }
            catch (e) {
                request.onerror(e);
            }
        };
        /* istanbul ignore next */
        this.doLoadF = function (url, remainingAttempts) {
            var baseUrl = _this.parseBaseUrl(url);
            var request = {};
            var acon = {
                aborted: false,
            };
            var init = {
                method: 'GET',
                headers: {},
                credentials: 'same-origin',
            };
            var self = _this;
            var mnfst = null;
            var success = false;
            var qrys = _this.mpdCommonQrys.concat();
            var hdrs = _this.mpdCommonHdrs.concat();
            request.url = url;
            _this.mpdOnPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: request,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            if (hdrs.length > 0) {
                hdrs.forEach(function (hdr) {
                    init.headers[hdr.name] = hdr.value;
                });
            }
            _this.abortWrapper(fetch(request.url, init), acon)
                .then(function (res) {
                _this.lastMpdLoadedTime = new Date().getTime();
                request.status = res.status;
                if (res.ok == true) {
                    return res.text();
                }
                else {
                    return Promise.reject(new Error('res.false'));
                }
            })
                .then(function (responseText) {
                if (responseText.length == 0) {
                    _this.logHandler.log('!!! Load mpd size : ' +
                        responseText.length +
                        ' !!!! remainingAttempts:' +
                        remainingAttempts);
                    return Promise.reject(new Error('size0'));
                }
                if (_this.manifestText == responseText) {
                    return Promise.reject(new Error('same'));
                }
                _this.mpdOnSuccess({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                //manifestText = responseText;
                var code0 = responseText.charCodeAt(0);
                var code1 = responseText.charCodeAt(1);
                var code2 = responseText.charCodeAt(2);
                if (code0 == 239 && code1 == 187 && code2 == 191) {
                    //remove BOM
                    _this.manifestText = responseText.substring(3);
                }
                else {
                    _this.manifestText = responseText;
                }
                _this.internalParse.call(self, _this.manifestText, baseUrl, function (d) {
                    if (d != null) {
                        mnfst = d;
                        mnfst.mpdUrl = url;
                        success = true;
                        _this.eventBus.dispatchEvent({
                            type: 'LOAD_MANIFEST_END',
                            data: {
                                success: success,
                                result: mnfst,
                            },
                        });
                    }
                    else {
                        success = false;
                    }
                });
                return;
            })
                .catch(function (_err) {
                if (acon.aborted) {
                    _this.logHandler.log('manifest request is aborted.');
                    request.status = -1;
                }
                _this.mpdOnError({
                    status: request.status,
                    req: request,
                    xhr: request,
                });
                if (remainingAttempts > 0) {
                    _this.NXDebug.log('Failed loading manifest: ' +
                        url +
                        ', retry in ' +
                        _this.RETRY_INTERVAL +
                        'ms' +
                        ' attempts: ' +
                        remainingAttempts);
                    remainingAttempts--;
                    setTimeout(function () {
                        _this.doLoad.call(self, url, remainingAttempts);
                    }, _this.RETRY_INTERVAL);
                }
                else {
                    _this.NXDebug.log('Failed loading manifest: ' + url + ' no retry attempts left');
                    _this.errHandler.downloadError(_this.eventBus, 'manifest', url, request);
                    _this.eventBus.dispatchEvent({
                        type: 'LOAD_MANIFEST_END',
                        data: {
                            success: false,
                            result: null,
                        },
                    });
                }
                return;
            });
        };
        this.doLoad = function (url, remainingAttempts) {
            return _this.useFetch
                ? _this.doLoadF(url, remainingAttempts)
                : _this.doLoadX(url, remainingAttempts);
        };
        //NSV-a const replaceByExt = (mnfst) => {
        //NSV-a   const periods = mnfst.mpd.periods;
        //NSV-a   const pids = [];
        //NSV-a
        //NSV-a   for (let i = 0; i < periods.length; i++) {
        //NSV-a     pids.push(periods[i].id);
        //NSV-a     if (hasProperty(xPeriods, periods[i].id)) {
        //NSV-a       const xmnfst = xPeriods[periods[i].id];
        //NSV-a       const xperiod = xmnfst.mpd.periods[0];
        //NSV-a       xperiod.index = periods[i].index;
        //NSV-a       xperiod.id = periods[i].id;
        //NSV-a       xperiod.start = periods[i].start;
        //NSV-a       xperiod.duration = periods[i].duration;
        //NSV-a       xperiod.offset = periods[i].offset;
        //NSV-a       xperiod.end = periods[i].end;
        //NSV-a       xperiod.mpd = periods[i].mpd;
        //NSV-a
        //NSV-a       mnfst.mpd.periods[i] = xperiod;
        //NSV-a     }
        //NSV-a   }
        //NSV-a
        //NSV-a   for (const x in xPeriods) {
        //NSV-a     if (pids.indexOf(x) < 0) {
        //NSV-a       delete xPeriods[x];
        //NSV-a     }
        //NSV-a   }
        //NSV-a
        //NSV-a   return mnfst;
        //NSV-a };
        this.manifestUpdateClear = function () {
            if (_this.manifestRefreshTimer !== null) {
                _this.NXDebug.log('Refresh manifest in ... clearTimeout id : ' + _this.manifestRefreshTimer);
                _this.manifestUpdating = false;
                clearTimeout(_this.manifestRefreshTimer);
                _this.manifestRefreshTimer = null;
            }
            else {
                // eslint-disable-line no-empty
            }
        };
        this.setManifestUpdateStart = function () {
            _this.manifestUpdateClear.call(_this);
            if (!isNaN(_this.manifestRefreshDelay)) {
                _this.NXDebug.log('Refresh manifest in ' + _this.manifestRefreshDelay + ' seconds.');
                // @ts-ignore
                _this.manifestRefreshTimer = setTimeout(_this.onManifestRefreshTimer.bind(_this), Math.min(_this.manifestRefreshDelay * 1000, Math.pow(2, 31) - 1), _this);
            }
        };
        this.manifestUpdateRun = function () {
            var self = _this;
            var timeSinceLastUpdate;
            if (_this.manifest !== undefined && _this.manifest !== null) {
                if (!self.getIsDynamic.call(self, _this.manifest))
                    return;
                timeSinceLastUpdate =
                    (new Date().getTime() - _this.lastMpdLoadedTime) / 1000;
                _this.manifestRefreshDelay = Math.max(_this.DEFAULT_MANIFEST_REFRESH_DELAY - timeSinceLastUpdate, 0);
                _this.NXDebug.debug('Refresh manifest in timeSince:' +
                    timeSinceLastUpdate +
                    ', delay:' +
                    _this.manifestRefreshDelay);
            }
            else {
                _this.manifestRefreshDelay = 0;
            }
            _this.setManifestUpdateStart.call(self);
        };
        this.manifest = null;
        this.DEFAULT_MANIFEST_REFRESH_DELAY =
            params.DEFAULT_MANIFEST_REFRESH_DELAY || 10;
        this.DEFAULT_PRESENTATION_DELAY = params.DEFAULT_PRESENTATION_DELAY || NaN;
        this.DEFAULT_BASEURL_IDX = params.DEFAULT_BASEURL_IDX || 0;
        this.SET_1STSEG_TIME_ZERO =
            params.SET_1STSEG_TIME_ZERO !== undefined
                ? params.SET_1STSEG_TIME_ZERO
                : true;
        this.supported_colour_primaries = params.SUPPORTED_COLOUR_PRIMARIES || [
            1, 9,
        ];
        this.supported_transfer_characteristics =
            params.SUPPORTED_TRANSFER_CHARACTERISTICS || [1, 16, 18];
        this.unuseAudio = params.UNUSE_AUDIO || false;
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.manifestRefreshDelay = NaN;
        this.manifestRefreshTimer = null;
        this.manifestUpdateIsStopped = false;
        this.manifestUpdating = false;
        this.lastMpdLoadedTime = 0;
        this.manifestText = null;
        this.clientServerTimeShift = NaN;
        this.timestampOffsetFor32bitVE = -1;
        this.minBandwidth = {
            video: NaN,
            audio: NaN,
        };
        this.mpdCommonQrys =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'mpd') && (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['mpd'], 'query')
                ? xhrCustom['mpd']['query']
                : [];
        this.mpdCommonHdrs =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'mpd') && (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['mpd'], 'header')
                ? xhrCustom['mpd']['header']
                : [];
        this.mpdOnPrepare =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'mpd') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['mpd'], 'onPrepare')
                ? xhrCustom['mpd']['onPrepare']
                : function () { };
        this.mpdOnSuccess =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'mpd') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['mpd'], 'onSuccess')
                ? xhrCustom['mpd']['onSuccess']
                : function () { };
        this.mpdOnError =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'mpd') && (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['mpd'], 'onError')
                ? xhrCustom['mpd']['onError']
                : function () { };
        this.xlinkCommonQrys =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'xlink') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['xlink'], 'query')
                ? xhrCustom['xlink']['query']
                : [];
        this.xlinkCommonHdrs =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'xlink') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['xlink'], 'header')
                ? xhrCustom['xlink']['header']
                : [];
        this.xlinkOnPrepare =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'xlink') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['xlink'], 'onPrepare')
                ? xhrCustom['xlink']['onPrepare']
                : function () { };
        this.xlinkOnSuccess =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'xlink') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['xlink'], 'onSuccess')
                ? xhrCustom['xlink']['onSuccess']
                : function () { };
        this.xlinkOnError =
            (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'xlink') &&
                (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom['xlink'], 'onError')
                ? xhrCustom['xlink']['onError']
                : function () { };
        this.maxBandwidth = {
            video: NaN,
            audio: NaN,
        };
        this.xlinks = {};
        this.xPeriods = {};
        this.RETRY_ATTEMPTS = 3;
        this.RETRY_INTERVAL = 500;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.eventBus = eventBus;
    }
    /* istanbul ignore next */
    ManifestModel.prototype.parsePeriod = function (mpd, periodNodes, _callback) {
        var _this = this;
        var periods = [];
        var self = this;
        var callback = _callback || (function () { });
        var periodCheck = function (periodNodes) {
            var pp = [];
            var p = null;
            var vo = null;
            var p1 = null;
            var vo1 = null;
            var attr;
            for (var i = 0; i < periodNodes.length; i++) {
                p = periodNodes[i];
                // If the attribute @start is present in the Period, then the
                // Period is a regular Period and the PeriodStart is equal
                // to the value of this attribute.
                if (p.getAttribute('start')) {
                    vo = new _Period__WEBPACK_IMPORTED_MODULE_5__.Period();
                    vo.start = _this.parseDuration(p.getAttribute('start'));
                }
                // If the @start attribute is absent, but the previous Period
                // element contains a @duration attribute then then this new
                // Period is also a regular Period. The start time of the new
                // Period PeriodStart is the sum of the start time of the previous
                // Period PeriodStart and the value of the attribute @duration
                // of the previous Period.
                else if (p1 !== null && p.getAttribute('duration')) {
                    vo = new _Period__WEBPACK_IMPORTED_MODULE_5__.Period();
                    vo.start = _this.float3(vo1.start + vo1.duration);
                    vo.duration = _this.parseDuration(p.getAttribute('duration'));
                    vo.end = _this.float3(vo.start + vo.duration);
                }
                // If (i) @start attribute is absent, and (ii) the Period element
                // is the first in the MPD, and (iii) the MPD@type is 'static',
                // then the PeriodStart time shall be set to zero.
                else if (i === 0) {
                    vo = new _Period__WEBPACK_IMPORTED_MODULE_5__.Period();
                    vo.start = 0;
                    //vo.duration = mpd.mediaPresentationDuration;
                }
                // The Period extends until the PeriodStart of the next Period.
                // The difference between the PeriodStart time of a Period and
                // the PeriodStart time of the following Period.
                if (vo1 !== null && isNaN(vo1.duration)) {
                    vo1.duration = _this.float3(vo.start - vo1.start);
                    vo1.end = _this.float3(vo1.start + vo1.duration);
                }
                if (vo !== null) {
                    if (p.getAttribute('id')) {
                        vo.id = p.getAttribute('id');
                    }
                    else {
                        vo.id = 'pid:' + i;
                    }
                }
                if (vo !== null && p.getAttribute('duration')) {
                    vo.duration = _this.parseDuration(p.getAttribute('duration'));
                    vo.end = _this.float3(vo.start + vo.duration);
                }
                if (vo !== null && p.getAttribute('xlink:href')) {
                    if (!(0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(_this.xlinks, vo.id) &&
                        !(0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(_this.xPeriods, vo.id)) {
                        _this.xlinks[vo.id] = p.getAttribute('xlink:href');
                    }
                }
                if (vo !== null) {
                    vo.index = i;
                    vo.mpd = mpd;
                    vo.childNodes = [];
                    var childNodes = periodNodes[i].childNodes;
                    for (var ii = 0; ii < childNodes.length; ii++) {
                        if (childNodes[ii].nodeName === 'AdaptationSet') {
                            vo.childNodes.push(childNodes[ii]);
                        }
                        else if (childNodes[ii].nodeName === 'BaseURL') {
                            var url = childNodes[ii].textContent;
                            var baseURL = new BaseURL();
                            if (url.indexOf('http://') === 0 ||
                                url.indexOf('https://') === 0) {
                                baseURL.url = url;
                                attr = childNodes[ii].getAttribute('availabilityTimeOffset');
                                if (attr) {
                                    baseURL.availabilityTimeOffset = parseFloat(attr);
                                }
                                vo.BaseURL.push(baseURL);
                            }
                            else {
                                for (var bb = 0; bb < mpd.BaseURL.length; bb++) {
                                    baseURL = mpd.BaseURL[bb].copy();
                                    baseURL.url = baseURL.url + url;
                                    attr = childNodes[ii].getAttribute('availabilityTimeOffset');
                                    if (attr) {
                                        baseURL.availabilityTimeOffset = parseFloat(attr);
                                    }
                                    vo.BaseURL.push(baseURL);
                                }
                            }
                        }
                        else if (childNodes[ii].nodeName === 'AssetIdentifier') {
                            vo.assetId = childNodes[ii].getAttribute('value');
                        }
                        else if (childNodes[ii].nodeName === 'EventStream') {
                            _this.parseEventStream(childNodes[ii], vo.outEventList);
                        }
                    }
                    if (vo.BaseURL.length === 0) {
                        mpd.BaseURL.forEach(function (b) {
                            vo.BaseURL.push(b.copy());
                        });
                    }
                    pp.push(vo);
                }
                p1 = p;
                p = null;
                vo1 = vo;
                vo = null;
            }
            p1 = null;
            vo1 = null;
            var checkTime = NaN;
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(mpd, 'minimumUpdatePeriod')) {
                //checkTime = timelineConverter.calcPresentationTimeFromWallTime(new Date(mpd.manifest.mpdLoadedTime.getTime()+clientServerTimeShift), pp[0]) + mpd.minimumUpdatePeriod;
                checkTime = _this.timelineConverter.calcPresentationTimeFromWallTime(new Date(mpd.manifest.mpdLoadedTime.getTime() + _this.clientServerTimeShift), pp[0]);
            }
            mpd.checkTime = checkTime;
            if (pp[pp.length - 1].end == Infinity) {
                var periodEndTime = 0;
                if (mpd.mediaPresentationDuration) {
                    periodEndTime = mpd.mediaPresentationDuration;
                }
                else if (!isNaN(mpd.checkTime)) {
                    // in this case the Period End Time should match CheckTime
                    periodEndTime = mpd.checkTime;
                }
                else {
                    _this.NXDebug.log('Must have @mediaPresentationDuration or @minimumUpdatePeriod on MPD or an explicit @duration on the last period.');
                }
                if (pp[pp.length - 1].start < periodEndTime) {
                    pp[pp.length - 1].end = _this.float3(periodEndTime);
                    pp[pp.length - 1].duration = _this.float3(pp[pp.length - 1].end - pp[pp.length - 1].start);
                }
                else {
                    pp.pop();
                }
            }
            return pp;
        };
        var processXlinks = function (_callback) {
            var callback = _callback;
            if (Object.keys(_this.xlinks).length > 0) {
                var rpCount_1 = 0;
                var loadRPeriodsEndListener_1 = function (evt) {
                    rpCount_1--;
                    if (evt.data.success) {
                        _this.xPeriods[evt.data.pid] = periodCheck(evt.data.result);
                        _this.NXDebug.info(String(_this.xPeriods[evt.data.pid]));
                    }
                    delete _this.xlinks[evt.data.pid];
                    if (rpCount_1 == 0) {
                        _this.eventBus.removeEventListener('LOAD_RPERIODS_END', loadRPeriodsEndListener_1);
                        callback();
                    }
                };
                _this.eventBus.addEventListener('LOAD_RPERIODS_END', loadRPeriodsEndListener_1);
                for (var x in _this.xlinks) {
                    _this.getRemotePeriods(_this.xlinks[x], x, 1);
                    rpCount_1++;
                }
            }
            else {
                callback();
            }
        };
        var replaceByExt = function (periods) {
            var pids = [];
            var tlen = periods.length;
            var i = 0;
            for (i = 0; i < tlen; i++) {
                pids.push(periods[i].id);
            }
            i = 0;
            var _loop_2 = function () {
                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(_this.xPeriods, periods[i].id)) {
                    var xperiods_1 = _this.xPeriods[periods[i].id];
                    var start = periods[i].start;
                    var duration = periods[i].duration;
                    var end = periods[i].end;
                    var dstart = _this.float3(start - xperiods_1[0].start);
                    var len = xperiods_1.length;
                    var rperiods = [];
                    var p_1;
                    var cdur = 0;
                    var _loop_3 = function (jj) {
                        p_1 = new _Period__WEBPACK_IMPORTED_MODULE_5__.Period();
                        Object.keys(xperiods_1[jj]).forEach(function (k) {
                            p_1[k] = xperiods_1[jj][k];
                        });
                        p_1.id = periods[i].id + ' #' + jj;
                        p_1.start = _this.float3(xperiods_1[jj].start + dstart);
                        p_1.offset = p_1.start;
                        p_1.duration = xperiods_1[jj].duration;
                        p_1.end = _this.float3(p_1.start + xperiods_1[jj].duration);
                        p_1.mpd = mpd;
                        cdur += p_1.duration;
                        if (jj == len - 1 || cdur >= duration) {
                            p_1.end = end;
                            p_1.duration = _this.float3(p_1.end - p_1.start);
                            jj = len - 1;
                        }
                        rperiods.push(p_1);
                        out_jj_1 = jj;
                    };
                    var out_jj_1;
                    for (var jj = 0; jj < len; jj++) {
                        _loop_3(jj);
                        jj = out_jj_1;
                    }
                    if (rperiods.length == 1) {
                        periods[i] = rperiods[0];
                        i++;
                    }
                    else {
                        periods.splice(i, 1);
                        tlen -= 1;
                        for (var jj = 0; jj < rperiods.length; jj++) {
                            _this.NXDebug.log('i=' + i);
                            periods.splice(i, 0, rperiods[jj]);
                            tlen++;
                            i++;
                        }
                    }
                }
                else {
                    i++;
                }
            };
            while (i < tlen) {
                _loop_2();
            }
            for (i = 0; i < periods.length; i++) {
                periods[i].index = i;
            }
            for (var x in _this.xPeriods) {
                if (pids.indexOf(x) < 0) {
                    delete _this.xPeriods[x];
                }
            }
            return periods;
        };
        periods = periodCheck(periodNodes);
        for (var i = 0; i < periods.length; i++) {
            //liveMulti
            if (periods[i].assetId) {
                var offset = 0;
                for (var j = 0; j < i; j++) {
                    if (periods[i].assetId !== periods[j].assetId) {
                        offset = this.float3(offset + periods[j].duration);
                    }
                }
                periods[i].offset = offset;
            }
            else {
                periods[i].offset = periods[i].start;
            }
            //liveMulti
        }
        processXlinks.call(self, function () {
            periods = replaceByExt(periods);
            for (var i = 0; i < periods.length; i++) {
                if (periods[i].BaseURL.length > 0) {
                    periods[i].selectedBaseURLIdx =
                        _this.DEFAULT_BASEURL_IDX < periods[i].BaseURL.length
                            ? _this.DEFAULT_BASEURL_IDX
                            : 0;
                }
                periods[i].clientServerTimeShift = _this.clientServerTimeShift;
                periods[i].isClientServerTimeSyncCompleted = true;
                periods[i].isClientServerTimeSyncCompletedForTC = true;
            }
            callback({
                data: periods,
            });
        });
    };
    ManifestModel.prototype.manifestUpdateStartPoll = function () {
        var self = this;
        var timeSinceLastUpdate;
        if (this.manifest !== undefined && this.manifest !== null) {
            if (!self.getIsDynamic.call(self, this.manifest))
                return;
            timeSinceLastUpdate =
                (new Date().getTime() - this.lastMpdLoadedTime) / 1000;
            this.manifestRefreshDelay = Math.max(this.getRefreshDelay.call(self, this.manifest) - timeSinceLastUpdate, 0);
            if (this.manifestRefreshDelay == 0) {
                this.manifestUpdateIsStopped = false;
                this.onManifestRefreshTimer.call(self);
            }
        }
    };
    /* istanbul ignore next */
    ManifestModel.prototype.onManifestRefreshTimer = function () {
        var _this = this;
        var self = this;
        var url;
        var manifestUpdate = function () {
            _this.eventBus.removeEventListener('REFRESH_MANIFEST_END', manifestUpdate);
            if (_this.manifestUpdating === false) {
                _this.manifestUpdating = true;
            }
            else {
                _this.NXDebug.log('### MPD Refresh Skip ###');
                //eventBus.removeEventListener("REFRESH_MANIFEST_END",manifestUpdate);
                return;
            }
            _this.NXDebug.debug('######################## Refresh Start ######################### Refresh manifest in ');
            _this.manifestUpdateClear.call(self);
            url = _this.manifest.mpdUrl;
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(_this.manifest, 'Location')) {
                url = _this.manifest.Location;
            }
            var loadManifestListener = function (evt) {
                if (evt.data.success) {
                    _this.NXDebug.log('Manifest has been refreshed. Refresh manifest in');
                    if (_this.manifestUpdateIsStopped)
                        return;
                }
                else {
                    _this.NXDebug.log('Failed to refresh Manifest. Refresh manifest in');
                }
                self.setValue(evt.data.result);
                _this.manifestUpdateRun.call(self);
                _this.eventBus.removeEventListener('LOAD_MANIFEST_END', loadManifestListener);
            };
            _this.eventBus.addEventListener('LOAD_MANIFEST_END', loadManifestListener);
            self.loadManifest.call(self, url);
        };
        if (this.manifestUpdating) {
            this.NXDebug.debug('refresh updating...');
        }
        else {
            manifestUpdate();
        }
    };
    ManifestModel.prototype.loadManifest = function (url) {
        this.doLoad.call(this, url, this.RETRY_ATTEMPTS);
    };
    ManifestModel.prototype.setManifestFromExt = function (url, data) {
        this.setManifestData.call(this, url, data);
    };
    ManifestModel.prototype.getIsDynamic = function (manifest) {
        var isDynamic = false;
        var LIVE_TYPE = 'dynamic';
        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(manifest.mpd, 'type')) {
            isDynamic = manifest.mpd.type === LIVE_TYPE;
        }
        return isDynamic;
    };
    // getEventsForPeriod(
    //   manifest: ManifestModel,
    //   period: Period
    // ): Array<DashEvent> {
    //   const periodArray: Array<Period> = manifest.mpd!.periods;
    //   const eventStreams: Array<NXEventStream> | undefined =
    //     periodArray[period.index].eventStreams;
    //   const events: Array<DashEvent> = [];
    //   if (eventStreams) {
    //     for (let i = 0; i < eventStreams.length; i += 1) {
    //       const eventStream: EventStream = new EventStream();
    //       eventStream.period = period;
    //       eventStream.timescale = 1;
    //       if (hasProperty(eventStreams[i], 'schemeIdUri')) {
    //         eventStream.schemeIdUri = eventStreams[i].schemeIdUri!;
    //       } else {
    //         throw 'Invalid EventStream. SchemeIdUri has to be set';
    //       }
    //       if (hasProperty(eventStreams[i], 'timescale')) {
    //         eventStream.timescale = eventStreams[i].timescale!;
    //       }
    //       if (hasProperty(eventStreams[i], 'value')) {
    //         eventStream.value = eventStreams[i].value!;
    //       }
    //       for (let j = 0; j < eventStreams[i].events!.length; j += 1) {
    //         const event: DashEvent = new DashEvent();
    //         event.presentationTime = 0;
    //         event.eventStream = eventStream;
    //         if (hasProperty(eventStreams[i].events![j], 'presentationTime')) {
    //           event.presentationTime = eventStreams[i].events![
    //             j
    //           ].presentationTime;
    //         }
    //         if (hasProperty(eventStreams[i].events![j], 'duration')) {
    //           event.duration = eventStreams[i].events![j].duration;
    //         }
    //         if (hasProperty(eventStreams[i].events![j], 'id')) {
    //           event.id = eventStreams[i].events![j].id;
    //         }
    //         events.push(event);
    //       }
    //     }
    //   }
    //   return events;
    // }
    // getEventStreamForAdaptationSet(data: Representation): Array<NXEventStream> {
    //   const eventStreams: Array<NXEventStream> = [];
    //   const inbandStreams: undefined | Array<NXEventStream> =
    //     data.inbandEventStreams;
    //   if (inbandStreams) {
    //     for (let i = 0; i < inbandStreams.length; i += 1) {
    //       const eventStream: NXEventStream = new EventStream();
    //       eventStream.timescale = 1;
    //       if (hasProperty(inbandStreams[i], 'schemeIdUri')) {
    //         eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;
    //       } else {
    //         throw 'Invalid EventStream. SchemeIdUri has to be set';
    //       }
    //       if (hasProperty(inbandStreams[i], 'timescale')) {
    //         eventStream.timescale = inbandStreams[i].timescale;
    //       }
    //       if (hasProperty(inbandStreams[i], 'value')) {
    //         eventStream.value = inbandStreams[i].value;
    //       }
    //       eventStreams.push(eventStream);
    //     }
    //   }
    //   return eventStreams;
    // }
    // getEventStreamForRepresentation(
    //   data,
    //   representation: Representation
    // ): Array<NXEventStream> {
    //   const eventStreams: Array<NXEventStream> = [];
    //   const inbandStreams: undefined | Array<NXEventStream> =
    //     data.representations[representation.index].inbandEventStreams;
    //   if (inbandStreams) {
    //     for (let i = 0; i < inbandStreams.length; i++) {
    //       const eventStream = new EventStream();
    //       eventStream.timescale = 1;
    //       eventStream.representation = representation;
    //       if (hasProperty(inbandStreams[i], 'schemeIdUri')) {
    //         eventStream.schemeIdUri = inbandStreams[i].schemeIdUri!;
    //       } else {
    //         throw 'Invalid EventStream. SchemeIdUri has to be set';
    //       }
    //       if (hasProperty(inbandStreams[i], 'timescale')) {
    //         eventStream.timescale = inbandStreams[i].timescale!;
    //       }
    //       if (hasProperty(inbandStreams[i], 'value')) {
    //         eventStream.value = inbandStreams[i].value!;
    //       }
    //       eventStreams.push(eventStream);
    //     }
    //   }
    //   return eventStreams;
    // }
    ManifestModel.prototype.getValue = function () {
        return this.manifest;
    };
    ManifestModel.prototype.setValue = function (value) {
        if (value != null) {
            this.manifest = value;
            this.eventBus.dispatchEvent({
                type: 'manifestUpdated',
                data: {},
            });
        }
        else {
            this.NXDebug.debug('manifest load failed ...');
            this.onManifestRefreshEnd();
        }
    };
    ManifestModel.prototype.setBandwidthLimit = function (min, max) {
        this.minBandwidth = min;
        this.maxBandwidth = max;
    };
    ManifestModel.prototype.manifestUpdateStart = function () {
        this.manifestUpdateIsStopped = false;
        this.manifestUpdateRun.call(this);
    };
    ManifestModel.prototype.manifestUpdateStop = function () {
        this.manifestUpdateIsStopped = true;
        this.manifestUpdateClear.call(this);
    };
    ManifestModel.prototype.onManifestRefreshEnd = function () {
        // When streams are ready we can consider manifest update completed. Resolve the update promise.
        if (this.manifestUpdating) {
            this.manifestUpdating = false;
            this.eventBus.dispatchEvent({
                type: 'REFRESH_MANIFEST_END',
                data: {},
            });
        }
    };
    return ManifestModel;
}());



/***/ }),

/***/ "./ts/dash/manifest/Mpd.ts":
/*!*********************************!*\
  !*** ./ts/dash/manifest/Mpd.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mpd": function() { return /* binding */ Mpd; }
/* harmony export */ });
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Mpd
 * @constructor
 */
var Mpd = /** @class */ (function () {
    function Mpd() {
        this.manifest = null;
        this.BaseURL = [];
        this.targetLatency = NaN;
        this.targetLatencyMin = NaN;
        this.targetLatencyMax = NaN;
        this.referenceIdPRT = NaN; //this.referenceIdPRT = null;
        this.playbackRateMin = 1;
        this.playbackRateMax = 1;
        this.suggestedPresentationDelay = 20;
        this.availabilityStartTime = new Date(0);
        this.publishTime = NaN;
        this.availabilityEndTime = new Date(0);
        this.timeShiftBufferDepth = Number.POSITIVE_INFINITY;
        this.maxSegmentDuration = Number.POSITIVE_INFINITY;
        this.checkTime = NaN;
        this.timestampOffsetFor32bitVE = 0;
        this.liveEdge = NaN;
        this.liveEdgeS = NaN;
        this.liveEdgeE = NaN;
        this.liveEdgeC = NaN;
        this.periods = [];
    }
    return Mpd;
}());



/***/ }),

/***/ "./ts/dash/manifest/Period.ts":
/*!************************************!*\
  !*** ./ts/dash/manifest/Period.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Period": function() { return /* binding */ Period; }
/* harmony export */ });
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Period
 * @constructor
 */
var Period = /** @class */ (function () {
    //  eventStreams?: Array<NXEventStream>;
    function Period() {
        var _this = this;
        this.getDataForIndex = function (index) {
            return _this.adaptationSets[index];
        };
        this.getDataForRole = function (type, value) {
            var asets = _this.adaptationSets;
            for (var i = 0; i < asets.length; i++) {
                if (asets[i].type == type) {
                    if (asets[i].getRole() == value) {
                        return asets[i];
                    }
                }
            }
            return _this.getPrimaryMediaData(type);
        };
        this.id = null;
        this.index = -1;
        this.duration = NaN;
        this.start = NaN;
        this.end = Infinity;
        this.mpd = null;
        this.type = null;
        this.BaseURL = [];
        this.selectedBaseURLIdx = NaN;
        this.liveEdge = NaN;
        this.liveEdgeS = NaN;
        this.liveEdgeE = NaN;
        this.liveEdgeC = NaN;
        this.temporalLiveEdgeDecided = {
            video: false,
            audio: false,
        };
        this.isClientServerTimeSyncCompleted = false;
        this.isClientServerTimeSyncCompletedForTC = false;
        this.clientServerTimeShift = 0;
        this.timestampOffsetFor32bitVE = 0;
        this.assetId = null;
        this.offset = NaN;
        this.liveEdgeFromRequest = 0;
        this.outEventList = [];
        this.inEventList = [];
        this.adaptationSets = [];
    }
    Period.prototype.getPrimaryMediaData = function (type) {
        var adaptations = this.adaptationSets;
        var medias = [];
        for (var i = 0; i < adaptations.length; i++) {
            if (adaptations[i].type === type) {
                if (adaptations[i].getIsMain()) {
                    return adaptations[i];
                }
                else {
                    medias.push(adaptations[i]);
                }
            }
        }
        if (medias.length == 0) {
            return null;
        }
        else {
            return medias[0];
        }
    };
    Period.prototype.getRolesFor = function (type) {
        var roles = [];
        var asets = this.adaptationSets;
        for (var i = 0; i < asets.length; i++) {
            if (asets[i].type === type) {
                var role = {
                    index: i,
                    id: asets[i].id,
                    role: asets[i].getRole(),
                };
                roles.push(role);
            }
        }
        return roles;
    };
    Period.prototype.getDataForId = function (id) {
        var adaptations = this.adaptationSets;
        var len = adaptations.length;
        for (var i = 0; i < len; i++) {
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(adaptations[i], 'id') && adaptations[i].id === id) {
                return adaptations[i];
            }
        }
        return null;
    };
    return Period;
}());



/***/ }),

/***/ "./ts/dash/manifest/Representation.ts":
/*!********************************************!*\
  !*** ./ts/dash/manifest/Representation.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Representation": function() { return /* binding */ Representation; }
/* harmony export */ });
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Representation
 * @constructor
 */
var Representation = /** @class */ (function () {
    function Representation() {
        this.id = null;
        this.index = -1;
        this.BaseURL = [];
        this.adaptation = null;
        this.segmentInfoType = null;
        this.initialization = null;
        this.segmentDuration = NaN;
        this.timescale = 1;
        this.startNumber = 1;
        this.indexRange = null;
        this.range = null;
        this.presentationTimeOffset = 0;
        this.MSETimeOffset = NaN;
        this.segmentAvailabilityRange = null;
        this.availableSegmentsNumber = 0;
        this.codecs = null;
        this.mimeType = null;
        this.segments = null;
        this.indexOffset = 0;
        this.availabilityTimeOffset = 0;
        this.lastRequestIndex = -1;
        this.transferCharacteristics = 1;
        this.colourPrimaries = 1;
        this.producerReferenceTime = {
            id: null,
            inband: false,
            type: null,
            wallClockTime: null,
            presentationTime: NaN,
        };
    }
    return Representation;
}());



/***/ }),

/***/ "./ts/dash/manifest/TimelineConverter.ts":
/*!***********************************************!*\
  !*** ./ts/dash/manifest/TimelineConverter.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
function _calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {
    var availabilityTime;
    if (calculateEnd) {
        //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed
        // to be available for a Media Presentation with type 'dynamic'.
        // When not present, the value is infinite.
        if (isDynamic && mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY) {
            availabilityTime = new Date(mpd.availabilityStartTime.getTime() +
                (presentationTime + mpd.timeShiftBufferDepth) * 1000);
        }
        else {
            availabilityTime = mpd.availabilityEndTime;
        }
    }
    else {
        if (isDynamic) {
            availabilityTime = new Date(mpd.availabilityStartTime.getTime() + presentationTime * 1000);
        }
        else {
            // in static mpd, all segments are available at the same time
            availabilityTime = mpd.availabilityStartTime;
        }
    }
    return availabilityTime;
}
var TimelineConverter = {
    calcAvailabilityStartTimeFromPresentationTime: function (presentationTime, mpd, isDynamic) {
        return _calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);
    },
    calcAvailabilityEndTimeFromPresentationTime: function (presentationTime, mpd, isDynamic) {
        return _calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);
    },
    // calcPresentationStartTime(period: Period): number {
    //   let presentationStartTime: number;
    //   let isDynamic: boolean;
    //   isDynamic = period.mpd!.type === 'dynamic';
    //   if (isDynamic) {
    //     presentationStartTime = period.mpd!.liveEdgeC;
    //   } else {
    //     presentationStartTime = period.start;
    //   }
    //   return presentationStartTime;
    // },
    calcPresentationTimeFromWallTime: function (wallTime, period) {
        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime()) / 1000);
    },
    calcPresentationTimeFromMediaTime: function (mediaTime, representation) {
        var offset = representation.adaptation.period.offset;
        var presentationOffset = representation.presentationTimeOffset;
        return offset - presentationOffset + mediaTime;
    },
    calcMediaTimeFromPresentationTime: function (presentationTime, representation) {
        var offset = representation.adaptation.period.offset;
        return presentationTime - offset;
    },
    calcWallTimeForSegment: function (segment, isDynamic) {
        if (!isDynamic) {
            return NaN;
        }
        var suggestedPresentationDelay = segment.representation.adaptation.period.mpd
            .suggestedPresentationDelay;
        var displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;
        var wallTime = typeof segment.availabilityStartTime == 'number'
            ? new Date(segment.availabilityStartTime + displayStartTime * 1000)
            : new Date(segment.availabilityStartTime.getTime() + displayStartTime * 1000);
        return wallTime;
    },
    //NSV-a  const usePublishTime = (representation, duration) => {
    //NSV-a    const publishTime = representation.adaptation.period.mpd.publishTime,
    //NSV-a      isSegmentTemplate = representation.segmentInfoType == 'SegmentTemplate';
    //NSV-a
    //NSV-a    if (isNaN(publishTime)) return false;
    //NSV-a    if (isNaN(duration)) return false;
    //NSV-a
    //NSV-a    if (isSegmentTemplate) {
    //NSV-a      const startTime =
    //NSV-a        representation.adaptation.period.mpd.availabilityStartTime;
    //NSV-a      if (publishTime.getTime() - startTime.getTime() > 2000 * duration) {
    //NSV-a        return true;
    //NSV-a      } else {
    //NSV-a        return false;
    //NSV-a      }
    //NSV-a    } else {
    //NSV-a      return true;
    //NSV-a    }
    //NSV-a  };
    calcSegmentAvailabilityRange: function (representation, isDynamic) {
        var duration = representation.segmentDuration;
        var period = representation.adaptation.period;
        var periodStart = period.start;
        var periodEnd = periodStart + period.duration;
        if (!isDynamic) {
            return {
                start: periodStart,
                end: periodEnd,
            };
        }
        var periods = period.mpd.periods;
        var isClientServerTimeSyncCompleted = period.isClientServerTimeSyncCompletedForTC;
        var clientServerTimeShift = period.clientServerTimeShift;
        if ((!isClientServerTimeSyncCompleted || isNaN(duration)) &&
            representation.segmentAvailabilityRange) {
            return representation.segmentAvailabilityRange;
        }
        var currentPresentationTime = this.calcPresentationTimeFromWallTime(new Date(new Date().getTime() + clientServerTimeShift), period);
        var now = period.liveEdgeFromRequest > 0
            ? Math.max(currentPresentationTime, period.liveEdgeFromRequest)
            : currentPresentationTime;
        if (period.start === periods[0].start)
            periodStart = Math.max(now -
                period.mpd.timeShiftBufferDepth -
                duration -
                period.mpd.timestampOffsetFor32bitVE, 0);
        if (period.start === periods[periods.length - 1].start)
            periodEnd = Math.max(now -
                duration +
                representation.availabilityTimeOffset -
                period.mpd.timestampOffsetFor32bitVE, 0);
        return {
            start: periodStart,
            end: periodEnd,
            now: periodEnd,
        };
    },
    // calcMSETimeOffset(representation: Representation): number {
    //   const period: Period = representation.adaptation!.period!;
    //   return period.offset;
    // },
};
/* harmony default export */ __webpack_exports__["default"] = (TimelineConverter);


/***/ }),

/***/ "./ts/dash/protection/ProtectionController.ts":
/*!****************************************************!*\
  !*** ./ts/dash/protection/ProtectionController.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtectionController": function() { return /* binding */ ProtectionController; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _ProtectionModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProtectionModel */ "./ts/dash/protection/ProtectionModel.ts");
/* harmony import */ var _ProtectionModelEME01b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProtectionModelEME01b */ "./ts/dash/protection/ProtectionModelEME01b.ts");
/* harmony import */ var _ProtectionModelRMKSA__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ProtectionModelRMKSA */ "./ts/dash/protection/ProtectionModelRMKSA.ts");
// The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
//
// Copyright (c) 2014, Microsoft Open Technologies, Inc.
// Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
//
// All rights reserved.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.






/**
 * ProtectionController
 *
 * @module ProtectionController（ProtectionControllerモジュール）
 */
/**
 * ProtectionController
 * @constructor
 */
var ProtectionController = /** @class */ (function () {
    function ProtectionController(params, eventBus, xhrCustom) {
        var _this = this;
        this.sessionIds = {};
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__["default"];
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.sessionToKID = {};
        //
        // Encrypted Media Extensions
        //
        /* istanbul ignore next */
        this.onMediaSourceNeedsKey = function (event) {
            var videoCodec;
            var contentProtection;
            _this.logHandler.log_item('needkey_type', event.type);
            _this.eventTypeList.push(event.type);
            if (_this.stream != null && !_this.periodInfo) {
                _this.periodInfo = _this.stream.getPeriodInfo();
            }
            var videoData = _this.periodInfo.getPrimaryMediaData('video');
            if (videoData !== null) {
                videoCodec = videoData.getCodec();
                contentProtection = videoData.getContentProtectionData();
                _this.logHandler.log('Code: ' + videoCodec, '#ff8080');
                _this.logHandler.log('CP: ' + contentProtection[0].schemeIdUri, '#ff8080');
            }
            _this.needsKeyQue.push({
                type: event.type,
                initData: event.initData,
                codec: videoCodec,
                contentProtection: contentProtection,
            });
            if (_this.needsKeyProcessing) {
                _this.needsKeyProcessListener = _this.needsKeyHandlerMED.bind(self);
                _this.eventBus.addEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
            }
            else {
                _this.needsKeyHandlerMED.call(self, null);
            }
        };
        this.needsKeyHandlerMED = function (evt) {
            var self = _this;
            var q;
            var ret;
            //var contentProtection = null;
            var curType = evt != null ? evt.data.keysTypeString : 'none';
            if (_this.needsKeyQue.length == 0) {
                _this.eventBus.removeEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
                _this.needsKeyProcessListener = null;
                return;
            }
            _this.stream.clearInitTimer();
            while (_this.needsKeyQue.length > 0) {
                q = _this.needsKeyQue.shift();
                _this.logHandler.log('EventType: ' + q.type, '#ff8080');
                _this.NXDebug.log('DRM: Key required for - ' + q.codec);
                _this.logHandler.log('DRM: Key required for - ' + q.codec);
                if (q.contentProtection != null && q.codec != null) {
                    try {
                        ret = _this.protectionModel.selectKeySystem(q.codec, q.contentProtection, q.initData);
                        _this.kid = ret.kid;
                        if (curType != 'none' && curType != ret.keysTypeString) {
                            continue;
                        }
                    }
                    catch (error) {
                        _this.NXDebug.log(error);
                        _this.errHandler.mediaKeySystemSelectionError(_this.eventBus, error);
                        continue;
                    }
                }
                _this.initData.push({
                    type: q.codec,
                    initData: q.initData,
                });
                _this.logHandler.log('kid: ' + _this.kid, '#ff8080');
                //if ((kid != null) &&(updatedKIDs.indexOf(kid) < 0)){
                if (_this.kid != null) {
                    var ss;
                    ss = _this.protectionModel.ensureKeySession(_this.kid, q.codec, q.initData);
                    if (ss) {
                        if (ss.sessionIdIsAvailable) {
                            _this.sessionToKID[ss.sessionId] = _this.kid;
                        }
                        else {
                            _this.sessionToKID[ss.tmpSessionId] = _this.kid;
                        }
                        _this.needsKeyProcessing = true;
                        _this.needsKeyProcessingTimerId = setTimeout(function () {
                            if (self.needsKeyProcessing) {
                                self.needsKeyProcessing = false;
                                self.eventBus.dispatchEvent({
                                    type: 'ON_ADDED_KEY_PROCESSED',
                                    data: { kid: self.kid, keysTypeString: 'none' },
                                });
                            }
                            self.stream.onKeyAdded();
                            self.needsKeyProcessingTimerId = null;
                        }, 1000);
                        if (_this.needsKeyQue.length > 0 && !_this.needsKeyProcessListener) {
                            _this.needsKeyProcessListener =
                                _this.needsKeyHandlerEME01b.bind(self);
                            _this.eventBus.addEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
                        }
                        break;
                    }
                }
            }
        };
        this.onMediaSourceKeyMessage = function (event) {
            var session = null;
            var bytes = null;
            //let msg: Nullable<string> = null;
            var laURL = null;
            var keySystem = event.target.keySystem;
            var kid = null;
            _this.NXDebug.log('DRM: Got a key message...');
            if (_this.needsKeyProcessingTimerId) {
                clearTimeout(_this.needsKeyProcessingTimerId);
                _this.needsKeyProcessingTimerId = null;
            }
            session = event.target;
            if (keySystem !== 'webkit-org.w3.clearkey' &&
                keySystem !== 'org.w3.clearkey') {
                if (event.type == 'mskeymessage') {
                    bytes = new Uint16Array(event.message.buffer);
                }
                else {
                    bytes = new Uint16Array(event.message);
                }
                laURL = event.destinationURL || 'unknown';
                _this.logHandler.log_DRM('message<br>&nbsp;&nbsp;laURL ==> ' + laURL, 0);
                if (session.sessionIdIsAvailable) {
                    kid = _this.sessionToKID[session.sessionId];
                }
                else {
                    kid = _this.sessionToKID[session.tmpSessionId];
                }
                _this.protectionModel.updateFromMessage(kid, session, bytes, laURL, function (d) {
                    if (d.status === 'error') {
                        _this.NXDebug.log(d.msg);
                        _this.errHandler.mediaKeyMessageError(_this.eventBus, d.msg);
                    }
                    _this.updatedKIDs.push(kid);
                    _this.eventBus.dispatchEvent({
                        type: 'addKeyProcessed',
                        data: { kid: kid, keysTypeString: keySystem },
                    });
                });
            }
            else {
                if (session.sessionIdIsAvailable) {
                    kid = _this.sessionToKID[session.sessionId];
                }
                else {
                    kid = _this.sessionToKID[session.tmpSessionId];
                }
                _this.protectionModel.updateFromMessageForClearKey(kid, session.sessionId, event.message);
            }
        };
        this.onMediaSourceEncrypted = function (event) {
            var element = event.target;
            var codecs = {};
            var contentProtections = null;
            if (element.mediaKeysObject === undefined) {
                element.mediaKeysObject = null;
                element.pendingSessionData = [];
                if (_this.stream != null && !_this.periodInfo) {
                    _this.periodInfo = _this.stream.getPeriodInfo();
                }
                var pmd = _this.periodInfo.getPrimaryMediaData('video');
                if (pmd !== null) {
                    codecs['video'] = pmd.getCodec();
                    contentProtections = pmd.getContentProtectionData();
                }
                pmd = _this.periodInfo.getPrimaryMediaData('audio');
                if (pmd !== null) {
                    codecs['audio'] = pmd.getCodec();
                    if (!contentProtections) {
                        contentProtections = pmd.getContentProtectionData();
                    }
                }
                _this.protectionModel.selectKeySystemRMKSA(codecs, contentProtections, event.initData, 0, 0, true);
            }
            else {
                //        return;
            }
            _this.protectionModel.addKeySession(element, event.initDataType, event.initData);
        };
        this.createMediaKeysFromMPD_MED = function (videoData, audioData) {
            var self = _this;
            var cpds;
            var codec;
            //var contentProtection = [];
            return;
            if (videoData !== null) {
                codec = videoData.getCodec();
                cpds = videoData.getContentProtectionData();
                if (cpds) {
                    for (var i = 0; i < cpds.length; i++) {
                        if (cpds[i].pssh) {
                            _this.needsKeyQue.push({
                                type: 'fromMPD',
                                initData: cpds[i].pssh,
                                codec: codec,
                                contentProtection: [cpds[i]],
                            });
                        }
                    }
                }
            }
            if (audioData !== null) {
                codec = audioData.getCodec();
                cpds = audioData.getContentProtectionData();
                if (cpds) {
                    for (var i = 0; i < cpds.length; i++) {
                        if (cpds[i].pssh) {
                            _this.needsKeyQue.push({
                                type: 'fromMPD',
                                initData: cpds[i].pssh,
                                codec: codec,
                                contentProtection: [cpds[i]],
                            });
                        }
                    }
                }
            }
            if (_this.needsKeyProcessing) {
                if (!_this.needsKeyProcessListener) {
                    _this.needsKeyProcessListener = _this.needsKeyHandlerMED.bind(self);
                    _this.eventBus.addEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
                }
            }
            else {
                _this.needsKeyHandlerMED.call(self, null);
            }
        };
        //        createMediaKeysFromMPD_EME01b = function(videoData,audioData) {
        this.createMediaKeysFromMPD_EME01b = function (videoData, audioData) {
            var self = _this;
            var cpds;
            //var contentProtection = [];
            if (videoData !== null) {
                cpds = videoData.getContentProtectionData();
                if (cpds) {
                    for (var i = 0; i < cpds.length; i++) {
                        if (cpds[i].pssh) {
                            _this.needsKeyQue.push({
                                type: 'fromMPD',
                                initData: cpds[i].pssh,
                                contentProtection: [cpds[i]],
                            });
                        }
                    }
                }
            }
            if (audioData !== null) {
                cpds = audioData.getContentProtectionData();
                if (cpds) {
                    for (var i = 0; i < cpds.length; i++) {
                        if (cpds[i].pssh) {
                            _this.needsKeyQue.push({
                                type: 'fromMPD',
                                initData: cpds[i].pssh,
                                contentProtection: [cpds[i]],
                            });
                        }
                    }
                }
            }
            if (_this.needsKeyProcessing) {
                if (!_this.needsKeyProcessListener) {
                    _this.needsKeyProcessListener = _this.needsKeyHandlerEME01b.bind(self);
                    _this.eventBus.addEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
                }
            }
            else {
                _this.needsKeyHandlerEME01b.call(self, null);
            }
        };
        //        createMediaKeysFromMPD_RMKS = function(videoData,audioData) {
        this.createMediaKeysFromMPD_RMKS = function (videoData, audioData) {
            var cpds, codecs = {}, contentProtection = [];
            if (videoData !== null) {
                codecs['video'] = videoData.getCodec();
                cpds = videoData.getContentProtectionData();
                if (cpds) {
                    for (var i = 0; i < cpds.length; i++) {
                        if (cpds[i].pssh) {
                            contentProtection.push(cpds[i]);
                        }
                    }
                }
            }
            if (audioData !== null) {
                codecs['audio'] = audioData.getCodec();
                cpds = audioData.getContentProtectionData();
                if (cpds) {
                    for (var i = 0; i < cpds.length; i++) {
                        if (cpds[i].pssh) {
                            contentProtection.push(cpds[i]);
                        }
                    }
                }
            }
            if (contentProtection.length > 0) {
                if (_this.element.mediaKeysObject === undefined) {
                    _this.element.mediaKeysObject = null;
                    _this.element.pendingContentProtectionData = [];
                    _this.element.pendingSessionData = [];
                    console.info(contentProtection);
                    _this.protectionModel.selectKeySystemRMKSA(codecs, contentProtection, null, 0, 0, false);
                }
                else {
                    //        return;
                }
                _this.protectionModel.addContentProtectionData(_this.element, contentProtection);
            }
        };
        this.onMediaSourceKeyAdded = function () {
            _this.logHandler.log_DRM('Key Added', 0);
            _this.NXDebug.log('DRM: Key added.');
            _this.stream.onKeyAdded();
        };
        this.onMediaSourceKeyError = function (event) {
            var session = event.target;
            var msg = 'DRM: MediaKeyError - sessionId: ' +
                session.sessionId +
                ' errorCode: ' +
                session.error.code +
                ' systemErrorCode: ' +
                session.error.systemCode +
                ' [';
            switch (session.error.code) {
                case 1:
                    msg +=
                        "MEDIA_KEYERR_UNKNOWN - An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
                    break;
                case 2:
                    msg +=
                        'MEDIA_KEYERR_CLIENT - The Key System could not be installed or updated.';
                    break;
                case 3:
                    msg +=
                        'MEDIA_KEYERR_SERVICE - The message passed into update indicated an error from the license service.';
                    break;
                case 4:
                    msg +=
                        'MEDIA_KEYERR_OUTPUT - There is no available output device with the required characteristics for the content protection system.';
                    break;
                case 5:
                    msg +=
                        'MEDIA_KEYERR_HARDWARECHANGE - A hardware configuration change caused a content protection error.';
                    break;
                case 6:
                    msg +=
                        'MEDIA_KEYERR_DOMAIN - An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.';
                    break;
            }
            msg += ']';
            _this.NXDebug.log(msg);
            _this.errHandler.mediaKeySessionError(_this.eventBus, msg);
        };
        this.onAddKeyProcessed = function (evt) {
            if (_this.needsKeyProcessingTimerId) {
                clearTimeout(_this.needsKeyProcessingTimerId);
                _this.needsKeyProcessingTimerId = null;
            }
            if (_this.needsKeyProcessing) {
                _this.needsKeyProcessing = false;
                _this.eventBus.dispatchEvent({
                    type: 'ON_ADDED_KEY_PROCESSED',
                    data: { kid: evt.data.kid, keysTypeString: evt.data.keysTypeString },
                });
            }
            _this.stream.onKeyAdded();
        };
        /* istanbul ignore next */
        this.needsKeyHandlerEME01b = function (evt) {
            var self = _this;
            var q;
            var ret;
            //var contentProtection = null;
            var curType = evt != null ? evt.data.keysTypeString : 'none';
            if (_this.needsKeyQue.length == 0) {
                _this.eventBus.removeEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
                _this.needsKeyProcessListener = null;
                return;
            }
            _this.stream.clearInitTimer();
            _this.logHandler.log('needsKeyQue.len:' + _this.needsKeyQue.length);
            while (_this.needsKeyQue.length > 0) {
                q = _this.needsKeyQue.shift();
                _this.logHandler.log_DRM('needkey( ' + q.type + ' )', 0);
                if (!q.contentProtection) {
                    _this.protectionModel.generateKeyRequest(q.initData, 'clearkey');
                }
                else {
                    ret = _this
                        .protectionModel.selectKeySystemEME01b(q.contentProtection, q.initData);
                    _this.kid = ret.kid;
                    if (curType != 'none' && curType != ret.keysTypeString) {
                        continue;
                    }
                }
                if (_this.updatedKIDs.indexOf(_this.kid) < 0) {
                    _this.logHandler.log('kid= ' + _this.kid, '#fff0f0');
                    _this.needsKeyProcessingTimerId = setTimeout(function () {
                        if (self.needsKeyProcessing) {
                            self.needsKeyProcessing = false;
                            self.eventBus.dispatchEvent({
                                type: 'ON_ADDED_KEY_PROCESSED',
                                data: { kid: self.kid, keysTypeString: 'none' },
                            });
                        }
                        self.needsKeyProcessingTimerId = null;
                    }, 1000);
                    if (_this.needsKeyQue.length > 0 && !_this.needsKeyProcessListener) {
                        _this.needsKeyProcessListener = _this.needsKeyHandlerEME01b.bind(self);
                        _this.eventBus.addEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
                    }
                    _this.initData.push(q.initData);
                    _this.needsKeyProcessing = true;
                    _this.protectionModel.generateKeyRequest(q.initData, _this.kid);
                    break;
                }
            }
        };
        this.onMediaSourceNeedsKeyEME01b = function (event) {
            var self = _this;
            var videoCodec = null;
            var contentProtection = null;
            if (_this.stream != null && !_this.periodInfo) {
                _this.periodInfo = _this.stream.getPeriodInfo();
            }
            var videoData = _this.periodInfo.getPrimaryMediaData('video');
            if (videoData !== null) {
                videoCodec = videoData.getCodec();
                contentProtection = videoData.getContentProtectionData();
                _this.logHandler.log(videoCodec, '#fff0f0');
            }
            _this.needsKeyQue.push({
                type: event.type,
                initData: event.initData,
                contentProtection: contentProtection,
            });
            if (_this.needsKeyProcessing) {
                _this.needsKeyProcessListener = _this.needsKeyHandlerEME01b.bind(_this); //this.needsKeyProcessListener = needsKeyHandlerEME01b.bind(this);
                _this.eventBus.addEventListener('ON_ADDED_KEY_PROCESSED', _this.needsKeyProcessListener);
            }
            else {
                _this.needsKeyHandlerEME01b.call(self, null);
            }
        };
        this.onMediaSourceKeyMessageEME01b = function (event) {
            var self = _this;
            var laURL = event.defaultURL;
            var keySystem = event.keySystem ||
                _this.protectionModel.getKeysTypeString(_this.kid);
            /*
            let keySystem: string =
              event.keySystem !== undefined
                ? event.keySystem
                : (this.protectionModel as ProtectionModelEME01b)!.getKeysTypeString(
                    this.kid!
                  );
            */
            var msg = null;
            var session = null;
            _this.logHandler.log_DRM('KeyRequest<br>&nbsp;&nbsp;defaultURL ==> ' +
                (event.defaultURL != null ? laURL : 'NONE'), 0);
            if (keySystem == 'com.microsoft.playready') {
                msg = String.fromCharCode.apply(String, event.message);
                if (!event.defaultURL) {
                    var parser = new DOMParser(), xmlDoc = parser.parseFromString(msg, 'application/xml');
                    if (xmlDoc.getElementsByTagName('LA_URL')[0]) {
                        laURL =
                            xmlDoc.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue;
                    }
                }
            }
            else if (keySystem == 'com.widevine.alpha') {
                msg = event.message;
                if (!event.defaultURL)
                    laURL = 'unknown';
            }
            session = event.sessionId;
            if (session in _this.sessionIds) {
                _this.logHandler.log('<< onMediaSourceKeyMessageEME01b 99 : sessionId=' + session, '#80ff80');
                if (_this.needsKeyProcessingTimerId) {
                    clearTimeout(_this.needsKeyProcessingTimerId);
                    _this.needsKeyProcessingTimerId = null;
                }
                if (_this.needsKeyProcessing) {
                    _this.needsKeyProcessing = false;
                    _this.eventBus.dispatchEvent({
                        type: 'ON_ADDED_KEY_PROCESSED',
                        data: { kid: _this.kid, keysTypeString: 'none' },
                    });
                }
                return;
            }
            else {
                _this.sessionIds[session] = session;
            }
            if (!laURL && keySystem == '') {
                keySystem = 'org.w3.clearkey';
            }
            var idata = _this.initData.shift();
            if (keySystem !== 'webkit-org.w3.clearkey' &&
                keySystem !== 'org.w3.clearkey') {
                _this.protectionModel.addKeyFromMessage(_this.kid, session, idata, msg, laURL, function (d) {
                    if (d.status == 'ok') {
                        self.updatedKIDs.push(self.kid);
                        self.eventBus.dispatchEvent({
                            type: 'addKeyProcessed',
                            data: { kid: self.kid, keysTypeString: keySystem },
                        });
                    }
                });
            }
            else {
                _this.protectionModel.addKeyFromMessageForClearKey(_this.kid, session, idata, msg, laURL);
                _this.updatedKIDs.push(_this.kid);
                _this.eventBus.dispatchEvent({
                    type: 'addKeyProcessed',
                    data: { kid: _this.kid, keysTypeString: keySystem },
                });
            }
            _this.logHandler.log('onMediaSourceKeyMessageEME01b 2', 0);
        };
        /* istanbul ignore next */
        this.onMediaSourceKeyAddedEME01b = function (event) {
            _this.logHandler.log_DRM('Key added sessionID:' + event.sessionId, 0);
        };
        this.onMediaSourceKeyErrorEME01b = function (_event) {
            //logHandler.log_DRM( "keyerror errorCode: " + event.errorCode , (-1)) ;
            if (_this.needsKeyProcessingTimerId) {
                clearTimeout(_this.needsKeyProcessingTimerId);
                _this.needsKeyProcessingTimerId = null;
            }
            if (_this.needsKeyProcessing) {
                _this.needsKeyProcessing = false;
                _this.eventBus.dispatchEvent({
                    type: 'ON_ADDED_KEY_PROCESSED',
                    data: { kid: 'none', keysTypeString: 'none' },
                });
            }
        };
        //
        // Support Functions
        //
        this.MediaKeys_prefix = function () {
            var hasWebKit = 'WebKitMediaKeys' in window;
            var hasMs = 'MSMediaKeys' in window;
            var hasMediaSource = 'MediaKeys' in window;
            var prefix = '----';
            if (hasWebKit) {
                prefix = 'webkit';
            }
            else if (hasMs) {
                prefix = 'ms';
            }
            else if (hasMediaSource) {
                prefix = 'standard';
            }
            _this.eme_prefix = prefix;
            return prefix;
        };
        this.EME01b_prefix = function (element) {
            var hasWebKit = typeof element.webkitGenerateKeyRequest ==
                'function';
            var hasMs = typeof element.msGenerateKeyRequest ==
                'function';
            var hasMediaSource = typeof element.generateKeyRequest == 'function';
            var prefix = '----';
            if (hasMediaSource) {
                prefix = 'standard';
            }
            else if (hasWebKit) {
                prefix = 'webkit';
            }
            else if (hasMs) {
                prefix = 'ms';
            }
            _this.eme_prefix = prefix;
            return prefix;
        };
        this.supportsRequestMediaKeySystemAccess = function () {
            var hasRMKS = 'requestMediaKeySystemAccess' in navigator;
            if (hasRMKS) {
                _this.logHandler.log_item('EME_ver', 'EME: ' +
                    '<span style="color:#808080">01b</span> <span style="color:#e7527d">requestMediaKeySystemAccess(' +
                    _this.MediaKeys_prefix() +
                    ')</span>');
            }
            return hasRMKS;
        };
        this.supportsMediaKeys = function () {
            var hasWebKit = 'WebKitMediaKeys' in window;
            var hasMs = 'MSMediaKeys' in window;
            var hasMediaSource = 'MediaKeys' in window;
            if (hasWebKit || hasMs || hasMediaSource) {
                _this.logHandler.log_item('EME_ver', 'EME: ' +
                    '<span style="color:#808080">01b</span> <span style="color:#e7527d">MediaKeys(' +
                    _this.MediaKeys_prefix() +
                    ')</span>');
            }
            return hasWebKit || hasMs || hasMediaSource;
        };
        this.supportsEME01b = function () {
            var hasWebKit = typeof _this.element
                .webkitGenerateKeyRequest == 'function';
            var hasMs = typeof _this.element.msGenerateKeyRequest ==
                'function';
            var hasMediaSource = typeof _this.element.generateKeyRequest ==
                'function';
            if (hasWebKit || hasMs || hasMediaSource) {
                _this.logHandler.log_item('EME_ver', 'EME: ' +
                    '<span style="color:#e7527d">01b( ' +
                    _this.EME01b_prefix(_this.element) +
                    ' )</span>' +
                    ' <span style="color:#808080">MediaKeys</span>');
            }
            return hasWebKit || hasMs || hasMediaSource;
        };
        this.createMediaKeysFromMPD = function (videoData, audioData) {
            if (_this.supportsRequestMediaKeySystemAccess()) {
                _this.createMediaKeysFromMPD_RMKS(videoData, audioData);
            }
            else if (_this.supportsMediaKeys()) {
                _this.createMediaKeysFromMPD_MED(videoData, audioData);
            }
            else if (_this.supportsEME01b()) {
                _this.createMediaKeysFromMPD_EME01b(videoData, audioData);
            }
            else {
            }
        };
        this.stream = null;
        this.videoModel = null;
        this.element = null;
        this.eme_prefix = null;
        this.periodInfo = null;
        this.protectionModel = null;
        this.initData = [];
        this.updatedKIDs = [];
        this.kid = null;
        this.sessionIds = {};
        this.needsKeyQue = [];
        this.eventTypeList = [];
        this.needsKeyProcessListener = null;
        this.needsKeyProcessing = false;
        this.needsKeyProcessingTimerId = null;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.sessionToKID = {};
        this.encryptedListener;
        this.needKeyListener;
        this.keyMessageListener;
        this.keyAddedListener;
        this.keyErrorListener;
        this.eventBus = eventBus;
        this.params = params;
        this.xhrCustom = xhrCustom;
    }
    ProtectionController.prototype.init = function (strm) {
        this.stream = strm;
        this.videoModel = strm.getVideoModel();
        this.element = this.videoModel.getElement();
        this.eventBus.addEventListener('addKeyProcessed', this.onAddKeyProcessed.bind(this));
        this.logHandler.log('EME' + this.videoModel, '#ff8080');
        if (this.supportsRequestMediaKeySystemAccess()) {
            this.protectionModel = new _ProtectionModelRMKSA__WEBPACK_IMPORTED_MODULE_5__.ProtectionModelRMKSA(this.params, this.eventBus);
            this.protectionModel.init(this.videoModel, this.stream, this.xhrCustom, '');
            this.encryptedListener = this.onMediaSourceEncrypted.bind(this);
            this.protectionModel.listenToEncrypted(this.encryptedListener);
        }
        else if (this.supportsMediaKeys() || this.supportsEME01b()) {
            if (this.supportsMediaKeys()) {
                this.logHandler.log('MediaKeys 1', '#ff8080');
                this.protectionModel = new _ProtectionModel__WEBPACK_IMPORTED_MODULE_3__.ProtectionModel(this.params, this.eventBus);
                this.protectionModel.init(this.videoModel, this.xhrCustom);
                this.needKeyListener = this.onMediaSourceNeedsKey.bind(this);
                this.keyMessageListener = this.onMediaSourceKeyMessage.bind(this);
                this.keyAddedListener = this.onMediaSourceKeyAdded.bind(this);
                this.keyErrorListener = this.onMediaSourceKeyError.bind(this);
            }
            else if (this.supportsEME01b()) {
                this.logHandler.log('01b 1', '#ff8080');
                this.protectionModel = new _ProtectionModelEME01b__WEBPACK_IMPORTED_MODULE_4__.ProtectionModelEME01b(this.params, this.eventBus);
                this.protectionModel.init(this.videoModel, this.xhrCustom, this.eme_prefix);
                this.needKeyListener = this.onMediaSourceNeedsKeyEME01b.bind(this);
                this.keyMessageListener = this.onMediaSourceKeyMessageEME01b.bind(this);
                this.keyAddedListener = this.onMediaSourceKeyAddedEME01b.bind(this);
                this.keyErrorListener = this.onMediaSourceKeyErrorEME01b.bind(this);
                this.logHandler.log('01b 4', '#ff8080');
            }
            this.protectionModel.listenToNeedKey(this.needKeyListener);
            this.protectionModel.listenToKeyMessage(this.keyMessageListener);
            this.protectionModel.listenToKeyAdded(this.keyAddedListener);
            this.protectionModel.listenToKeyError(this.keyErrorListener);
        }
    };
    ProtectionController.prototype.supportsProtection = function () {
        return (this.supportsMediaKeys.call(this) ||
            this.supportsEME01b.call(this) ||
            this.supportsRequestMediaKeySystemAccess.call(this));
    };
    ProtectionController.prototype.reset = function () {
        this.needsKeyProcessing = false;
        if (this.element) {
            this.element.mediaKeysObject = undefined;
        }
        if (this.needsKeyProcessingTimerId) {
            clearTimeout(this.needsKeyProcessingTimerId);
            this.needsKeyProcessingTimerId = null;
        }
        if (this.supportsRequestMediaKeySystemAccess()) {
            this.protectionModel.unlistenToEncrypted(this.encryptedListener);
            this.protectionModel.reset();
        }
        else if (this.supportsMediaKeys() || this.supportsEME01b()) {
            this.protectionModel.unlistenToNeedKey(this.needKeyListener);
            this.protectionModel.unlistenToKeyMessage(this.keyMessageListener);
            this.protectionModel.unlistenToKeyAdded(this.keyAddedListener);
            this.protectionModel.unlistenToKeyError(this.keyErrorListener);
        }
    };
    return ProtectionController;
}());



/***/ }),

/***/ "./ts/dash/protection/ProtectionExtensions.ts":
/*!****************************************************!*\
  !*** ./ts/dash/protection/ProtectionExtensions.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtectionExtensions": function() { return /* binding */ ProtectionExtensions; },
/* harmony export */   "stringToArray": function() { return /* binding */ stringToArray; }
/* harmony export */ });
/* harmony import */ var _core_Base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base64 */ "./ts/dash/core/Base64.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
// The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
//
// Copyright (c) 2013, Microsoft Open Technologies, Inc.
// Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
//
// All rights reserved.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * ProtectionExtensions
 *
 * @module ProtectionExtensions（ProtectionExtensionsモジュール）
 */
// const hexdump = (data: any): string => {
//   const tmp: Uint8Array = new Uint8Array(data);
//   let tmp_a: string = '';
//   tmp_a = tmp_a + data.length + '/';
//   for (let ii = 0; ii < data.length; ii++) {
//     if (tmp[ii] < 16) {
//       tmp_a = tmp_a + '0';
//     }
//     tmp_a = tmp_a + tmp[ii];
//   }
//   return tmp_a;
// };
var stringToArray = function (s) {
    var array = new Uint8Array(s.length);
    for (var i = 0; i < s.length; i++) {
        array[i] = s.charCodeAt(i);
    }
    return array;
};
var arrayToString = function (a) {
    // 以下修正案
    // for (let i = 0; i < a.byteLength; i++) {
    //   returnString += String.fromCharCode(a[i]);
    // }
    // @ts-ignore
    return String.fromCharCode.apply(String, a);
};
var extractClearKeyFromMessage = function (initData) {
    var abuf = initData.buffer;
    var dv = new DataView(abuf);
    var pos = 0;
    while (pos < abuf.byteLength) {
        var box_size = dv.getUint32(pos, false);
        var type = dv.getUint32(pos + 4, false);
        if (type != 0x70737368)
            throw 'Box type ' + type.toString(16) + ' not equal to "pssh"';
        if (dv.getUint32(pos + 12, false) == 0x9a04f079 &&
            dv.getUint32(pos + 16, false) == 0x98404286 &&
            dv.getUint32(pos + 20, false) == 0xab92e65b &&
            dv.getUint32(pos + 24, false) == 0xe0885f95) {
            return initData;
        }
        if (dv.getUint32(pos + 12, false) == 0x00000000 &&
            dv.getUint32(pos + 16, false) == 0x00000000 &&
            dv.getUint32(pos + 20, false) == 0x00000000 &&
            dv.getUint32(pos + 24, false) == 0x00000001) {
            var size = dv.getUint32(pos + 28, false);
            return new Uint8Array(abuf.slice(pos + 32 + 3, pos + 32 + size));
        }
        if (dv.getUint32(pos + 12, false) == 0xedef8ba9 &&
            dv.getUint32(pos + 16, false) == 0x79d64ace &&
            dv.getUint32(pos + 20, false) == 0xa3c827dc &&
            dv.getUint32(pos + 24, false) == 0xd51d21ed) {
            return new Uint8Array(abuf.slice(pos + 36, pos + 52));
        }
        pos += box_size;
    }
    return initData;
};
//NSV-a function abortWrapper(f, c) {
//NSV-a   return new Promise((resolve, reject) => {
//NSV-a     setTimeout(() => {
//NSV-a       c.aborted = true;
//NSV-a       reject(new Error('abort'));
//NSV-a     }, 1000);
//NSV-a     f.then(resolve, reject);
//NSV-a   });
//NSV-a }
/**
 * ProtectionExtensions
 * @constructor
 */
var ProtectionExtensions = /** @class */ (function () {
    // authtoken: any;
    function ProtectionExtensions(params, _eventBus) {
        var _this = this;
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.init = function (elmnt, prefix) {
            _this.element = elmnt;
            _this.EME01b_prefix = prefix;
        };
        this.supportsCodec = function (mediaKeysString, codec) {
            var hasWebKit = 'WebKitMediaKeys' in window;
            var hasMs = 'MSMediaKeys' in window;
            var hasMediaSource = 'MediaKeys' in window;
            if (hasMediaSource) {
                // @ts-ignore
                return MediaKeys.isTypeSupported(mediaKeysString, codec);
            }
            else if (hasWebKit) {
                // @ts-ignore
                return WebKitMediaKeys.isTypeSupported(mediaKeysString, codec);
            }
            else if (hasMs) {
                // @ts-ignore
                return MSMediaKeys.isTypeSupported(mediaKeysString, codec);
            }
            return false;
        };
        this.createMediaKeys = function (mediaKeysString) {
            var hasWebKit = 'WebKitMediaKeys' in window;
            var hasMs = 'MSMediaKeys' in window;
            var hasMediaSource = 'MediaKeys' in window;
            if (hasMediaSource) {
                _this.logHandler.log_DRM('new MediaKeys( ' + mediaKeysString + ' )', 99);
                // @ts-ignore
                return new MediaKeys(mediaKeysString);
            }
            else if (hasWebKit) {
                _this.logHandler.log_DRM('new WebKitMediaKeys( ' + mediaKeysString + ' )', 99);
                // @ts-ignore
                return new WebKitMediaKeys(mediaKeysString);
            }
            else if (hasMs) {
                _this.logHandler.log_DRM('new MSMediaKeys( ' + mediaKeysString + ' )', 99);
                // @ts-ignore
                return new MSMediaKeys(mediaKeysString);
            }
            return null;
        };
        this.setMediaKey = function (element, mediaKeys) {
            var hasWebKit = 'WebKitSetMediaKeys' in element;
            var hasMs = 'msSetMediaKeys' in element;
            var hasStd = 'setMediaKeys' in element;
            if (hasStd) {
                return element.setMediaKeys(mediaKeys);
            }
            else if (hasWebKit) {
                return element.WebKitSetMediaKeys(mediaKeys);
            }
            else if (hasMs) {
                // @ts-ignore
                return element.msSetMediaKeys(mediaKeys);
            }
            else {
                _this.NXDebug.log('no setmediakeys function in element');
            }
        };
        this.createSession = function (mediaKeys, //mediaKeys: MSMediaKeys,
        mediaCodec, initData) {
            var sess; //let sess: ExMSMediaKeySession;
            try {
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('createSession()<br>&nbsp;&nbsp;codec ==> ' + mediaCodec, 1);
                // @ts-ignore
                sess = mediaKeys.createSession(mediaCodec, initData);
            }
            catch (e) {
                _this.logHandler.log_DRM('Error: createSession ' + String(e));
            }
            return sess;
        };
        /* istanbul ignore next */
        this.getKeySystems = function () {
            var playreadyGetUpdate = function (bytes, laURL, xhrCustom, callback) {
                var decodedChallenge = null;
                var headers = [];
                var parser = new DOMParser();
                // @ts-ignore
                var msg = String.fromCharCode.apply(null, bytes);
                var xmlDoc = parser.parseFromString(msg, 'application/xml');
                //this.logHandler.log('getKeySystems: msg: ' + msg);
                var qrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'query')
                    ? xhrCustom['query'].concat()
                    : [];
                var hdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'header')
                    ? xhrCustom['header'].concat()
                    : [];
                var onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onPrepare')
                    ? xhrCustom['onPrepare']
                    : function () { };
                var onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onSuccess')
                    ? xhrCustom['onSuccess']
                    : function () { };
                var onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onError')
                    ? xhrCustom['onError']
                    : function () { };
                if (xmlDoc.getElementsByTagName('PlayReadyKeyMessage')[0]) {
                    if (xmlDoc.getElementsByTagName('Challenge')[0]) {
                        var Challenge = xmlDoc.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue;
                        if (Challenge) {
                            decodedChallenge = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decode(Challenge);
                        }
                    }
                    else {
                        callback({
                            status: 'error',
                            msg: 'DRM: playready update, can not find Challenge in keyMessage',
                        });
                        return;
                    }
                }
                else {
                    decodedChallenge = msg;
                }
                var headerNameList = xmlDoc.getElementsByTagName('name');
                var headerValueList = xmlDoc.getElementsByTagName('value');
                if (headerNameList.length != headerValueList.length) {
                    callback({
                        status: 'error',
                        msg: 'DRM: playready update, invalid header name/value pair in keyMessage',
                    });
                    return;
                }
                for (var i = 0; i < headerNameList.length; i++) {
                    headers[i] = {
                        name: headerNameList[i].childNodes[0].nodeValue,
                        value: headerValueList[i].childNodes[0].nodeValue,
                    };
                }
                if (!_this.useFetch) {
                    var xhr_1 = new XMLHttpRequest();
                    xhr_1.keysTypeString = 'com.microsoft.playready';
                    xhr_1.url = laURL;
                    onPrepare({
                        req: xhr_1,
                        qrys: qrys,
                        hdrs: hdrs,
                        xhr: xhr_1,
                    });
                    if (qrys.length > 0) {
                        qrys.forEach(function (qry) {
                            xhr_1.url += xhr_1.url.indexOf('?') > 0 ? '&' : '?';
                            xhr_1.url += qry.name + '=' + qry.value;
                        });
                    }
                    laURL = xhr_1.url;
                    if (hdrs.length > 0) {
                        hdrs.forEach(function (hdr) {
                            headers.push({
                                name: hdr.name,
                                value: hdr.value,
                            });
                        });
                    }
                    xhr_1.onload = function () {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('License( xhr.status == ' + xhr_1.status + ' )', 3);
                        if (xhr_1.status == 200) {
                            onSuccess({
                                status: xhr_1.status,
                                req: xhr_1,
                                xhr: xhr_1,
                            });
                            callback({
                                status: 'ok',
                                data: new Uint8Array(xhr_1.response),
                            });
                        }
                        else {
                            onError({
                                status: xhr_1.status,
                                req: xhr_1,
                                xhr: xhr_1,
                            });
                            callback({
                                status: 'error',
                                msg: 'DRM: playready update, XHR status is "' +
                                    xhr_1.statusText +
                                    '" (' +
                                    xhr_1.status +
                                    '), expected to be 200. readyState is ' +
                                    xhr_1.readyState,
                            });
                        }
                    };
                    xhr_1.onabort = function () {
                        onError({
                            status: xhr_1.status,
                            req: xhr_1,
                            xhr: xhr_1,
                        });
                        callback({
                            status: 'error',
                            msg: 'DRM: playready update, XHR aborted. status is "' +
                                xhr_1.statusText +
                                '" (' +
                                xhr_1.status +
                                '), readyState is ' +
                                xhr_1.readyState,
                        });
                    };
                    xhr_1.onerror = function () {
                        onError({
                            status: xhr_1.status,
                            req: xhr_1,
                            xhr: xhr_1,
                        });
                        callback({
                            status: 'error',
                            msg: 'DRM: playready update, XHR error. status is "' +
                                xhr_1.statusText +
                                '" (' +
                                xhr_1.status +
                                '), readyState is ' +
                                xhr_1.readyState,
                        });
                    };
                    xhr_1.open('POST', xhr_1.url);
                    xhr_1.responseType = 'arraybuffer';
                    headers.push({
                        name: 'Content-Type',
                        value: 'text/xml; charset=utf-8',
                    });
                    if (headers) {
                        headers.forEach(function (hdr) {
                            xhr_1.setRequestHeader(hdr.name, hdr.value);
                        });
                    }
                    xhr_1.send(decodedChallenge);
                }
                else {
                    var request_1 = {};
                    var acon_1 = {
                        aborted: false,
                    };
                    var init_1 = {
                        method: 'POST',
                        headers: {},
                        credentials: 'same-origin',
                    };
                    request_1.url = laURL;
                    onPrepare({
                        req: request_1,
                        qrys: qrys,
                        hdrs: hdrs,
                        xhr: request_1,
                    });
                    if (qrys.length > 0) {
                        qrys.forEach(function (qry) {
                            request_1.url += request_1.url.indexOf('?') > 0 ? '&' : '?';
                            request_1.url += qry.name + '=' + qry.value;
                        });
                    }
                    laURL = request_1.url;
                    if (hdrs.length > 0) {
                        hdrs.forEach(function (hdr) {
                            headers.push({
                                name: hdr.name,
                                value: hdr.value,
                            });
                        });
                    }
                    headers.push({
                        name: 'Content-Type',
                        value: 'text/xml; charset=utf-8',
                    });
                    if (headers) {
                        headers.forEach(function (hdr) {
                            init_1.headers[hdr.name] = hdr.value;
                        });
                    }
                    init_1.body = decodedChallenge;
                    fetch(request_1.url, init_1)
                        .then(function (res) {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('License( res.status == ' + res.status + ' )', 3);
                        request_1.status = res.status;
                        if (res.ok == true) {
                            return res.arrayBuffer();
                        }
                        else {
                            return Promise.reject(new Error('res.false'));
                        }
                    })
                        .then(function (ab) {
                        onSuccess({
                            status: request_1.status,
                            req: request_1,
                            xhr: request_1,
                        });
                        callback({
                            status: 'ok',
                            data: new Uint8Array(ab),
                        });
                    })
                        .catch(function (_err) {
                        if (acon_1.abort) {
                            request_1.status = -1;
                        }
                        onError({
                            status: request_1.status,
                            req: request_1,
                            xhr: request_1,
                        });
                        if (request_1.status > 0) {
                            callback({
                                status: 'error',
                                msg: 'DRM: playready update, XHR status code is' + request_1.status,
                            });
                        }
                        else if (request_1.status == -1) {
                            callback({
                                status: 'error',
                                msg: 'DRM: License Request is aborted.',
                            });
                        }
                        else {
                            callback({
                                status: 'error',
                                msg: 'DRM: playready update, XHR error.',
                            });
                        }
                    });
                }
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('Get License()<br>&nbsp;&nbsp;laURL ==> ' + laURL, 2);
            };
            var widevineGetUpdate = function (bytes, laURL, xhrCustom, _callback) {
                var callback = _callback || function () { }, self = _this, headers = [], 
                //utils = new DashTVPlayer.Utils(),
                qrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'query')
                    ? xhrCustom['query'].concat()
                    : [], hdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'header')
                    ? xhrCustom['header'].concat()
                    : [], onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onPrepare')
                    ? xhrCustom['onPrepare']
                    : function () { }, onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onSuccess')
                    ? xhrCustom['onSuccess']
                    : function () { }, onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onError')
                    ? xhrCustom['onError']
                    : function () { };
                var xhr = new XMLHttpRequest();
                xhr.keysTypeString = 'com.widevine.alpha';
                xhr.url = laURL;
                onPrepare({
                    req: xhr,
                    qrys: qrys,
                    hdrs: hdrs,
                    xhr: xhr,
                });
                if (qrys.length > 0) {
                    qrys.forEach(function (qry) {
                        xhr.url += xhr.url.indexOf('?') > 0 ? '&' : '?';
                        xhr.url += qry.name + '=' + qry.value;
                    });
                }
                laURL = xhr.url;
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        headers.push({
                            name: hdr.name,
                            value: hdr.value,
                        });
                    });
                }
                xhr.onload = function () {
                    self.logHandler.log_DRM('License( xhr.status == ' + xhr.status + ' )', 3);
                    if (xhr.status == 200) {
                        onSuccess({
                            status: xhr.status,
                            req: xhr,
                            xhr: xhr,
                        });
                        callback({
                            status: 'ok',
                            data: new Uint8Array(xhr.response),
                        });
                    }
                    else {
                        onError({
                            status: xhr.status,
                            req: xhr,
                            xhr: xhr,
                        });
                        callback({
                            status: 'error',
                            msg: 'DRM: widevine update, XHR status is "' +
                                xhr.statusText +
                                '" (' +
                                xhr.status +
                                '), expected to be 200. readyState is ' +
                                xhr.readyState,
                        });
                    }
                };
                xhr.onabort = function () {
                    onError({
                        status: xhr.status,
                        req: xhr,
                        xhr: xhr,
                    });
                    callback({
                        status: 'error',
                        msg: 'DRM: widevine update, XHR aborted. status is "' +
                            xhr.statusText +
                            '" (' +
                            xhr.status +
                            '), readyState is ' +
                            xhr.readyState,
                    });
                };
                xhr.onerror = function () {
                    onError({
                        status: xhr.status,
                        req: xhr,
                        xhr: xhr,
                    });
                    callback({
                        status: 'error',
                        msg: 'DRM: widevine update, XHR error. status is "' +
                            xhr.statusText +
                            '" (' +
                            xhr.status +
                            '), readyState is ' +
                            xhr.readyState,
                    });
                };
                xhr.open('POST', xhr.url);
                xhr.responseType = 'arraybuffer';
                if (headers) {
                    headers.forEach(function (hdr) {
                        xhr.setRequestHeader(hdr.name, hdr.value);
                    });
                }
                xhr.send(bytes);
                _this.logHandler.log_DRM('Get License()<br>&nbsp;&nbsp;laURL ==> ' + laURL, 2);
            };
            var playreadyGetKeyEME01b = function (msg, laURL, xhrCustom, callback) {
                var headers = [];
                var qrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'query')
                    ? xhrCustom['query'].concat()
                    : [];
                var hdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'header')
                    ? xhrCustom['header'].concat()
                    : [];
                var onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onPrepare')
                    ? xhrCustom['onPrepare']
                    : function () { };
                var onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onSuccess')
                    ? xhrCustom['onSuccess']
                    : function () { };
                var onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onError')
                    ? xhrCustom['onError']
                    : function () { };
                if (!_this.useFetch) {
                    var xhr_2 = new XMLHttpRequest();
                    xhr_2.keysTypeString = 'com.microsoft.playready';
                    xhr_2.onload = function () {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('Key( xhr.status == ' + xhr_2.status + ' )', 3);
                        if (xhr_2.status == 200) {
                            onSuccess({
                                status: xhr_2.status,
                                req: xhr_2,
                                xhr: xhr_2,
                            });
                            callback({
                                status: 'ok',
                                data: new Uint8Array(xhr_2.response),
                            });
                        }
                        else {
                            onError({
                                status: xhr_2.status,
                                req: xhr_2,
                                xhr: xhr_2,
                            });
                            callback({
                                status: 'error',
                                msg: 'DRM: playready update, XHR status is "' +
                                    xhr_2.statusText +
                                    '" (' +
                                    xhr_2.status +
                                    '), expected to be 200. readyState is ' +
                                    xhr_2.readyState,
                            });
                        }
                    };
                    xhr_2.onabort = function () {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('playreadyGetKeyEME01b: xhr.onabort' + xhr_2.status, -1);
                        onError({
                            status: xhr_2.status,
                            req: xhr_2,
                            xhr: xhr_2,
                        });
                        callback({
                            status: 'error',
                            msg: 'DRM: playready update, XHR aborted. status is "' +
                                xhr_2.statusText +
                                '" (' +
                                xhr_2.status +
                                '), readyState is ' +
                                xhr_2.readyState,
                        });
                    };
                    xhr_2.onerror = function () {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('playreadyGetKeyEME01b: xhr.onerror == ' + xhr_2.status, -1);
                        onError({
                            status: xhr_2.status,
                            req: xhr_2,
                            xhr: xhr_2,
                        });
                        callback({
                            status: 'error',
                            msg: 'DRM: playready update, XHR error. status is "' +
                                xhr_2.statusText +
                                '" (' +
                                xhr_2.status +
                                '), readyState is ' +
                                xhr_2.readyState,
                        });
                    };
                    xhr_2.url = laURL;
                    onPrepare({
                        req: xhr_2,
                        qrys: qrys,
                        hdrs: hdrs,
                        xhr: xhr_2,
                    });
                    if (qrys.length > 0) {
                        qrys.forEach(function (qry) {
                            xhr_2.url += xhr_2.url.indexOf('?') > 0 ? '&' : '?';
                            xhr_2.url += qry.name + '=' + qry.value;
                        });
                    }
                    laURL = xhr_2.url;
                    headers.push({
                        name: 'Content-Type',
                        value: 'text/xml; charset=utf-8',
                    });
                    if (hdrs.length > 0) {
                        hdrs.forEach(function (hdr) {
                            headers.push({
                                name: hdr.name,
                                value: hdr.value,
                            });
                        });
                    }
                    xhr_2.open('POST', xhr_2.url);
                    xhr_2.responseType = 'arraybuffer';
                    if (headers) {
                        headers.forEach(function (hdr) {
                            xhr_2.setRequestHeader(hdr.name, hdr.value);
                        });
                    }
                    xhr_2.send(msg);
                }
                else {
                    var request_2 = {};
                    var acon_2 = {
                        aborted: false,
                    };
                    var init_2 = {
                        method: 'POST',
                        headers: {},
                        credentials: 'same-origin',
                    };
                    request_2.url = laURL;
                    onPrepare({
                        req: request_2,
                        qrys: qrys,
                        hdrs: hdrs,
                        xhr: request_2,
                    });
                    if (qrys.length > 0) {
                        qrys.forEach(function (qry) {
                            request_2.url += request_2.url.indexOf('?') > 0 ? '&' : '?';
                            request_2.url += qry.name + '=' + qry.value;
                        });
                    }
                    laURL = request_2.url;
                    headers.push({
                        name: 'Content-Type',
                        value: 'text/xml; charset=utf-8',
                    });
                    if (hdrs.length > 0) {
                        hdrs.forEach(function (hdr) {
                            headers.push({
                                name: hdr.name,
                                value: hdr.value,
                            });
                        });
                    }
                    if (headers) {
                        headers.forEach(function (hdr) {
                            init_2.headers[hdr.name] = hdr.value;
                        });
                    }
                    init_2.body = msg;
                    fetch(request_2.url, init_2)
                        .then(function (res) {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('License( res.status == ' + res.status + ' )', 3);
                        request_2.status = res.status;
                        if (res.ok == true) {
                            return res.arrayBuffer();
                        }
                        else {
                            return Promise.reject(new Error('res.false'));
                        }
                    })
                        .then(function (ab) {
                        onSuccess({
                            status: request_2.status,
                            req: request_2,
                            xhr: request_2,
                        });
                        callback({
                            status: 'ok',
                            data: new Uint8Array(ab),
                        });
                    })
                        .then(function (_err) {
                        if (acon_2.abort) {
                            request_2.status = -1;
                        }
                        onError({
                            status: request_2.status,
                            req: request_2,
                            xhr: request_2,
                        });
                        if (request_2.status > 0) {
                            callback({
                                status: 'error',
                                msg: 'DRM: playready update, XHR status code is' + request_2.status,
                            });
                        }
                        else if (request_2.status == -1) {
                            callback({
                                status: 'error',
                                msg: 'DRM: License Request is aborted.',
                            });
                        }
                        else {
                            callback({
                                status: 'error',
                                msg: 'DRM: playready update, XHR error.',
                            });
                        }
                    });
                }
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('GetKey<br>&nbsp;&nbsp;laURL ==> ' + laURL, 2);
            };
            var widevineGetKeyEME01b = function (msg, laURL, xhrCustom, callback) {
                var self = _this;
                //var callback = _callback || function () {},
                var headers = [], 
                //utils = new DashTVPlayer.Utils(),
                qrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'query')
                    ? xhrCustom['query'].concat()
                    : [], hdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'header')
                    ? xhrCustom['header'].concat()
                    : [], onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onPrepare')
                    ? xhrCustom['onPrepare']
                    : function () { }, onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onSuccess')
                    ? xhrCustom['onSuccess']
                    : function () { }, onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_3__.hasProperty)(xhrCustom, 'onError')
                    ? xhrCustom['onError']
                    : function () { };
                var xhr = new XMLHttpRequest();
                xhr.keysTypeString = 'com.widevine.alpha';
                xhr.onload = function () {
                    self.logHandler.log_DRM('Key( xhr.status == ' + xhr.status + ' )', 3);
                    if (xhr.status == 200) {
                        onSuccess({
                            status: xhr.status,
                            req: xhr,
                            xhr: xhr,
                        });
                        callback({
                            status: 'ok',
                            data: new Uint8Array(xhr.response),
                        });
                    }
                    else {
                        onError({
                            status: xhr.status,
                            req: xhr,
                            xhr: xhr,
                        });
                        callback({
                            status: 'error',
                            msg: 'DRM: widevine update, XHR status is "' +
                                xhr.statusText +
                                '" (' +
                                xhr.status +
                                '), expected to be 200. readyState is ' +
                                xhr.readyState,
                        });
                    }
                };
                xhr.onabort = function () {
                    self.logHandler.log_DRM('widevineGetKeyEME01b: xhr.onabort' + xhr.status, -1);
                    onError({
                        status: xhr.status,
                        req: xhr,
                        xhr: xhr,
                    });
                    callback({
                        status: 'error',
                        msg: 'DRM: widevine update, XHR aborted. status is "' +
                            xhr.statusText +
                            '" (' +
                            xhr.status +
                            '), readyState is ' +
                            xhr.readyState,
                    });
                };
                xhr.onerror = function () {
                    self.logHandler.log_DRM('widevineGetKeyEME01b: xhr.onerror == ' + xhr.status, -1);
                    onError({
                        status: xhr.status,
                        req: xhr,
                        xhr: xhr,
                    });
                    callback({
                        status: 'error',
                        msg: 'DRM: widevine update, XHR error. status is "' +
                            xhr.statusText +
                            '" (' +
                            xhr.status +
                            '), readyState is ' +
                            xhr.readyState,
                    });
                };
                xhr.url = laURL;
                onPrepare({
                    req: xhr,
                    qrys: qrys,
                    hdrs: hdrs,
                    xhr: xhr,
                });
                if (qrys.length > 0) {
                    qrys.forEach(function (qry) {
                        xhr.url += xhr.url.indexOf('?') > 0 ? '&' : '?';
                        xhr.url += qry.name + '=' + qry.value;
                    });
                }
                laURL = xhr.url;
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        headers.push({
                            name: hdr.name,
                            value: hdr.value,
                        });
                    });
                }
                xhr.open('POST', xhr.url);
                xhr.responseType = 'arraybuffer';
                if (headers) {
                    headers.forEach(function (hdr) {
                        xhr.setRequestHeader(hdr.name, hdr.value);
                    });
                }
                xhr.send(msg);
                _this.logHandler.log_DRM('GetKey<br>&nbsp;&nbsp;laURL ==> ' + laURL, 2);
            };
            var playReadyNeedToAddKeySession = function (_initData, _keySessions) {
                //return initData === null && keySessions.length === 0;
                return true;
            };
            var playreadyGetInitData = function (data) {
                // * desc@ getInitData
                // *   generate PSSH data from PROHeader defined in MPD file
                // *   PSSH format:
                // *   size (4)
                // *   box type(PSSH) (8)
                // *   Protection SystemID (16)
                // *   protection system data size (4) - length of decoded PROHeader
                // *   decoded PROHeader data from MPD file
                var byteCursor = 0;
                var PROSize = 0;
                var PSSHSize = 0;
                //'PSSH' 8 bytes
                var PSSHBoxType = new Uint8Array([
                    0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00,
                ]);
                var playreadySystemID = new Uint8Array([
                    0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b,
                    0xe0, 0x88, 0x5f, 0x95,
                ]);
                var uint8arraydecodedPROHeader = null;
                var PSSHBoxBuffer = null;
                var PSSHBox = null;
                var PSSHData = null;
                if ('pro' in data) {
                    uint8arraydecodedPROHeader = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(data.pro.__text);
                }
                else if ('prheader' in data) {
                    uint8arraydecodedPROHeader = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(data.prheader.__text);
                }
                else {
                    return null;
                }
                PROSize = uint8arraydecodedPROHeader.length;
                PSSHSize =
                    0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize;
                PSSHBoxBuffer = new ArrayBuffer(PSSHSize);
                PSSHBox = new Uint8Array(PSSHBoxBuffer);
                PSSHData = new DataView(PSSHBoxBuffer);
                PSSHData.setUint32(byteCursor, PSSHSize);
                byteCursor += 0x4;
                PSSHBox.set(PSSHBoxType, byteCursor);
                byteCursor += PSSHBoxType.length;
                PSSHBox.set(playreadySystemID, byteCursor);
                byteCursor += playreadySystemID.length;
                PSSHData.setUint32(byteCursor, PROSize);
                byteCursor += 0x4;
                PSSHBox.set(uint8arraydecodedPROHeader, byteCursor);
                byteCursor += PROSize;
                return PSSHBox;
            };
            //
            // order by priority. if an mpd contains more than one the first match will win.
            // Entries with the same schemeIdUri can appear multiple times with different keysTypeStrings.
            //
            return [
                {
                    schemeIdUri: 'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',
                    keysTypeString: 'com.microsoft.playready',
                    isSupported: function (data) {
                        return this.schemeIdUri === data.schemeIdUri.toLowerCase();
                    },
                    needToAddKeySession: playReadyNeedToAddKeySession,
                    getInitData: playreadyGetInitData,
                    getUpdate: playreadyGetUpdate,
                    getKeyEME01b: playreadyGetKeyEME01b, //EME01b
                },
                {
                    schemeIdUri: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',
                    keysTypeString: 'com.widevine.alpha',
                    isSupported: function (data) {
                        return this.schemeIdUri === data.schemeIdUri.toLowerCase();
                    },
                    needToAddKeySession: playReadyNeedToAddKeySession,
                    getInitData: playreadyGetInitData,
                    getUpdate: widevineGetUpdate,
                    getKeyEME01b: widevineGetKeyEME01b, //EME01b
                },
                {
                    schemeIdUri: 'urn:mpeg:dash:mp4protection:2011',
                    keysTypeString: 'com.microsoft.playready',
                    isSupported: function (data) {
                        return (this.schemeIdUri === data.schemeIdUri.toLowerCase() &&
                            data.value.toLowerCase() === 'cenc');
                    },
                    needToAddKeySession: playReadyNeedToAddKeySession,
                    getInitData: function () {
                        // the cenc element in mpd does not contain initdata
                        return null;
                    },
                    getUpdate: playreadyGetUpdate,
                    getKeyEME01b: playreadyGetKeyEME01b, //EME01b
                },
                {
                    schemeIdUri: 'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b',
                    keysTypeString: 'webkit-org.w3.clearkey',
                    isSupported: function (data) {
                        return this.schemeIdUri === data.schemeIdUri.toLowerCase();
                    },
                    needToAddKeySession: function () {
                        return true;
                    },
                    getInitData: function () {
                        return null;
                    },
                    getUpdate: function (bytes /*, laURL*/) {
                        return bytes;
                    },
                    getKeyEME01b: function () {
                        //EME01b
                        return null;
                    },
                },
            ];
        };
        this.generateKeyRequest = function (element, data, keysystem) {
            if (keysystem != null) {
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('generateKeyRequest (' + keysystem.keySystem.keysTypeString + ')', 1);
            }
            var keysTypeString;
            if (keysystem == null) {
                keysTypeString = 'webkit-org.w3.clearkey';
            }
            else {
                keysTypeString = keysystem.keySystem.keysTypeString;
            }
            var self = _this;
            var s_data = data;
            if (!data || !element) {
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('generateKeyRequest Called 1 data false', '#c0c0ff');
            }
            try {
                if (typeof element
                    .webkitGenerateKeyRequest == 'function' &&
                    keysTypeString != null &&
                    data != null) {
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('webkitGenerateKeyRequest()', 1);
                    element.webkitGenerateKeyRequest(keysTypeString, s_data);
                    self.initDataQueue.push(s_data);
                }
                else if (typeof element.generateKeyRequest == 'function') {
                    if (keysTypeString !== 'webkit-org.w3.clearkey') {
                        element.generateKeyRequest(keysTypeString, s_data);
                    }
                    else {
                        element.generateKeyRequest('org.w3.clearkey', s_data);
                    }
                    self.initDataQueue.push(s_data);
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('generateKeyRequest()', 1);
                }
                else if (typeof element.msGenerateKeyRequest ==
                    'function') {
                    if (keysTypeString !== 'webkit-org.w3.clearkey') {
                        element.msGenerateKeyRequest(keysTypeString, s_data);
                    }
                    else {
                        element.msGenerateKeyRequest('org.w3.clearkey', s_data);
                    }
                    self.initDataQueue.push(data);
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('msGenerateKeyRequest()', 1);
                }
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('KeyInfo ==> ' + keysTypeString, 99);
            }
            catch (e) {
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('generateKeyRequest Error ' + e, -1);
            }
        };
        this.addKey = function (p_license, p_initData, p_session, keysTypeString) {
            if (typeof _this.element.webkitAddKey ==
                'function') {
                _this.element.webkitAddKey(keysTypeString, p_license, p_initData, p_session);
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('webkitAddKey sessionID:' + p_session, 1);
            }
            else if (typeof _this.element.msaddKey == 'function') {
                _this.element.msaddKey(keysTypeString, p_license, p_initData, p_session);
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('msaddKey sessionID:' + p_session, 1);
            }
            else if (typeof _this.element.addKey == 'function') {
                _this.element.addKey('com.youtube.playready', p_license, p_initData, p_session); //Temporary
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('addKey sessionID:' + p_session + ' keystr: ' + keysTypeString, 1);
            }
        };
        this.extractClearKeyKIDFromPSSHBox = function (msg) {
            var idata = extractClearKeyFromMessage(msg);
            var jwk = JSON.parse(_core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decode(arrayToString(idata)));
            var kidString = jwk['keys'][0]['kid'];
            var padlen = 4 - (kidString.length % 4);
            for (var i = 0; i < padlen; i++) {
                kidString += '=';
            }
            var kidArray = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(kidString);
            var kid = ('0' + kidArray[0].toString(16)).slice(-2) +
                ('0' + kidArray[1].toString(16)).slice(-2) +
                ('0' + kidArray[2].toString(16)).slice(-2) +
                ('0' + kidArray[3].toString(16)).slice(-2) +
                '-' +
                ('0' + kidArray[4].toString(16)).slice(-2) +
                ('0' + kidArray[5].toString(16)).slice(-2) +
                '-' +
                ('0' + kidArray[6].toString(16)).slice(-2) +
                ('0' + kidArray[7].toString(16)).slice(-2) +
                '-' +
                ('0' + kidArray[8].toString(16)).slice(-2) +
                ('0' + kidArray[9].toString(16)).slice(-2) +
                '-' +
                ('0' + kidArray[10].toString(16)).slice(-2) +
                ('0' + kidArray[11].toString(16)).slice(-2) +
                ('0' + kidArray[12].toString(16)).slice(-2) +
                ('0' + kidArray[13].toString(16)).slice(-2) +
                ('0' + kidArray[14].toString(16)).slice(-2) +
                ('0' + kidArray[15].toString(16)).slice(-2);
            return kid;
        };
        this.eventBus = _eventBus;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.useFetch = false;
        this.initDataQueue = [];
        this.element = null;
        this.EME01b_prefix = null;
    }
    ProtectionExtensions.prototype.extractClearKeyFromMessageForRMKSA = function (msg) {
        var self = this;
        try {
            var idata = extractClearKeyFromMessage(msg);
            var jwk = JSON.parse(_core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decode(arrayToString(idata)));
            return jwk;
        }
        catch (e) {
            self.NXDebug.debug(e);
            return;
        }
    };
    ProtectionExtensions.prototype.addKeyForClearKey = function (_kid, session, msg) {
        var self = this;
        var idata;
        var kidString;
        var keyString;
        try {
            idata = extractClearKeyFromMessage(msg);
            var jwk = JSON.parse(_core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decode(arrayToString(idata)));
            kidString = jwk['keys'][0]['kid'];
            keyString = jwk['keys'][0]['k'];
            var padlen = 4 - (kidString.length % 4);
            for (var i = 0; i < padlen; i++) {
                kidString += '=';
            }
            var kid = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(kidString);
            padlen = 4 - (keyString.length % 4);
            for (var i = 0; i < padlen; i++) {
                keyString += '=';
            }
            var key = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(keyString);
        }
        catch (e) {
            self.NXDebug.debug(e);
            return;
        }
        this.logHandler.log(_core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decode(arrayToString(idata)));
        this.logHandler.log('kid:' + kidString + ', key:' + keyString);
        if (typeof self.element.webkitAddKey ==
            'function') {
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('>> CK webkitAddKey sessionID:' + session, '#40ff40');
            self.element.webkitAddKey('webkit-org.w3.clearkey', key, kid, session);
        }
        else if (typeof self.element.msaddKey == 'function') {
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('>> CK msaddKey sessionID:' + session, '#40ff40');
            self.element.msaddKey('org.w3.clearkey', key, kid, session);
        }
        else if (typeof self.element.addKey == 'function') {
            self.element.addKey('org.w3.clearkey', key, kid, session); //Temporary
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('>> CK addKey sessionID:' + session, '#40ff40');
        }
    };
    // setAuthtoken(value: any): void {
    //   this.authtoken = value;
    // }
    ProtectionExtensions.prototype.extractPROFromPSSHBox = function (initData) {
        var abuf = initData.buffer;
        var dv = new DataView(abuf);
        var pos = 0;
        while (pos < abuf.byteLength) {
            var box_size = dv.getUint32(pos, false);
            var type = dv.getUint32(pos + 4, false);
            if (type != 0x70737368)
                throw 'Box type ' + type.toString(16) + ' not equal to "pssh"';
            if (dv.getUint32(pos + 12, false) == 0x9a04f079 &&
                dv.getUint32(pos + 16, false) == 0x98404286 &&
                dv.getUint32(pos + 20, false) == 0xab92e65b &&
                dv.getUint32(pos + 24, false) == 0xe0885f95) {
                var size = dv.getUint32(pos + 28, false);
                var pro = new Uint16Array(abuf.slice(pos + 32 + (4 + 2 + 2 + 2), pos + 32 + size));
                var xmlString = arrayToString(pro);
                var parser = new DOMParser();
                var xmlDoc = parser.parseFromString(xmlString, 'application/xml');
                return xmlDoc;
            }
            else {
                pos += box_size;
            }
        }
        return null;
    };
    ProtectionExtensions.prototype.extractKIDFromPSSHBox = function (initData) {
        var abuf = initData.buffer;
        var dv = new DataView(abuf);
        var pos = 0;
        while (pos < abuf.byteLength) {
            var box_size = dv.getUint32(pos, false);
            var type = dv.getUint32(pos + 4, false);
            if (type != 0x70737368)
                throw 'Box type ' + type.toString(16) + ' not equal to "pssh"';
            if (dv.getUint32(pos + 12, false) == 0x9a04f079 &&
                dv.getUint32(pos + 16, false) == 0x98404286 &&
                dv.getUint32(pos + 20, false) == 0xab92e65b &&
                dv.getUint32(pos + 24, false) == 0xe0885f95) {
                var size = dv.getUint32(pos + 28, false);
                var pro = new Uint16Array(abuf.slice(pos + 32 + (4 + 2 + 2 + 2), pos + 32 + size));
                var xmlString = void 0;
                var b64Kid = void 0;
                var kidArray = void 0;
                var kid = void 0;
                xmlString = arrayToString(pro);
                var parser = new DOMParser();
                var xmlDoc = parser.parseFromString(xmlString, 'application/xml');
                if (xmlDoc.getElementsByTagName('LA_URL')[0]) {
                    //
                }
                if (xmlDoc.getElementsByTagName('KID')[0]) {
                    b64Kid =
                        xmlDoc.getElementsByTagName('KID')[0].childNodes[0].nodeValue;
                }
                kidArray = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decodeArray(b64Kid);
                //MSbinary To UUID
                kid =
                    ('0' + kidArray[3].toString(16)).slice(-2) +
                        ('0' + kidArray[2].toString(16)).slice(-2) +
                        ('0' + kidArray[1].toString(16)).slice(-2) +
                        ('0' + kidArray[0].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[5].toString(16)).slice(-2) +
                        ('0' + kidArray[4].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[7].toString(16)).slice(-2) +
                        ('0' + kidArray[6].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[8].toString(16)).slice(-2) +
                        ('0' + kidArray[9].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[10].toString(16)).slice(-2) +
                        ('0' + kidArray[11].toString(16)).slice(-2) +
                        ('0' + kidArray[12].toString(16)).slice(-2) +
                        ('0' + kidArray[13].toString(16)).slice(-2) +
                        ('0' + kidArray[14].toString(16)).slice(-2) +
                        ('0' + kidArray[15].toString(16)).slice(-2);
                return kid;
            }
            else {
                pos += box_size;
            }
        }
        return 'CCC';
    };
    ProtectionExtensions.prototype.extractWideVineKIDFromPSSHBox = function (initData) {
        var abuf = initData.buffer;
        var dv = new DataView(abuf);
        var pos = 0;
        while (pos < abuf.byteLength) {
            var box_size = dv.getUint32(pos, false);
            var type = dv.getUint32(pos + 4, false);
            if (type != 0x70737368)
                throw 'Box type ' + type.toString(16) + ' not equal to "pssh"';
            if (dv.getUint32(pos + 12, false) == 0xedef8ba9 &&
                dv.getUint32(pos + 16, false) == 0x79d64ace &&
                dv.getUint32(pos + 20, false) == 0xa3c827dc &&
                dv.getUint32(pos + 24, false) == 0xd51d21ed) {
                //var size = dv.getUint32(pos + 28, false),
                var kidArray = new Uint8Array(abuf.slice(pos + 32 + 4, pos + 32 + 4 + 16)), kid;
                kid =
                    ('0' + kidArray[0].toString(16)).slice(-2) +
                        ('0' + kidArray[1].toString(16)).slice(-2) +
                        ('0' + kidArray[2].toString(16)).slice(-2) +
                        ('0' + kidArray[3].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[4].toString(16)).slice(-2) +
                        ('0' + kidArray[5].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[6].toString(16)).slice(-2) +
                        ('0' + kidArray[7].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[8].toString(16)).slice(-2) +
                        ('0' + kidArray[9].toString(16)).slice(-2) +
                        '-' +
                        ('0' + kidArray[10].toString(16)).slice(-2) +
                        ('0' + kidArray[11].toString(16)).slice(-2) +
                        ('0' + kidArray[12].toString(16)).slice(-2) +
                        ('0' + kidArray[13].toString(16)).slice(-2) +
                        ('0' + kidArray[14].toString(16)).slice(-2) +
                        ('0' + kidArray[15].toString(16)).slice(-2);
                return kid;
            }
            else {
                pos += box_size;
            }
        }
        return 'CCC';
    };
    ProtectionExtensions.prototype.listenToNeedKey = function (videoModel, listener) {
        videoModel.listen('webkitneedkey', listener);
        videoModel.listen('msneedkey', listener);
        videoModel.listen('needKey', listener);
    };
    ProtectionExtensions.prototype.listenToNeedKeyEME01b = function (element, listener) {
        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('listenToNeedKeyEME01b:' + this.EME01b_prefix, '#8080ff');
        var args = {
            standard: 'needkey',
            webkit: 'webkitneedkey',
            ms: 'msneedkey',
        };
        element.addEventListener(args[this.EME01b_prefix], listener, false);
    };
    ProtectionExtensions.prototype.listenToKeyError = function (source, listener) {
        source.addEventListener('webkitkeyerror', listener, false);
        source.addEventListener('mskeyerror', listener, false);
        source.addEventListener('keyerror', listener, false);
    };
    ProtectionExtensions.prototype.listenToKeyMessage = function (source, listener) {
        try {
            source.addEventListener('webkitkeymessage', listener, false);
            source.addEventListener('mskeymessage', listener, false);
            source.addEventListener('keymessage', listener, false);
        }
        catch (e) {
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('listenToKeyMessage Error: ' + e.message, '#8080ff');
        }
    };
    ProtectionExtensions.prototype.listenToKeyAdded = function (source, listener) {
        source.addEventListener('webkitkeyadded', listener, false);
        source.addEventListener('mskeyadded', listener, false);
        source.addEventListener('keyadded', listener, false);
    };
    ProtectionExtensions.prototype.unlistenToNeedKeyEME01b = function (element, listener) {
        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log('unlistenToNeedKeyEME01b:' + this.EME01b_prefix, '#8080ff');
        var args = {
            standard: 'needkey',
            webkit: 'webkitneedkey',
            ms: 'msneedkey',
        };
        element.removeEventListener(args[this.EME01b_prefix], listener, false);
    };
    ProtectionExtensions.prototype.unlistenToNeedKey = function (videoModel, listener) {
        videoModel.unlisten('webkitneedkey', listener);
        videoModel.unlisten('msneedkey', listener);
        videoModel.unlisten('needKey', listener);
    };
    ProtectionExtensions.prototype.unlistenToKeyError = function (source, listener) {
        source.removeEventListener('webkitkeyerror', listener);
        source.removeEventListener('mskeyerror', listener);
        source.removeEventListener('keyerror', listener);
    };
    ProtectionExtensions.prototype.unlistenToKeyMessage = function (source, listener) {
        source.removeEventListener('webkitkeymessage', listener);
        source.removeEventListener('mskeymessage', listener);
        source.removeEventListener('keymessage', listener);
    };
    ProtectionExtensions.prototype.unlistenToKeyAdded = function (source, listener) {
        source.removeEventListener('webkitkeyadded', listener);
        source.removeEventListener('mskeyadded', listener);
        source.removeEventListener('keyadded', listener);
    };
    return ProtectionExtensions;
}());



/***/ }),

/***/ "./ts/dash/protection/ProtectionModel.ts":
/*!***********************************************!*\
  !*** ./ts/dash/protection/ProtectionModel.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtectionModel": function() { return /* binding */ ProtectionModel; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _ProtectionExtensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProtectionExtensions */ "./ts/dash/protection/ProtectionExtensions.ts");
// The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
//
// Copyright (c) 2013, Microsoft Open Technologies, Inc.
// Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
//
// All rights reserved.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



/**
 * ProtectionModel
 *
 * @module ProtectionModel（ProtectionModelモジュール）
 */
/**
 * ProtectionModel
 * @constructor
 */
var ProtectionModel = /** @class */ (function () {
    function ProtectionModel(params, eventBus) {
        var _this = this;
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__["default"];
        this.teardownKeySystem = function (kid) {
            var self = _this;
            _this.removeKeySystem.call(self, kid);
        };
        //NSV-a  const getKID = (data) => {
        //NSV-a    if (!data || !utils.hasProperty(data, 'cenc:default_KID')) {
        //NSV-a      return null;
        //NSV-a    }
        //NSV-a    return data['cenc:default_KID'];
        //NSV-a  };
        //NSV-a
        //NSV-a  const _getKID = (idx, contentProtections) => {
        //NSV-a    if (utils.hasProperty(contentProtections[idx], 'cenc:default_KID')) {
        //NSV-a      return contentProtections[idx]['cenc:default_KID'];
        //NSV-a    } else {
        //NSV-a      for (let i = 0; i < contentProtections.length; i++) {
        //NSV-a        if (utils.hasProperty(contentProtections[i], 'cenc:default_KID')) {
        //NSV-a          return contentProtections[i]['cenc:default_KID'];
        //NSV-a        }
        //NSV-a      }
        //NSV-a    }
        //NSV-a    return null;
        //NSV-a  };
        this.selectKeySystem = function (codec, contentProtections, initData) {
            var self = _this;
            for (var ks = 0; ks < _this.keySystemDescs.length; ++ks) {
                for (var cp = 0; cp < contentProtections.length; ++cp) {
                    if (_this.keySystemDescs[ks].isSupported(contentProtections[cp]) &&
                        _this.protectionExt.supportsCodec(_this.keySystemDescs[ks].keysTypeString, codec)) {
                        var kid = void 0;
                        if (!kid) {
                            if (_this.keySystemDescs[ks].keysTypeString ===
                                'com.microsoft.playready') {
                                kid = _this.protectionExt.extractKIDFromPSSHBox(initData);
                            }
                            else if (_this.keySystemDescs[ks].keysTypeString === 'com.widevine.alpha') {
                                kid = _this.protectionExt.extractWideVineKIDFromPSSHBox(initData);
                            }
                            else {
                                kid = 'unknown';
                            }
                        }
                        _this.logHandler.log_item('codec_video', 'V-Codec: ' + codec);
                        _this.logHandler.log_item('keysystem', 'KeySystem: ' + _this.keySystemDescs[ks].keysTypeString);
                        _this.logHandler.log_item('keysystem_kid_v', 'KID: ' + kid);
                        if (_this.kids.indexOf(kid) == -1) {
                            _this.NXDebug.debug(String(_this.kids));
                            _this.addKeySystem.call(self, kid, contentProtections[cp], _this.keySystemDescs[ks]);
                            _this.kids.push(kid);
                        }
                        _this.logHandler.log_DRM('  KID ==> ' + kid, 99);
                        _this.logHandler.log_DRM('  KeyInfo ==> ' + _this.keySystemDescs[ks].keysTypeString, 99);
                        _this.logHandler.log_DRM('  Codec ==> ' + codec, 99);
                        _this.NXDebug.log('DRM: Selected Key System: ' +
                            _this.keySystemDescs[ks].keysTypeString +
                            ' For KID: ' +
                            kid);
                        return {
                            kid: kid,
                            keysTypeString: _this.keySystemDescs[ks].keysTypeString,
                        };
                    }
                }
            }
            throw new Error('DRM: The protection system for this content is not supported.');
        };
        this.ensureKeySession = function (kid, codec, eventInitData) {
            var self = _this;
            var session = null;
            var initData = null;
            if (!_this.needToAddKeySession.call(self, kid)) {
                return null;
            }
            if (!initData && eventInitData != null) {
                initData = eventInitData;
                _this.logHandler.log('DRM: Using initdata from needskey event.');
                _this.NXDebug.log('DRM: Using initdata from needskey event.');
            }
            // } else if (initData != null) {
            //   this.logHandler.log('DRM: Using initdata from prheader in mpd.');
            //   this.NXDebug.log('DRM: Using initdata from prheader in mpd.');
            // }
            if (initData != null) {
                session = _this.addKeySession.call(self, kid, codec, initData);
                _this.logHandler.log('DRM: Added Key Session [' +
                    (session.sessionIdIsAvailable
                        ? session.sessionId
                        : session.tmpSessionId) +
                    '] for KID: ' +
                    kid +
                    ' type: ' +
                    codec);
                _this.NXDebug.log('DRM: Added Key Session [' +
                    session.sessionId +
                    '] for KID: ' +
                    kid +
                    ' type: ' +
                    codec);
            }
            else {
                _this.NXDebug.log('DRM: initdata is null.');
            }
            return session;
        };
        //NSV-a  const getAuthToken = (atURL, _callback) => {
        //NSV-a    const callback = _callback || (() => {}),
        //NSV-a      xhr = new XMLHttpRequest();
        //NSV-a    xhr.onload = () => {
        //NSV-a      if (xhr.status == 200) {
        //NSV-a        callback({
        //NSV-a          status: 'ok',
        //NSV-a          data: xhr.response,
        //NSV-a        });
        //NSV-a      } else {
        //NSV-a        callback({
        //NSV-a          status: 'error',
        //NSV-a          msg:
        //NSV-a            'DRM: get auth token xhr status is "' +
        //NSV-a            xhr.statusText +
        //NSV-a            '" (' +
        //NSV-a            xhr.status +
        //NSV-a            '), expected to be 200. readyState is ' +
        //NSV-a            xhr.readyState,
        //NSV-a        });
        //NSV-a      }
        //NSV-a    };
        //NSV-a    xhr.onabort = () => {
        //NSV-a      callback({
        //NSV-a        status: 'error',
        //NSV-a        msg:
        //NSV-a          'DRM: get auth token, XHR aborted. status is "' +
        //NSV-a          xhr.statusText +
        //NSV-a          '" (' +
        //NSV-a          xhr.status +
        //NSV-a          '), readyState is ' +
        //NSV-a          xhr.readyState,
        //NSV-a      });
        //NSV-a    };
        //NSV-a    xhr.onerror = () => {
        //NSV-a      callback({
        //NSV-a        status: 'error',
        //NSV-a        msg:
        //NSV-a          'DRM: get auth token, XHR error. status is "' +
        //NSV-a          xhr.statusText +
        //NSV-a          '" (' +
        //NSV-a          xhr.status +
        //NSV-a          '), readyState is ' +
        //NSV-a          xhr.readyState,
        //NSV-a      });
        //NSV-a    };
        //NSV-a
        //NSV-a    xhr.open('GET', atURL);
        //NSV-a    xhr.responseType = 'json';
        //NSV-a    xhr.send();
        //NSV-a  };
        this.updateFromMessage = function (kid, session, bytes, laURL, callback) {
            var self = _this;
            _this._updateFromMessage.call(self, kid, bytes, laURL, _this.xhrCustom, function (d) {
                if (d.status === 'ok') {
                    session.update(d.data);
                    _this.logHandler.log_DRM('update()', 1);
                    callback(d);
                }
                else {
                    callback(d);
                }
            });
        };
        this.updateFromMessageForClearKey = function (kid, session, msg) {
            _this.protectionExt.addKeyForClearKey(kid, session, msg);
        };
        this.addKeySession = function (kid, mediaCodec, initData) {
            var session = null;
            try {
                session = _this.protectionExt.createSession(_this.keySystems[kid].keys, mediaCodec, initData);
            }
            catch (e) {
                _this.logHandler.log('createSession ' + e);
            }
            if (session.sessionId) {
                session.sessionIdIsAvailable = true;
            }
            else {
                session.tmpSessionId = new Date().getTime();
            }
            try {
                _this.protectionExt.listenToKeyAdded(session, _this.keyAddedListener);
                _this.protectionExt.listenToKeyError(session, _this.keyErrorListener);
                _this.protectionExt.listenToKeyMessage(session, _this.keyMessageListener);
                _this.keySystems[kid].initData = initData;
                _this.keySystems[kid].keySessions.push(session);
            }
            catch (e) {
                _this.logHandler.log('after listener ' + e);
            }
            return session;
        };
        this.addKeySystem = function (kid, contentProtectionData, keySystemDesc) {
            var keysLocal = null;
            if (_this.element.mediaKeysObject == undefined) {
                keysLocal = _this.protectionExt.createMediaKeys(keySystemDesc.keysTypeString);
                _this.protectionExt.setMediaKey(_this.element, keysLocal);
            }
            else {
                keysLocal = _this.element.mediaKeysObject;
            }
            _this.keySystems[kid] = {
                kID: kid,
                contentProtection: contentProtectionData,
                keySystem: keySystemDesc,
                keys: keysLocal,
                initData: null,
                keySessions: [],
            };
        };
        this.removeKeySystem = function (kid) {
            if (kid !== null &&
                _this.keySystems[kid] !== undefined &&
                _this.keySystems[kid].keySessions.length !== 0) {
                var keySessions = _this.keySystems[kid].keySessions;
                for (var kss = 0; kss < keySessions.length; ++kss) {
                    _this.protectionExt.unlistenToKeyError(keySessions[kss], _this.keyErrorListener);
                    _this.protectionExt.unlistenToKeyAdded(keySessions[kss], _this.keyAddedListener);
                    _this.protectionExt.unlistenToKeyMessage(keySessions[kss], _this.keyMessageListener);
                    keySessions[kss].close();
                }
                _this.keySystems[kid] = undefined;
            }
        };
        this.needToAddKeySession = function (kid) {
            var keySystem = _this.keySystems[kid];
            return keySystem.keySystem.needToAddKeySession(keySystem.initData, keySystem.keySessions);
        };
        //NSV-a  const getInitData = (kid) => {
        //NSV-a    let keySystem = null;
        //NSV-a    keySystem = keySystems[kid];
        //NSV-a    return keySystem.keySystem.getInitData(keySystem.contentProtection);
        //NSV-a  };
        this._updateFromMessage = function (kid, bytes, laURL, token, callback) {
            return _this.keySystems[kid].keySystem.getUpdate(bytes, laURL, token, callback);
        };
        this.element = null;
        this.keyAddedListener = null;
        this.keyErrorListener = null;
        this.keyMessageListener = null;
        this.keySystems = [];
        this.kids = [];
        this.keySystemDescs = null;
        this.videoModel = null;
        this.xhrCustom = null;
        this.protectionExt = new _ProtectionExtensions__WEBPACK_IMPORTED_MODULE_2__.ProtectionExtensions(params, eventBus);
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    ProtectionModel.prototype.init = function (v, xhrCustom, _prefix) {
        this.videoModel = v;
        this.xhrCustom = xhrCustom;
        this.element = this.videoModel.getElement();
        this.keySystemDescs = this.protectionExt.getKeySystems();
        this.protectionExt.init(this.element, '');
    };
    ProtectionModel.prototype.listenToNeedKey = function (listener) {
        this.protectionExt.listenToNeedKey(this.videoModel, listener);
    };
    ProtectionModel.prototype.listenToKeyError = function (listener) {
        this.keyErrorListener = listener;
        for (var ks = 0; ks < this.keySystems.length; ++ks) {
            var keySessions = this.keySystems[ks].keySessions;
            for (var kss = 0; kss < keySessions.length; ++kss) {
                this.protectionExt.listenToKeyError(keySessions[kss], listener);
            }
        }
    };
    ProtectionModel.prototype.listenToKeyMessage = function (listener) {
        this.keyMessageListener = listener;
        for (var ks = 0; ks < this.keySystems.length; ++ks) {
            var keySessions = this.keySystems[ks].keySessions;
            for (var kss = 0; kss < keySessions.length; ++kss) {
                this.logHandler.log('Model.listenToKeyMessage ' + kss); //aaaaa
                this.protectionExt.listenToKeyMessage(keySessions[kss], listener);
            }
        }
    };
    ProtectionModel.prototype.listenToKeyAdded = function (listener) {
        this.keyAddedListener = listener;
        for (var ks = 0; ks < this.keySystems.length; ++ks) {
            var keySessions = this.keySystems[ks].keySessions;
            for (var kss = 0; kss < keySessions.length; ++kss) {
                this.protectionExt.listenToKeyAdded(keySessions[kss], listener);
            }
        }
    };
    ProtectionModel.prototype.unlistenToNeedKey = function (listener) {
        this.protectionExt.unlistenToNeedKey(this.videoModel, listener);
    };
    ProtectionModel.prototype.unlistenToKeyError = function (listener) {
        for (var ks = 0; ks < this.keySystems.length; ++ks) {
            var keySessions = this.keySystems[ks].keySessions;
            for (var kss = 0; kss < keySessions.length; ++kss) {
                this.protectionExt.unlistenToKeyError(keySessions[kss], listener);
            }
        }
    };
    ProtectionModel.prototype.unlistenToKeyMessage = function (listener) {
        for (var ks = 0; ks < this.keySystems.length; ++ks) {
            var keySessions = this.keySystems[ks].keySessions;
            for (var kss = 0; kss < keySessions.length; ++kss) {
                this.protectionExt.unlistenToKeyMessage(keySessions[kss], listener);
            }
        }
    };
    ProtectionModel.prototype.unlistenToKeyAdded = function (listener) {
        for (var ks = 0; ks < this.keySystems.length; ++ks) {
            var keySessions = this.keySystems[ks].keySessions;
            for (var kss = 0; kss < keySessions.length; ++kss) {
                this.protectionExt.unlistenToKeyAdded(keySessions[kss], listener);
            }
        }
    };
    return ProtectionModel;
}());



/***/ }),

/***/ "./ts/dash/protection/ProtectionModelEME01b.ts":
/*!*****************************************************!*\
  !*** ./ts/dash/protection/ProtectionModelEME01b.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtectionModelEME01b": function() { return /* binding */ ProtectionModelEME01b; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _ProtectionExtensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProtectionExtensions */ "./ts/dash/protection/ProtectionExtensions.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



/**
 * ProtectionModelEME01b
 *
 * @module ProtectionModelEME01b（ProtectionModelEME01bモジュール）
 */
/**
 * ProtectionModelEME01b
 * @constructor
 */
var ProtectionModelEME01b = /** @class */ (function () {
    function ProtectionModelEME01b(params, eventBus) {
        var _this = this;
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__["default"];
        // teardownKeySystem = (kid: string): void => {
        //   this.removeKeySystem(kid);
        // };
        this.selectKeySystemEME01b = function (contentProtection, initData) {
            var kid = null;
            for (var ks = 0; ks < _this.keySystems.length; ++ks) {
                for (var cp = 0; cp < contentProtection.length; ++cp) {
                    if (_this.keySystems[ks].isSupported(contentProtection[cp])) {
                        if (_this.keySystems[ks].keysTypeString === 'com.microsoft.playready') {
                            kid = _this.protectionExt.extractKIDFromPSSHBox(initData);
                        }
                        else if (_this.keySystems[ks].keysTypeString === 'com.widevine.alpha') {
                            kid = _this.protectionExt.extractWideVineKIDFromPSSHBox(initData);
                        }
                        else {
                            kid = 'unknown';
                        }
                        _this.logHandler.log_item('keysystem', 'KeySystem: ' + _this.keySystems[ks].keysTypeString);
                        _this.logHandler.log_item('keysystem_kid_v', 'KID: ' + kid);
                        _this.addKeySystem01b(kid, contentProtection[cp], _this.keySystems[ks]);
                        return {
                            kid: kid,
                            initData: initData,
                            keysTypeString: _this.keySystems[ks].keysTypeString,
                        };
                    }
                }
            }
            return kid;
        };
        //NSV-a const getAuthToken = (atURL, _callback) => {
        //NSV-a   const callback = _callback || (() => {});
        //NSV-a   const xhr = new XMLHttpRequest();
        //NSV-a
        //NSV-a   xhr.onload = () => {
        //NSV-a     if (xhr.status == 200) {
        //NSV-a       callback({
        //NSV-a         status: 'ok',
        //NSV-a         data: xhr.response,
        //NSV-a       });
        //NSV-a     } else {
        //NSV-a       callback({
        //NSV-a         status: 'error',
        //NSV-a         msg:
        //NSV-a           'DRM: get auth token xhr status is "' +
        //NSV-a           xhr.statusText +
        //NSV-a           '" (' +
        //NSV-a           xhr.status +
        //NSV-a           '), expected to be 200. readyState is ' +
        //NSV-a           xhr.readyState,
        //NSV-a       });
        //NSV-a     }
        //NSV-a   };
        //NSV-a   xhr.onabort = () => {
        //NSV-a     callback({
        //NSV-a       status: 'error',
        //NSV-a       msg:
        //NSV-a         'DRM: get auth token, XHR aborted. status is "' +
        //NSV-a         xhr.statusText +
        //NSV-a         '" (' +
        //NSV-a         xhr.status +
        //NSV-a         '), readyState is ' +
        //NSV-a         xhr.readyState,
        //NSV-a     });
        //NSV-a   };
        //NSV-a   xhr.onerror = () => {
        //NSV-a     callback({
        //NSV-a       status: 'error',
        //NSV-a       msg:
        //NSV-a         'DRM: get auth token, XHR error. status is "' +
        //NSV-a         xhr.statusText +
        //NSV-a         '" (' +
        //NSV-a         xhr.status +
        //NSV-a         '), readyState is ' +
        //NSV-a         xhr.readyState,
        //NSV-a     });
        //NSV-a   };
        //NSV-a
        //NSV-a   xhr.open('GET', atURL);
        //NSV-a   xhr.responseType = 'json';
        //NSV-a   xhr.send();
        //NSV-a };
        this._licenseFromMessage = function (kid, msg, laURL, token, callback) {
            _this.NXDebug.debug('_licenseFromMessage ' + kid + ' ' + laURL);
            _this.logHandler.log('_licenseFromMessage ' + kid + ' ' + laURL);
            return _this.keySystems[kid].keySystem.getKeyEME01b(msg, laURL, token, callback);
        };
        this.addKeyFromMessage = function (kid, session, idata, msg, laURL, callback) {
            if (callback === void 0) { callback = function () { }; }
            var self = _this;
            var keysTypeString = _this.keySystems[kid].keySystem.keysTypeString;
            _this._licenseFromMessage.call(self, kid, msg, laURL, _this.xhrCustom, function (d) {
                if (d.status === 'ok') {
                    _this.protectionExt.addKey(d.data, idata, session, keysTypeString);
                    callback(d);
                }
                else {
                    callback(d);
                }
            });
        };
        this.addKeyFromMessageForClearKey = function (kid, session, idata, _msg, _laURL) {
            _this.protectionExt.addKeyForClearKey(kid, session, idata);
        };
        this.element = null;
        this.keySystems = [];
        this.xhrCustom = null;
        this.protectionExt = null;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.params = params;
        this.eventBus = eventBus;
    }
    // setup(): void {
    //   this.keySystems = this.protectionExt!.getKeySystems();
    //   this.element = this.videoModel!.getElement();
    // }
    ProtectionModelEME01b.prototype.init = function (v, xhrCustom, prefix) {
        this.videoModel = v;
        this.element = v.getElement();
        this.xhrCustom = xhrCustom;
        try {
            this.protectionExt = new _ProtectionExtensions__WEBPACK_IMPORTED_MODULE_2__.ProtectionExtensions(this.params, this.eventBus);
        }
        catch (e) {
            this.logHandler.log(e);
        }
        this.protectionExt.init(this.element, prefix);
        this.keySystems = this.protectionExt.getKeySystems();
    };
    ProtectionModelEME01b.prototype.addKeySystem01b = function (kid, contentProtectionData, keySystemDesc) {
        var keysLocal = null;
        this.keySystems[kid] = {
            kID: kid,
            contentProtection: contentProtectionData,
            keySystem: keySystemDesc,
            keys: keysLocal,
            initData: null,
            keySessions: [],
        };
    };
    ProtectionModelEME01b.prototype.getInitData = function (kid) {
        var keySystem = this.keySystems[kid];
        return keySystem.keySystem.getInitData(keySystem.contentProtection);
    };
    ProtectionModelEME01b.prototype.getKeysTypeString = function (kid) {
        return this.keySystems[kid].keySystem.keysTypeString;
    };
    ProtectionModelEME01b.prototype.addKey = function (type, key, data, _id) {
        this.logHandler.log_DRM('ProtectionModel::addKey ' + type + ' ' + key, 1);
        // @ts-ignore
        this.protectionExt.addKey(this.element, type, key, data);
    };
    ProtectionModelEME01b.prototype.generateKeyRequest = function (data, kid) {
        if (kid != 'clearkey') {
            this.protectionExt.generateKeyRequest(this.element, data, this.keySystems[kid]);
        }
        else {
            this.protectionExt.generateKeyRequest(this.element, data, null);
        }
    };
    ProtectionModelEME01b.prototype.listenToNeedKey = function (listener) {
        this.protectionExt.listenToNeedKeyEME01b(this.element, listener);
    };
    ProtectionModelEME01b.prototype.listenToKeyMessage = function (listener) {
        this.protectionExt.listenToKeyMessage(this.element, listener);
    };
    ProtectionModelEME01b.prototype.listenToKeyAdded = function (listener) {
        this.protectionExt.listenToKeyAdded(this.element, listener);
    };
    ProtectionModelEME01b.prototype.listenToKeyError = function (listener) {
        this.protectionExt.listenToKeyError(this.element, listener);
    };
    ProtectionModelEME01b.prototype.unlistenToNeedKey = function (listener) {
        this.protectionExt.unlistenToNeedKeyEME01b(this.element, listener);
    };
    ProtectionModelEME01b.prototype.unlistenToKeyMessage = function (listener) {
        this.protectionExt.unlistenToKeyMessage(this.element, listener);
    };
    ProtectionModelEME01b.prototype.unlistenToKeyAdded = function (listener) {
        this.protectionExt.unlistenToKeyAdded(this.element, listener);
    };
    ProtectionModelEME01b.prototype.unlistenToKeyError = function (listener) {
        this.protectionExt.unlistenToKeyError(this.element, listener);
    };
    return ProtectionModelEME01b;
}());



/***/ }),

/***/ "./ts/dash/protection/ProtectionModelRMKSA.ts":
/*!****************************************************!*\
  !*** ./ts/dash/protection/ProtectionModelRMKSA.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProtectionModelRMKSA": function() { return /* binding */ ProtectionModelRMKSA; }
/* harmony export */ });
/* harmony import */ var _core_Base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base64 */ "./ts/dash/core/Base64.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _ProtectionExtensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProtectionExtensions */ "./ts/dash/protection/ProtectionExtensions.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */





/**
 * ProtectionModelRMKSA
 *
 * @module ProtectionModelRMKSA（ProtectionModelRMKSAモジュール）
 */
/**
 * ProtectionModelRMKSA
 * @constructor
 */
var ProtectionModelRMKSA = /** @class */ (function () {
    function ProtectionModelRMKSA(params, eventBus) {
        var _this = this;
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        // teardownKeySystem = (kid: string): void => {
        //   this.removeKeySystem(kid);
        // };
        //NSV-a const abortWrapper = (f, c) =>
        //NSV-a   new Promise((resolve, reject) => {
        //NSV-a     setTimeout(() => {
        //NSV-a       c.aborted = true;
        //NSV-a       reject(new Error('abort'));
        //NSV-a     }, 1000);
        //NSV-a     f.then(resolve, reject);
        //NSV-a   });
        //NSV-a
        //NSV-a const getKID = (data) => {
        //NSV-a   if (!data || !hasProperty(data, 'cenc:default_KID')) {
        //NSV-a     return 'unknown';
        //NSV-a   }
        //NSV-a   return data['cenc:default_KID'];
        //NSV-a };
        this.createSupportedKeySystem = function (codecs, keysTypeString) {
            var systemOptions = [];
            var option = {};
            option['initDataTypes'] = ['cenc'];
            if (codecs['video']) {
                option['videoCapabilities'] = [
                    {
                        contentType: codecs['video'],
                        robustness: '',
                    },
                ];
            }
            if (codecs['audio']) {
                option['audioCapabilities'] = [
                    {
                        contentType: codecs['audio'],
                        robustness: '',
                    },
                ];
            }
            systemOptions.push(option);
            return navigator
                .requestMediaKeySystemAccess(keysTypeString, systemOptions)
                .then(function (keySystemAccess //NXDebug.info(keySystemAccess.getConfiguration());
            ) { return keySystemAccess.createMediaKeys(); });
        };
        this.getSystems = function () { return [
            {
                schemeIdUri: 'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',
                keysTypeString: 'com.microsoft.playready',
                isSupported: function (data) {
                    return this.schemeIdUri === data.schemeIdUri.toLowerCase();
                },
            },
            {
                schemeIdUri: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',
                keysTypeString: 'com.widevine.alpha',
                isSupported: function (data) {
                    return this.schemeIdUri === data.schemeIdUri.toLowerCase();
                },
            },
            {
                schemeIdUri: 'urn:mpeg:dash:mp4protection:2011',
                keysTypeString: 'com.microsoft.playready',
                isSupported: function (data) {
                    return (this.schemeIdUri === data.schemeIdUri.toLowerCase() &&
                        data.value.toLowerCase() === 'cenc');
                },
            },
            {
                schemeIdUri: 'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b',
                keysTypeString: 'org.w3.clearkey',
                isSupported: function (data) {
                    return this.schemeIdUri === data.schemeIdUri.toLowerCase();
                },
            },
        ]; };
        this.selectKeySystemRMKSA = function (codecs, contentProtection, _initData, _cp, _ks, fromEvent) {
            var ks = _ks;
            var cp = _cp;
            var initData = _initData;
            //    let idat: Uint8Array;
            var kid;
            if (_this.keySystemDescs[ks].isSupported(contentProtection[cp])) {
                /* istanbul ignore next */
                _this.createSupportedKeySystem(codecs, _this.keySystemDescs[ks].keysTypeString)
                    .then(function (createdMediaKeys) {
                    if (fromEvent == false)
                        initData = contentProtection[cp].pssh;
                    if (_this.keySystemDescs[ks].keysTypeString ===
                        'com.microsoft.playready') {
                        //            idat = new Uint8Array(initData!.buffer);
                        kid = _this.protectionExt.extractKIDFromPSSHBox(new Uint8Array(initData));
                    }
                    else if (_this.keySystemDescs[ks].keysTypeString === 'com.widevine.alpha') {
                        //            idat = new Uint8Array(initData!.buffer);
                        kid = _this.protectionExt.extractWideVineKIDFromPSSHBox(new Uint8Array(initData));
                    }
                    else if (_this.keySystemDescs[ks].keysTypeString === 'org.w3.clearkey') {
                        //            idat = new Uint8Array(initData!.buffer);
                        kid = _this.protectionExt.extractClearKeyKIDFromPSSHBox(new Uint8Array(initData));
                    }
                    else {
                        kid = 'unknown';
                    }
                    _this.logHandler.log_item('codec_video', 'V-Codec: ' + codecs['video']);
                    _this.logHandler.log_item('keysystem', 'KeySystem: ' + _this.keySystemDescs[ks].keysTypeString);
                    _this.logHandler.log_item('keysystem_kid_v', 'KID: ' + kid);
                    _this.logHandler.log_DRM('  KID ==> ' + kid, 99);
                    _this.logHandler.log_DRM('  KeyInfo ==> ' + _this.keySystemDescs[ks].keysTypeString, 99);
                    _this.logHandler.log_DRM('  Codec ==> ' + codecs['video'], 99);
                    _this.NXDebug.log('DRM: Selected Key System: ' +
                        _this.keySystemDescs[ks].keysTypeString +
                        ' For KID: ' +
                        kid);
                    createdMediaKeys.keysTypeString =
                        _this.keySystemDescs[ks].keysTypeString;
                    createdMediaKeys.schemeIdUri =
                        _this.keySystemDescs[ks].schemeIdUri;
                    _this.element.mediaKeysObject = createdMediaKeys;
                    if (fromEvent) {
                        for (var i = 0; i < _this.element.pendingSessionData.length; i++) {
                            var data = _this.element.pendingSessionData[i];
                            _this.makeNewRequest(_this.element.mediaKeysObject, data.initDataType, data.initData);
                        }
                        _this.element.pendingSessionData = [];
                    }
                    else {
                        for (var i = 0; i < _this.element.pendingContentProtectionData.length; i++) {
                            var cpd = _this.element.pendingContentProtectionData[i];
                            if (_this.keySystemDescs[ks].isSupported(cpd)) {
                                _this.makeNewRequest(_this.element.mediaKeysObject, 'cenc', cpd.pssh);
                            }
                        }
                        _this.element.pendingContentProtectionData = [];
                    }
                    return _this.element.setMediaKeys(createdMediaKeys);
                })
                    .catch(function (error) {
                    _this.NXDebug.log(_this.keySystemDescs[ks].keysTypeString + ' error:' + error);
                    if (cp < contentProtection.length - 1) {
                        cp++;
                    }
                    else if (ks < _this.keySystemDescs.length - 1) {
                        ks++;
                        cp = 0;
                    }
                    else {
                        throw new Error('DRM: The protection system for this content is not supported.');
                    }
                    _this.selectKeySystemRMKSA(codecs, contentProtection, initData, cp, ks, fromEvent);
                });
            }
            else {
                if (cp < contentProtection.length - 1) {
                    cp++;
                }
                else if (ks < _this.keySystemDescs.length - 1) {
                    ks++;
                    cp = 0;
                }
                else {
                    throw new Error('DRM: The protection system for this content is not supported.');
                }
                _this.selectKeySystemRMKSA(codecs, contentProtection, initData, cp, ks, fromEvent);
            }
        };
        this.addKeySession = function (element, initDataType, initData) {
            if (element.mediaKeysObject) {
                _this.makeNewRequest(element.mediaKeysObject, initDataType, initData);
            }
            else {
                element.pendingSessionData.push({
                    initDataType: initDataType,
                    initData: initData,
                });
            }
        };
        this.addContentProtectionData = function (element, contentProtection) {
            if (element.mediaKeysObject) {
                for (var i = 0; i < contentProtection.length; i++) {
                    if (element.mediaKeysObject.schemeIdUri ==
                        contentProtection[i].schemeIdUri.toLowerCase()) {
                        _this.makeNewRequest(element.mediaKeysObject, 'cenc', contentProtection[i].pssh);
                    }
                }
            }
            else {
                element.pendingContentProtectionData =
                    element.pendingContentProtectionData.concat(contentProtection);
            }
        };
        this.makeNewRequest = function (mediaKeys, initDataType, initData) {
            var self = _this;
            var keySession = null;
            var keysTypeString = mediaKeys.keysTypeString;
            var kid;
            var idat;
            if (keysTypeString === 'com.microsoft.playready') {
                idat = new Uint8Array(initData);
                kid = _this.protectionExt.extractKIDFromPSSHBox(idat);
                if (_this.kids.indexOf(kid) > -1) {
                    return;
                }
                else {
                    _this.kids.push(kid);
                }
                var pro = _this.protectionExt.extractPROFromPSSHBox(idat);
                var laURL = void 0;
                if (pro.getElementsByTagName('LA_URL')[0]) {
                    laURL = pro.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue;
                }
                else {
                    laURL = 'unknown';
                }
                keySession = mediaKeys.createSession('temporary');
                keySession.laURL = laURL;
                keySession.keysTypeString = keysTypeString;
                keySession.addEventListener('message', _this.licenseRequestReady.bind(_this), false);
                keySession
                    .generateRequest(initDataType, initData)
                    .then(function () { })
                    .catch(function (_error) {
                    _this.logHandler.log('gerateRequest error');
                });
            }
            else if (keysTypeString === 'com.widevine.alpha') {
                idat = new Uint8Array(initData);
                kid = _this.protectionExt.extractWideVineKIDFromPSSHBox(idat);
                if (_this.kids.indexOf(kid) > -1) {
                    return;
                }
                else {
                    _this.kids.push(kid);
                }
                keySession = mediaKeys.createSession('temporary');
                //keySession!.laURL = laURL;
                keySession.keysTypeString = keysTypeString;
                keySession.addEventListener('message', _this.licenseRequestReady_wv.bind(_this), false);
                keySession
                    .generateRequest(initDataType, initData)
                    .then(function () { })
                    .catch(function ( /* error:any */) {
                    self.logHandler.log('gerateRequest error');
                });
            }
            else if (keysTypeString == 'org.w3.clearkey') {
                var keys = _this.protectionExt.extractClearKeyFromMessageForRMKSA(new Uint8Array(initData));
                var keyids = {};
                kid = keys['keys'][0]['kid'];
                keyids['kids'] = [kid];
                if (_this.kids.indexOf(kid) > -1) {
                    return;
                }
                else {
                    _this.kids.push(kid);
                }
                keySession = mediaKeys.createSession();
                keySession.addEventListener('message', _this.handleClearKeyMessage.bind(_this, keys), false);
                keySession.generateRequest('keyids', (0,_ProtectionExtensions__WEBPACK_IMPORTED_MODULE_3__.stringToArray)(JSON.stringify(keyids)));
            }
        };
        this.handleClearKeyMessage = function (keys, event) {
            var keySession = event.target;
            keys['type'] = 'temporary';
            keySession
                .update((0,_ProtectionExtensions__WEBPACK_IMPORTED_MODULE_3__.stringToArray)(JSON.stringify(keys)))
                .then(function () {
                _this.stream.onKeyAdded();
            })
                .catch(function (error) {
                _this.logHandler.log(error);
            });
        };
        /* istanbul ignore next */
        this.licenseRequestReady = function (event) {
            var bytes = new Uint8Array(event.message);
            var msg = String.fromCharCode.apply(null, Array.from(bytes));
            var decodedChallenge = null;
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(msg, 'application/xml');
            var headers = [];
            var qrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'query')
                ? _this.xhrCustom['query'].concat()
                : [];
            var hdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'header')
                ? _this.xhrCustom['header'].concat()
                : [];
            var onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'onPrepare')
                ? _this.xhrCustom['onPrepare']
                : function () { };
            var onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'onSuccess')
                ? _this.xhrCustom['onSuccess']
                : function () { };
            var onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'onError')
                ? _this.xhrCustom['onError']
                : function () { };
            var laURL;
            var ctypeIsSet;
            if (xmlDoc.getElementsByTagName('parsererror')[0]) {
                bytes = new Uint16Array(event.message);
                msg = String.fromCharCode.apply(null, Array.from(bytes));
                xmlDoc = parser.parseFromString(msg, 'application/xml');
            }
            if (xmlDoc.getElementsByTagName('LA_URL')[0]) {
                laURL = xmlDoc.getElementsByTagName('LA_URL')[0].childNodes[0].nodeValue;
            }
            else {
                laURL = event.target.laURL;
            }
            if (xmlDoc.getElementsByTagName('PlayReadyKeyMessage')[0]) {
                if (xmlDoc.getElementsByTagName('Challenge')[0]) {
                    var Challenge = xmlDoc.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue;
                    if (Challenge) {
                        decodedChallenge = _core_Base64__WEBPACK_IMPORTED_MODULE_0__.BASE64.decode(Challenge);
                    }
                }
                else {
                    _this.logHandler.log('error: DRM: playready update, can not find Challenge in keyMessage');
                    return;
                }
            }
            else {
                decodedChallenge = msg;
            }
            var headerNameList = xmlDoc.getElementsByTagName('name');
            var headerValueList = xmlDoc.getElementsByTagName('value');
            if (headerNameList.length != headerValueList.length) {
                _this.logHandler.log('error: DRM: playready update, invalid header name/value pair in keyMessage');
                return;
            }
            for (var i = 0; i < headerNameList.length; i++) {
                headers[i] = {
                    name: headerNameList[i].childNodes[0].nodeValue,
                    value: headerValueList[i].childNodes[0].nodeValue,
                };
            }
            if (!_this.useFetch) {
                var xhr_1 = new XMLHttpRequest();
                xhr_1.keySession = event.target;
                xhr_1.keysTypeString = event.target.keysTypeString;
                xhr_1.url = laURL;
                onPrepare({
                    req: xhr_1,
                    qrys: qrys,
                    hdrs: hdrs,
                    xhr: xhr_1,
                });
                if (qrys.length > 0) {
                    qrys.forEach(function (qry) {
                        xhr_1.url += xhr_1.url.indexOf('?') > 0 ? '&' : '?';
                        xhr_1.url += qry.name + '=' + qry.value;
                    });
                }
                laURL = xhr_1.url;
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        headers.push({
                            name: hdr.name,
                            value: hdr.value,
                        });
                    });
                }
                xhr_1.onload = function () {
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('License( xhr.status == ' + xhr_1.status + ' )', 3);
                    if (xhr_1.status == 200) {
                        onSuccess({
                            status: xhr_1.status,
                            req: xhr_1,
                            xhr: xhr_1,
                        });
                        xhr_1.keySession
                            .update(xhr_1.response)
                            .then(function () {
                            _this.stream.onKeyAdded();
                        })
                            .catch(function (_error) {
                            _this.NXDebug.info('session.update error');
                        });
                    }
                    else {
                        onError({
                            status: xhr_1.status,
                            req: xhr_1,
                            xhr: xhr_1,
                        });
                        //callback({status:"error", msg:'DRM: playready update, XHR status is "' + xhr.statusText + '" (' + xhr.status + '), expected to be 200. readyState is ' + xhr.readyState});
                    }
                };
                xhr_1.onabort = function () {
                    onError({
                        status: xhr_1.status,
                        req: xhr_1,
                        xhr: xhr_1,
                    });
                    //callback({status:"error", msg:'DRM: playready update, XHR aborted. status is "' + xhr.statusText + '" (' + xhr.status + '), readyState is ' + xhr.readyState});
                };
                xhr_1.onerror = function () {
                    onError({
                        status: xhr_1.status,
                        req: xhr_1,
                        xhr: xhr_1,
                    });
                    //callback({status:"error", msg:'DRM: playready update, XHR error. status is "' + xhr.statusText + '" (' + xhr.status + '), readyState is ' + xhr.readyState});
                };
                xhr_1.open('POST', xhr_1.url);
                xhr_1.responseType = 'arraybuffer';
                if (headers) {
                    ctypeIsSet = false;
                    headers.forEach(function (hdr) {
                        xhr_1.setRequestHeader(hdr.name, hdr.value);
                        if (hdr.name.toLowerCase() === 'content-type') {
                            ctypeIsSet = true;
                        }
                    });
                    if (!ctypeIsSet) {
                        xhr_1.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');
                    }
                }
                xhr_1.send(decodedChallenge);
            }
            else {
                var request_1 = {};
                var acon_1 = {
                    aborted: false,
                };
                var init_1 = {
                    method: 'POST',
                    headers: {},
                    credentials: 'same-origin',
                };
                request_1.keySession = event.target;
                request_1.url = laURL;
                onPrepare({
                    req: request_1,
                    qrys: qrys,
                    hdrs: hdrs,
                    xhr: request_1,
                });
                if (qrys.length > 0) {
                    qrys.forEach(function (qry) {
                        request_1.url += request_1.url.indexOf('?') > 0 ? '&' : '?';
                        request_1.url += qry.name + '=' + qry.value;
                    });
                }
                laURL = request_1.url;
                if (hdrs.length > 0) {
                    hdrs.forEach(function (hdr) {
                        headers.push({
                            name: hdr.name,
                            value: hdr.value,
                        });
                    });
                }
                if (headers) {
                    ctypeIsSet = false;
                    headers.forEach(function (hdr) {
                        init_1.headers[hdr.name] = hdr.value;
                        if (hdr.name.toLowerCase() === 'content-type') {
                            ctypeIsSet = true;
                        }
                    });
                    if (!ctypeIsSet) {
                        init_1.headers['Content-Type'] = 'text/xml; charset=utf-8';
                    }
                }
                init_1.body = decodedChallenge;
                fetch(request_1.url, init_1)
                    .then(function (res) {
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('License( res.status == ' + res.status + ' )', 3);
                    request_1.status = res.status;
                    if (res.ok == true) {
                        return res.arrayBuffer();
                    }
                    else {
                        return Promise.reject(new Error('res.false'));
                    }
                })
                    .then(function (ab) {
                    onSuccess({
                        status: request_1.status,
                        req: request_1,
                        xhr: request_1,
                    });
                    request_1.keySession
                        .update(ab)
                        .then(function () {
                        _this.stream.onKeyAdded();
                    })
                        .catch(function (_err) {
                        _this.NXDebug.info('session.update error');
                    });
                })
                    .then(function (_err) {
                    if (acon_1.aborted) {
                        _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('License Request aborted.', 3);
                        request_1.status = -1;
                    }
                    onError({
                        status: request_1.status,
                        req: request_1,
                        xhr: request_1,
                    });
                });
            }
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_DRM('Get License()<br>&nbsp;&nbsp;laURL ==> ' + laURL, 2);
        };
        this.licenseRequestReady_wv = function (event) {
            var self = _this;
            var bytes = new Uint8Array(event.message);
            //  laURL;
            var headers = [];
            var qrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'query')
                ? _this.xhrCustom['query'].concat()
                : [];
            var hdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'header')
                ? _this.xhrCustom['header'].concat()
                : [];
            var onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'onPrepare')
                ? _this.xhrCustom['onPrepare']
                : function () { };
            var onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'onSuccess')
                ? _this.xhrCustom['onSuccess']
                : function () { };
            var onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_4__.hasProperty)(_this.xhrCustom, 'onError')
                ? _this.xhrCustom['onError']
                : function () { };
            var xhr = new XMLHttpRequest();
            xhr.keySession = event.target;
            xhr.keysTypeString = event.target.keysTypeString;
            xhr.url = 'unknown';
            onPrepare({ req: xhr, qrys: qrys, hdrs: hdrs, xhr: xhr });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    xhr.url += xhr.url.indexOf('?') > 0 ? '&' : '?';
                    xhr.url += qry.name + '=' + qry.value;
                });
            }
            //laURL = xhr.url;
            if (hdrs.length > 0) {
                hdrs.forEach(function (hdr) {
                    headers.push({ name: hdr.name, value: hdr.value });
                });
            }
            xhr.onload = function () {
                self.logHandler.log_DRM('License( xhr.status == ' + xhr.status + ' )', 3);
                if (xhr.status == 200) {
                    onSuccess({ status: xhr.status, req: xhr, xhr: xhr });
                    xhr
                        .keySession.update(xhr.response)
                        .then(function () {
                        self.stream.onKeyAdded();
                    })
                        .catch(function ( /* error: any */) {
                        self.NXDebug.info('session.update error');
                    });
                }
                else {
                    onError({ status: xhr.status, req: xhr, xhr: xhr });
                }
            };
            xhr.onabort = function () {
                onError({ status: xhr.status, req: xhr, xhr: xhr });
            };
            xhr.onerror = function () {
                onError({ status: xhr.status, req: xhr, xhr: xhr });
            };
            xhr.open('POST', xhr.url);
            xhr.responseType = 'arraybuffer';
            xhr.send(bytes);
        };
        this.element = null;
        //NSV-a keySystems = [],
        this.kids = [];
        this.keySystemDescs = null;
        this.xhrCustom = null;
        this.protectionExt = null;
        this.stream = null;
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.useFetch = false;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.eventBus = eventBus;
        this.checkList = [
            {
                schemeIdUri: 'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',
                keysTypeString: 'com.microsoft.playready',
            },
            {
                schemeIdUri: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',
                keysTypeString: 'com.widevine.alpha',
            },
            {
                schemeIdUri: 'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b',
                keysTypeString: 'org.w3.clearkey',
            },
        ];
    }
    // setup(): void {
    //   //NSV-a keySystems = protectionExt.getKeySystems();
    //   this.element = this.videoModel!.getElement();
    // }
    ProtectionModelRMKSA.prototype.init = function (v, strm, xhrCustom, prefix) {
        this.videoModel = v;
        this.element = v.getElement();
        this.xhrCustom = xhrCustom;
        this.keySystemDescs = this.getSystems.call(this);
        this.stream = strm;
        try {
            this.protectionExt = new _ProtectionExtensions__WEBPACK_IMPORTED_MODULE_3__.ProtectionExtensions({}, this.eventBus);
        }
        catch (e) {
            this.logHandler.log(e);
        }
        this.protectionExt.init(this.element, prefix);
        //NSV-a keySystems = protectionExt.getKeySystems();
    };
    ProtectionModelRMKSA.prototype.listenToEncrypted = function (listener) {
        this.videoModel.listen('encrypted', listener);
    };
    ProtectionModelRMKSA.prototype.listenToKeyAdded = function (listener) {
        this.protectionExt.listenToKeyAdded(this.element, listener);
    };
    ProtectionModelRMKSA.prototype.listenToKeyError = function (listener) {
        this.protectionExt.listenToKeyError(this.element, listener);
    };
    ProtectionModelRMKSA.prototype.unlistenToEncrypted = function (listener) {
        this.videoModel.unlisten('encrypted', listener);
    };
    ProtectionModelRMKSA.prototype.unlistenToKeyAdded = function (listener) {
        this.protectionExt.unlistenToKeyAdded(this.element, listener);
    };
    ProtectionModelRMKSA.prototype.unlistenToKeyError = function (listener) {
        this.protectionExt.unlistenToKeyError(this.element, listener);
    };
    ProtectionModelRMKSA.prototype.reset = function () {
        this.kids = [];
    };
    return ProtectionModelRMKSA;
}());



/***/ }),

/***/ "./ts/dash/streaming/AbrController.ts":
/*!********************************************!*\
  !*** ./ts/dash/streaming/AbrController.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbrController": function() { return /* binding */ AbrController; },
/* harmony export */   "getAverageDownloadRate": function() { return /* binding */ getAverageDownloadRate; },
/* harmony export */   "getInternalConfidence": function() { return /* binding */ getInternalConfidence; },
/* harmony export */   "getInternalQuality": function() { return /* binding */ getInternalQuality; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * AbrController
 *
 * @module AbrController（AbrControllerモジュール）
 */
var NO_CHANGE = 0;
var SWITCH_DOWN = 1;
var SWITCH_UP = 2;
var NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
var getInternalQuality = function (qualityDict, type) {
    var quality;
    if (!(0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(qualityDict, type)) {
        qualityDict[type] = 0;
    }
    quality = qualityDict[type];
    return quality;
};
var getInternalConfidence = function (confidenceDict, type) {
    var confidence;
    if (!(0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(confidenceDict, type)) {
        confidenceDict[type] = 0;
    }
    confidence = confidenceDict[type];
    return confidence;
};
//NSV-a const getAverageDownloadRatio = (averageDownloadRatio, type, value) => {
//NSV-a   if (!utils.hasProperty(averageDownloadRatio, type)) {
//NSV-a     averageDownloadRatio[type] = value;
//NSV-a   } else {
//NSV-a     averageDownloadRatio[type] =
//NSV-a       0.75 * averageDownloadRatio[type] + 0.25 * value;
//NSV-a   }
//NSV-a   return averageDownloadRatio[type];
//NSV-a };
var getAverageDownloadRate = function (averageDownloadRate, type, value) {
    if (!(0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(averageDownloadRate, type)) {
        averageDownloadRate[type] = value;
    }
    else {
        averageDownloadRate[type] = 0.75 * averageDownloadRate[type] + 0.25 * value;
    }
    return averageDownloadRate[type];
};
/* istanbul ignore next */
var checkDownloadRatio = function (current, metrics, data, level, lastRequest, lastCheckedRequest, downloadRateList, downloadDiffList, _averageDownloadRatio, averageDownloadRate, minBufferTime, aborted, _stalled) {
    // eslint-disable-line no-unused-vars
    var totalTime;
    var downloadRatio;
    var totalRatio;
    var DOWNLOAD_RATIO_SAFETY_FACTOR = 0.9;
    var decideTarget = false;
    var c;
    if (!metrics) {
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    if (lastRequest === null) {
        NXDebug.log('No requests made for this stream yet, bailing.');
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    else if (lastRequest === lastCheckedRequest[data.type]) {
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    else {
        lastCheckedRequest[data.type] = lastRequest;
    }
    totalTime = (lastRequest.tfinish - lastRequest.trequest) / 1000;
    if (totalTime <= 0) {
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    var dlrate = ((8 * lastRequest.size) / totalTime) * DOWNLOAD_RATIO_SAFETY_FACTOR;
    getAverageDownloadRate(averageDownloadRate, data.type, dlrate);
    if (downloadRateList[data.type].length > 2) {
        downloadRateList[data.type].shift();
    }
    downloadRateList[data.type].push(dlrate);
    if (downloadDiffList[data.type].length > 2) {
        downloadDiffList[data.type].shift();
    }
    if (lastRequest.code == 408) {
        downloadDiffList[data.type].push(-totalTime);
    }
    else {
        downloadDiffList[data.type].push(lastRequest.mediaduration - totalTime);
    }
    if (level === undefined) {
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    if (lastRequest.mediaduration === null ||
        lastRequest.mediaduration === undefined ||
        lastRequest.mediaduration <= 0 ||
        isNaN(lastRequest.mediaduration)) {
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    totalRatio =
        lastRequest.code != 408 ? lastRequest.mediaduration / totalTime : 0.1;
    downloadRatio = totalRatio * DOWNLOAD_RATIO_SAFETY_FACTOR;
    if (isNaN(downloadRatio) || isNaN(totalRatio)) {
        NXDebug.log('The ratios are NaN, bailing.');
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    var r = level < lastRequest.mediaduration * 1.5 || downloadRatio < 1.0 ? 1.5 : 1.0;
    if (isNaN(downloadRatio)) {
        return {
            idx: current,
            switchTo: NO_CHANGE,
        };
    }
    else if (downloadRatio < 1.0) {
        if (level < lastRequest.mediaduration) {
            return {
                idx: 0,
                switchTo: SWITCH_DOWN,
            };
        }
        if (dlrate < data.representations[current].bandwidth * r) {
            if (current > 0) {
                decideTarget = false;
                for (c = current - 1; c >= 0; c--) {
                    if (dlrate >= data.representations[c].bandwidth * r) {
                        decideTarget = true;
                        return {
                            idx: c,
                            switchTo: SWITCH_DOWN,
                        };
                    }
                }
                if (!decideTarget) {
                    return {
                        idx: 0,
                        switchTo: SWITCH_DOWN,
                    };
                }
            }
            else {
                return {
                    idx: 0,
                    switchTo: NO_CHANGE,
                };
            }
        }
        else {
            var diff = 0;
            for (var i = 0; i < downloadDiffList[data.type].length; i++) {
                diff += downloadDiffList[data.type][i];
            }
            if (aborted) {
                return {
                    idx: Math.max(current - 2, 0),
                    switchTo: SWITCH_DOWN,
                };
            }
            else if (diff < 0 && level < lastRequest.mediaduration * 2) {
                return {
                    idx: Math.max(current - 1, 0),
                    switchTo: SWITCH_DOWN,
                };
            }
            else {
                return {
                    idx: current,
                    switchTo: NO_CHANGE,
                };
            }
        }
    }
    else {
        var noChange = false;
        if (level < minBufferTime) {
            var bw = data.representations[current].bandwidth * r;
            for (var i = 0; i < downloadRateList[data.type].length; i++) {
                if (downloadRateList[data.type][i] < bw) {
                    noChange = true;
                    break;
                }
            }
        }
        var max = data.representations.length;
        if (noChange) {
            return {
                idx: current,
                switchTo: NO_CHANGE,
            };
        }
        else if (current < max) {
            decideTarget = false;
            for (c = current; c < max; c++) {
                if (dlrate < data.representations[c].bandwidth * r) {
                    decideTarget = true;
                    if (c == current + 1) {
                        return {
                            idx: c - 1,
                            switchTo: NO_CHANGE,
                        };
                    }
                    else {
                        return {
                            idx: c - 1,
                            switchTo: SWITCH_UP,
                        };
                    }
                }
            }
            if (!decideTarget) {
                return {
                    idx: max - 1,
                    switchTo: SWITCH_UP,
                };
            }
        }
        else {
            return {
                idx: current,
                switchTo: NO_CHANGE,
            };
        }
    }
    return null;
};
var AbrController = /** @class */ (function () {
    function AbrController() {
        this.autoSwitchBitrate = true;
        this.qualityDict = {};
        this.defaultQualityDict = {
            video: 0,
            audio: 0,
        };
        this.averageDownloadRatio = {};
        this.averageDownloadRate = {};
        this.confidenceDict = {};
        this.maxQualityIndexDict = {};
        this.minBufferTime = 4;
        this.lastCheckedRequest = {
            video: null,
            audio: null,
        };
        this.downloadRateList = {
            video: [],
            audio: [],
        };
        this.downloadDiffList = {
            video: [],
            audio: [],
        };
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    AbrController.prototype.getAutoSwitchBitrate = function () {
        return this.autoSwitchBitrate;
    };
    AbrController.prototype.setAutoSwitchBitrate = function (value) {
        this.autoSwitchBitrate = value;
    };
    /* istanbul ignore next */
    AbrController.prototype.getPlaybackQuality = function (type, data, metrics, level, aborted, stalled) {
        var values;
        var quality;
        var confidence;
        quality = getInternalQuality(this.qualityDict, type);
        confidence = getInternalConfidence(this.confidenceDict, type);
        if (this.autoSwitchBitrate) {
            values = checkDownloadRatio(quality, metrics, data, level, metrics.getCurrentRevisedHttpRequest(), this.lastCheckedRequest, this.downloadRateList, this.downloadDiffList, this.averageDownloadRatio, this.averageDownloadRate, this.minBufferTime, aborted, stalled);
            if (values != null) {
                if (values.idx < 0)
                    values.idx = 0;
                this.qualityDict[type] = values.idx;
                this.confidenceDict[type] = values.switchTo;
                return {
                    quality: values.idx,
                    confidence: values.switchTo,
                };
            }
            else {
                return {
                    quality: quality,
                    confidence: confidence,
                };
            }
        }
        else {
            //NXDebug.debug(type + " Unchanged quality of " + quality);
            return {
                quality: quality,
                confidence: confidence,
            };
        }
    };
    /* istanbul ignore next */
    AbrController.prototype.setPlaybackQuality = function (type, newPlaybackQuality) {
        var quality = getInternalQuality(this.qualityDict, type);
        if (newPlaybackQuality !== quality) {
            this.qualityDict[type] = newPlaybackQuality;
        }
    };
    /* istanbul ignore next */
    AbrController.prototype.getQualityFor = function (type) {
        return getInternalQuality(this.qualityDict, type);
    };
    AbrController.prototype.setDefaultPlaybackQuality = function (type, quality) {
        this.defaultQualityDict[type] = quality;
    };
    AbrController.prototype.getDefaultQualityFor = function (type) {
        return this.defaultQualityDict[type];
    };
    AbrController.prototype.setMaxQualityIndex = function (type, max) {
        this.maxQualityIndexDict[type] = max - 1;
        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(this.qualityDict, type)) {
            if (this.qualityDict[type] > max - 1) {
                this.qualityDict[type] = max - 1;
            }
        }
    };
    // getDownloadDiffFor(type: string): number {
    //   let ret: number = 0;
    //   const len: number = this.downloadDiffList[type].length;
    //   if (len == 0) {
    //     return NaN;
    //   } else {
    //     for (let i = 0; i < len; i++) {
    //       ret += this.downloadDiffList[type][i];
    //     }
    //     return ret;
    //   }
    // }
    AbrController.prototype.getMaxQualityIndexFor = function (type) {
        return (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(this.maxQualityIndexDict, type)
            ? this.maxQualityIndexDict[type]
            : 0;
    };
    AbrController.prototype.setMinBufferTime = function (time) {
        this.minBufferTime = time;
    };
    // getAverageDownloadRatio(type: string): number {
    //   return hasProperty(this.averageDownloadRatio, type)
    //     ? this.averageDownloadRatio[type]
    //     : 0;
    // }
    AbrController.prototype.getAverageDownloadRate = function (type) {
        return (0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(this.averageDownloadRate, type)
            ? this.averageDownloadRate[type]
            : 0;
    };
    AbrController.prototype.matchingQualityBetweenDifferentAdaptation = function (from, to) {
        if (from === to)
            return;
        NXDebug.debug('********* matchingQualityBetweenDifferentAdaptation *********');
        var current = getInternalQuality(this.qualityDict, from.type);
        var next = 0;
        var bandwidth = from.representations[current].bandwidth;
        var dlrate = this.getAverageDownloadRate(from.type);
        var th = Math.max(dlrate, bandwidth * 1.1);
        this.setMaxQualityIndex(to.type, to.representations.length);
        for (var i = to.representations.length - 1; i >= 0; i--) {
            if (to.representations[i].bandwidth <= th) {
                next = i;
                break;
            }
        }
        NXDebug.debug('[' +
            from.type +
            '] from:[' +
            current +
            ']:' +
            bandwidth +
            ',' +
            'to:[' +
            next +
            ']:' +
            to.representations[next].bandwidth +
            ', averageDownloadRate:' +
            dlrate);
        this.setPlaybackQuality(from.type, next);
    };
    return AbrController;
}());



/***/ }),

/***/ "./ts/dash/streaming/BufferController.ts":
/*!***********************************************!*\
  !*** ./ts/dash/streaming/BufferController.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BufferController": function() { return /* binding */ BufferController; }
/* harmony export */ });
/* harmony import */ var _StreamController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StreamController */ "./ts/dash/streaming/StreamController.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



/**
 * BufferController
 *
 * @module BufferController（BufferControllerモジュール）
 */
var MSE_ver = function (buffer) {
    var ver = '';
    try {
        ver =
            ver +
                ('append' in buffer
                    ? '<span style="color:#e7527d">append</span>'
                    : '<span style="color:#808080">append</span>');
        ver =
            ver +
                ' ' +
                ('appendBuffer' in buffer
                    ? '<span style="color:#e7527d">appendBuffer</span>'
                    : '<span style="color:#808080">appendBuffer</span>');
    }
    catch (err) {
        ver = 'err';
    }
    _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"].log_item('MSE_ver', 'MSE: ' + ver);
    return ver;
};
/**
 * BufferController
 * @constructor
 */
var BufferController = /** @class */ (function () {
    function BufferController() {
        var _this = this;
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.setState = function (value) {
            _this.state = value;
            if (_this.fragmentModel !== null) {
                if (_this.state === _this.READY) {
                    if (_this.type == 'video') {
                        var ln = _this.fragmentModel.getLoadingRequests();
                        if (ln.length == 0) {
                            _this.fragmentModel.executeCurrentRequest();
                        }
                    }
                    else {
                        _this.fragmentModel.executeCurrentRequest();
                    }
                }
            }
        };
        this.clearPlayListTraceMetrics = function (endTime, stopreason) {
            var duration = 0;
            var startTime = null;
            if (_this.playListTraceMetricsClosed === false &&
                _this.playListTraceMetrics) {
                startTime = _this.playListTraceMetrics.start;
                duration = endTime.getTime() - startTime.getTime();
                _this.playListTraceMetrics.duration = duration;
                _this.playListTraceMetrics.stopreason = stopreason;
                _this.playListTraceMetricsClosed = true;
            }
        };
        this.setBufferState = function (actLen, reqLen) {
            var value = 0;
            if (_this.minBufferTime)
                if (actLen < _this.minBufferTime) {
                    value = 1;
                }
                else if (actLen >= _this.minBufferTime && actLen < reqLen) {
                    value = 2;
                }
                else if (actLen >= reqLen) {
                    value = 3;
                }
            //NSV-a    else {
            //NSV-a    }
            if (_this.bufferState != value && _this.eventBus) {
                _this.bufferState = value;
                _this.eventBus.dispatchEvent({
                    type: 'bufferStateChangeInt',
                    data: {
                        type: _this.type,
                        state: _this.bufferState,
                    },
                });
            }
        };
        this.startScheduling = function (func) {
            var self = _this;
            if (_this.requestScheduler) {
                clearInterval(_this.requestScheduler);
            }
            _this.requestScheduler = setInterval(func.bind(self), _this.SCHEDULE_EXECUTE_INTERVAL);
            _this.isScheduled = true;
            func.call(self);
        };
        this.stopScheduling = function () {
            if (_this.requestScheduler) {
                clearInterval(_this.requestScheduler);
                _this.requestScheduler = null;
            }
            _this.isScheduled = false;
        };
        this.startPlayback = function () {
            if (!_this.ready || !_this.started) {
                return;
            }
            _this.setState.call(_this, _this.READY);
            _this.startScheduling.call(_this, _this.validate);
        };
        this.start = function (val) {
            var currentTime;
            _this.isStreamCompleted = false;
            if (_this.isScheduled) {
                _this.stopScheduling.call(_this);
            }
            if (_this.seeking === false && _this.metrics && _this.type) {
                currentTime = new Date();
                _this.clearPlayListTraceMetrics(currentTime, _this.USER_REQUEST_STOP_REASON);
                _this.playListMetrics = _this.metrics.addPlayList(_this.type, currentTime, 0, _this.INITIAL_PLAY_START_REASON);
            }
            _this.NXDebug.debug('[' + _this.type + '] BufferController start.' + val);
            _this.started = true;
            _this.updateBufferLevel.call(_this);
            if (!_this.waitingForBuffer && _this.bufferLevel <= _this.STALL_THRESHOLD) {
                _this.waitingForBuffer = true;
                _this.bufferStartThreshold = Math.min(_this.minBufferTime || _this.DEFAULT_MIN_BUFFER_TIME, _this.getTimeToEnd.call(self));
            }
            _this.startPlayback.call(_this);
        };
        /* istanbul ignore next */
        this.checkQ = function (_seekTarget) {
            var self = _this;
            var curTime;
            var q;
            var i;
            if (!_this.buffer)
                return;
            if (!_this.playbackStarted) {
                if (_this.videoModel.isDummy()) {
                    curTime = _this.videoModel.getCurrentTime();
                    for (i = 0; i < _this.buffer.queue.length; i++) {
                        q = _this.buffer.queue[i];
                        if (curTime >= q.time && curTime < q.time + q.dur)
                            break;
                    }
                    while (i > 1) {
                        //0??
                        _this.buffer.queue.shift();
                        i--;
                    }
                }
                else {
                    return;
                }
            }
            var ld = _this.fragmentModel.getLoadingRequests();
            for (var i_1 = ld.length - 1; i_1 >= 0; i_1--) {
                if (!ld[i_1].keep) {
                    var rs = ld[i_1].startTime;
                    ld.splice(i_1, 1);
                    _this.fragmentModel.abortRequestForTime(rs);
                }
            }
            _this.cancelPendingRequests.call(self, _this.type, _this.NOCHANGE, 1);
            _this.fragmentModel.removeAllExecutedRequests();
            var clearQ = true;
            if (_this.videoModel)
                curTime = _this.videoModel.getCurrentTime();
            if (_this.buffer.queue.length > 0) {
                var range = _this.sourceBufferExt.getBufferRange(_this.buffer, curTime, _this.tolerance);
                var btime = range != null ? range.end : curTime;
                var bqsTime = _this.buffer.queue[0].time - 0.1;
                var bqeTime = _this.buffer.queue[_this.buffer.queue.length - 1].time +
                    _this.buffer.queue[_this.buffer.queue.length - 1].dur +
                    0.1;
                if ((!_this.playbackStarted &&
                    _this.BUFFER_PREFETCH_THRESHOLD &&
                    btime < bqsTime &&
                    bqsTime - btime < _this.BUFFER_PREFETCH_THRESHOLD) ||
                    (bqsTime <= btime && btime < bqeTime)) {
                    //NXDebug.log("buffer queue will be used. btime:"+btime+", bqsTime:"+bqsTime+", bqeTime:"+bqeTime);
                    for (var i_2 = _this.buffer.queue.length - 1; i_2 >= 0; i_2--) {
                        var s = _this.buffer.queue[i_2].time;
                        if (s - btime > _this.BUFFER_PREFETCH_THRESHOLD) {
                            var dn = void 0;
                            q = _this.buffer.queue.pop();
                            dn = q.divNum;
                            q = void 0;
                            while (dn > 0) {
                                var qt = _this.buffer.queue.pop();
                                dn = qt.divNum;
                                qt = void 0;
                                i_2--;
                            }
                        }
                    }
                    clearQ = false;
                }
                else {
                    //NXDebug.log("clear buffer queue");
                }
            }
            if (clearQ) {
                _this.buffer.queue = [];
                _this.buffer.lastAppendtime = -1;
                _this.preAppendTime = -1;
            }
            _this.buffer.laData = null;
        };
        /* istanbul ignore next */
        this.seek = function (time, msg) {
            var currentTime;
            var self = _this;
            var curTime;
            var dataView;
            var ud;
            _this.isStreamCompleted = false;
            _this.seeking = true;
            _this.seekTarget =
                _this.type == 'audio' && _this.isSegmentTemplate == true && _this.periodInfo
                    ? Math.max(time - 1, _this.periodInfo.start)
                    : time;
            _this.setIncrementalMode.call(self, false, 1);
            currentTime = new Date();
            _this.clearPlayListTraceMetrics(currentTime, _this.USER_REQUEST_STOP_REASON);
            if (_this.metrics && _this.type)
                _this.playListMetrics = _this.metrics.addPlayList(_this.type, currentTime, _this.seekTarget, _this.SEEK_START_REASON);
            _this.NXDebug.debug('[' +
                _this.type +
                '] BufferController seek: ' +
                time +
                ', bufferLevel: ' +
                _this.bufferLevel +
                ',' +
                msg);
            _this.updateBufferLevel.call(self);
            curTime = _this.videoModel.getCurrentTime();
            if (!_this.buffer)
                return;
            if (!_this.stalled) {
                _this.bufferStartThreshold = Math.min(_this.minBufferTime || _this.DEFAULT_MIN_BUFFER_TIME, _this.getTimeToEnd.call(self));
                if (_this.videoModel && _this.videoModel.isPaused()) {
                    _this.stalled = true;
                    _this.waitingForBuffer = true;
                    _this.stallStream.call(self, _this.stalled, 0);
                    if (_this.bufferLevel < _this.bufferStartThreshold) {
                        if (_this.abrController &&
                            _this.abrController.getAutoSwitchBitrate() &&
                            _this.type) {
                            _this.abrController.setPlaybackQuality(_this.type, _this.abrController.getDefaultQualityFor(_this.type));
                        }
                    }
                }
                else {
                    if (_this.seekTarget < curTime) {
                        var blen = _this.sourceBufferExt.getBufferLength(_this.buffer, curTime, _this.tolerance);
                        if (blen > 0) {
                            _this.seeking = false;
                        }
                    }
                    else {
                        // eslint-disable-line no-empty
                    }
                }
            }
            if (_this.seeking)
                _this.loadFirstSegmentRequestAfterSeek(_this.seekTarget);
            if (_this.bDatInsertMode && _this.buffer.updating === undefined) {
                for (var i = _this.buffer.buffered.length - 1; i >= 0; i--) {
                    if (_this.buffer.buffered.start(i) > curTime + 0.5) {
                        if (_this.buffer.buffered.end(i) - _this.buffer.buffered.start(i) <
                            1.5) {
                            // eslint-disable-line no-empty
                        }
                        else {
                            var remTime = _this.buffer.buffered.start(i) - 0.3;
                            if (_this.getMSEDuration.call(self) - remTime < 20)
                                continue;
                            if (remTime < 0)
                                remTime = 0;
                            dataView = new DataView(_this.dmyData);
                            if (_this.type === 'video') {
                                if (!_this.isProtection) {
                                    dataView.setUint32(846 + 20, 30000 * remTime);
                                    dataView.setUint32(938 + 12, 30000 * remTime);
                                    dataView.setUint32(25306 + 20, 30000 * remTime); // 0.5s
                                    dataView.setUint32(25398 + 12, 30000 * remTime); // 0.5s
                                }
                                else {
                                    dataView.setUint32(1624 + 20, 30000 * remTime);
                                    dataView.setUint32(1716 + 12, 30000 * remTime);
                                    dataView.setUint32(42809 + 20, 30000 * remTime); // 0,5s
                                    dataView.setUint32(42901 + 12, 30000 * remTime); // 0.5s
                                }
                            }
                            else {
                                if (!_this.isProtection) {
                                    // eslint-disable-line no-empty
                                }
                                else {
                                    // eslint-disable-line no-empty
                                }
                            }
                            _this.buffer.timestampOffset = 0;
                            if (_this.buffer.updating === undefined) {
                                ud = new Uint8Array(_this.dmyData);
                                _this.buffer.append(ud);
                            }
                            else {
                                _this.buffer.appendBuffer(_this.dmyData);
                            }
                            _this.buffer.quality = -1;
                            break;
                        }
                    }
                }
                //checkQ.call(self,seekTarget);
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] BufferController  seek: ' +
                    time +
                    ', bufferLevel: ' +
                    _this.bufferLevel +
                    ', qlen:' +
                    _this.buffer.queue.length);
                _this.start.call(self, '11111');
            }
            else if ('remove' in _this.buffer && _this.buffer.updating !== undefined) {
                if (_this.periodInfo &&
                    _this.buffer.buffered.length > 0 &&
                    (curTime + 30 <
                        _this.buffer.buffered.end(_this.buffer.buffered.length - 1) ||
                        _this.periodInfo.end <
                            _this.buffer.buffered.end(_this.buffer.buffered.length - 1))) {
                    var end_1 = _this.buffer.buffered.end(_this.buffer.buffered.length - 1);
                    _this.sourceBufferExt.waitForUpdateEnd(_this.buffer, function () {
                        var blen = _this.sourceBufferExt.getBufferLength(_this.buffer, curTime, _this.tolerance) + 0.5;
                        _this.sourceBufferExt.remove(_this.buffer, Math.min(curTime + Math.max(blen, 30), _this.periodInfo.end), end_1, _this.periodInfo.duration, _this.mediaSource, function () {
                            //incrementalMode=false;
                            _this.NXDebug.debug('[' +
                                _this.type +
                                '] BufferController  seek: ' +
                                time +
                                ', bufferLevel: ' +
                                _this.bufferLevel +
                                ', qlen:' +
                                _this.buffer.queue.length);
                            _this.start.call(self, '11111-');
                        });
                    });
                }
                else {
                    _this.NXDebug.debug('[' +
                        _this.type +
                        '] BufferController  seek: ' +
                        time +
                        ', bufferLevel: ' +
                        _this.bufferLevel +
                        ', qlen:' +
                        _this.buffer.queue.length);
                    _this.start.call(self, '11111+');
                }
            }
            else {
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] BufferController  seek: ' +
                    time +
                    ', bufferLevel: ' +
                    _this.bufferLevel);
                _this.start.call(self, '11111');
            }
        };
        this.stop = function () {
            if (_this.state === _this.WAITING)
                return;
            _this.NXDebug.debug('[' + _this.type + '] BufferController stop.');
            _this.setState.call(_this, _this.isBufferingCompleted ? _this.READY : _this.WAITING);
            _this.stopScheduling.call(_this);
            _this.started = false;
            _this.clearPlayListTraceMetrics(new Date(), _this.USER_REQUEST_STOP_REASON);
        };
        this.setIncrementalMode = function (value, _loc) {
            _this.incrementalMode = value;
        };
        this.stallStream = function (isStalled, _value) {
            if (_this.STORE_MEASURED_DATA) {
                if (isStalled) {
                    _this.metrics.addBufferingEvent(new Date().getTime(), 0, _this.videoModel.getCurrentTime());
                }
                else {
                    _this.metrics.addBufferingEvent(new Date().getTime(), 1, _this.videoModel.getCurrentTime());
                }
            }
            _this.videoModel.stallStream(_this.type, isStalled);
        };
        this.getRepresentationForQuality = function (quality) {
            return _this.availableRepresentations[quality];
        };
        //NSV-a  const setRepresentationTimeOffset = (offset) => {
        //NSV-a    for (let i = 0; i < availableRepresentations.length; i++) {
        //NSV-a      const pto = availableRepresentations[i].presentationTimeOffset;
        //NSV-a      availableRepresentations[i].presentationTimeOffset = offset + pto;
        //NSV-a    }
        //NSV-a  };
        this.cancelPendingRequests = function (type, flagnum, loc) {
            var flag = flagnum || _this.RESET;
            var index = -1;
            if (flag == _this.UPDATE) {
                var pen = _this.fragmentModel.getPendingRequests();
                index = -1;
                flag = _this.NOCHANGE;
                for (var i = 0; i < pen.length; i++) {
                    if (!pen[i].keep &&
                        pen[i].periodIdx == _this.periodInfo.index &&
                        pen[i].adaptationIdx == _this.currentAdaptation.index) {
                        index = pen[i].index;
                        if (index > 0)
                            index -= 1;
                        flag = _this.UPDATE;
                        break;
                    }
                }
            }
            _this.fragmentModel.cancelPendingRequests();
            if (flag != _this.NOCHANGE) {
                _this.indexHandler.setupRequestStatus(type, index, loc);
            }
        };
        this.clearAllSegments = function () {
            var reps = _this.currentAdaptation.representations;
            for (var i = 0; i < reps.length; i++) {
                reps[i].segments = null;
            }
        };
        this.abortOnGoingRequests = function () {
            _this.fragmentModel.abortRequests(true);
        };
        /* istanbul ignore next */
        this.checkLoadingRequests = function (type, totalBufferLevel) {
            var self = _this;
            var aborted = false;
            if (_this.fragmentModel != null) {
                var requests = _this.fragmentModel.getLoadingRequests();
                if (requests.length > 0) {
                    for (var i = 0; i < requests.length; i++) {
                        var request = requests[i];
                        var now = new Date().getTime();
                        var loadingTime = (now - request.requestStartTime) / 1000;
                        var abortThreshold = (totalBufferLevel > request.duration * 3
                            ? request.duration * 2
                            : request.duration * 1.2) *
                            ((request.quality == 0 ? 1 : 0) + 1);
                        if (loadingTime > abortThreshold) {
                            if (request.quality !== 0 || !request.aborted) {
                                _this.NXDebug.info('[' +
                                    type +
                                    ']============= This request should be aborted. ================' +
                                    requests.length);
                                _this.logHandler.log('[' +
                                    i +
                                    '/' +
                                    requests.length +
                                    '][' +
                                    _this.buffer.type +
                                    ']abort time:' +
                                    request.startTime +
                                    ',q: ' +
                                    request.quality +
                                    ', diff:' +
                                    (now - request.requestStartTime) / 1000 +
                                    ',request.aborted:' +
                                    request.aborted);
                                aborted = true;
                                break;
                            }
                        }
                        else if (loadingTime > request.duration && request.quality !== 0) {
                            _this.fragmentModel.setRestrictMultiLoad(true);
                        }
                    }
                    if (aborted) {
                        var sts = [];
                        for (var i = 0; i < requests.length; i++) {
                            sts.push({
                                startTime: requests[i].startTime,
                                representation: requests[i].representation,
                            });
                            if (_this.useFetch)
                                _this.checkRemoveQForTime.call(self, requests[i].startTime);
                        }
                        _this.fragmentModel.abortRequests(false);
                        _this.cancelPendingRequests.call(_this, type, _this.RESET, 2);
                        for (var i = 0; i < sts.length; i++) {
                            var q = _this.abrController.getPlaybackQuality(type, sts[i].representation.adaptation, _this.metrics, totalBufferLevel, aborted, _this.stalled);
                            _this.indexHandler.getSegmentRequestForTime(sts[i].representation.adaptation.representations[q.quality], sts[i].startTime, type, 5, function (d) {
                                var request;
                                if (d.status === 'ok') {
                                    if (d.data) {
                                        request = d.data;
                                        if (request != null) {
                                            request.keep = true;
                                            request.aborted = true;
                                            if (!_this.fragmentController.isFragmentLoadingOrPending(self, request)) {
                                                _this.fragmentModel.addRequest(request);
                                            }
                                        }
                                    }
                                }
                                else {
                                    request = null;
                                }
                            });
                        }
                    }
                }
            }
            return aborted;
        };
        this.finishValidation = function () {
            var self = _this;
            if (_this.state === _this.LOADING) {
                _this.setState.call(self, _this.READY);
            }
        };
        this.onBytesLoadingStart = function (request) {
            if (_this.fragmentController.isInitializationRequest(request)) {
                _this.setState.call(_this, _this.READY);
            }
            else {
                _this.setState.call(_this, _this.LOADING);
                var self_1 = _this;
                if (!_this.hasData())
                    return;
                _this.setState.call(self_1, _this.READY);
                if (_this.fragmentController.needToPrepareNewRequest(self_1)) {
                    _this.getPlaybackQuality.call(self_1);
                    _this.requestNewFragment.call(self_1);
                }
            }
        };
        this.onBytesLoaded = function (request, response) {
            if (_this.type === 'video') {
                var totalBufferLevel = _this.bufferLevel +
                    _this.sourceBufferExt.dataQduration(_this.buffer, _this.isSegmentTemplate);
                if ((request.requestEndTime - request.requestStartTime) / 1000 >
                    request.duration &&
                    totalBufferLevel < 10) {
                    _this.cancelPendingRequests.call(_this, _this.type, _this.UPDATE, 3);
                }
            }
            if (request.canceled) {
                _this.fragmentModel.removeExecutedRequest(request);
                return;
            }
            if (_this.fragmentController.isInitializationRequest(request)) {
                _this.onInitializationLoaded.call(_this, request, response);
            }
            else {
                _this.onMediaLoaded.call(_this, request, response);
            }
        };
        this.onFirstChunkLoaded = function (req) {
            var quality = req.quality;
            var index = req.index;
            var startTime = req.startTime;
            var dur = req.duration;
            var offset = req.MSETimeOffset;
            var curRep = req.representation;
            var curAset = curRep.adaptation;
            var asetIdx = req.adaptationIdx;
            var pStart = curAset.period.start;
            var initData = _this.initializationData[pStart][curAset.index][quality];
            var q = _this.sourceBufferExt.append(_this.buffer, null, initData, startTime, startTime, dur, pStart, offset, _this.minBufferTime, quality, asetIdx, 0, index);
            return q;
        };
        /* istanbul ignore next */
        this.onChunkLoaded = function (done, q, _in) {
            var self = _this;
            var chunk = {};
            //let tmplen: number;
            if (done) {
                q.done = true;
                if (q.chunks.length > 0) {
                    q.dur =
                        q.chunks[q.chunks.length - 1].dur +
                            (q.chunks[q.chunks.length - 1].start - q.time);
                }
            }
            else {
                var data = void 0;
                var pos = void 0;
                var cur = 0;
                var len = 0;
                var tmplen_1 = 0;
                q.progress.push(_in);
                q.progress.forEach(function (r) {
                    tmplen_1 += r.length;
                });
                if (q.chunkEnd > tmplen_1) {
                    return;
                }
                pos = _this.indexHandler.extractChunk(q, tmplen_1, _this.periodInfo.inEventList, _this.type);
                if (pos.curChunkEnd == 0) {
                    q.chunkEnd = pos.nextChunkEnd;
                    q.chunkStartTime = pos.nextChunkStartTime;
                    q.chunkDur = pos.nextChunkDur;
                    return;
                }
                else {
                    data = new Uint8Array(pos.curChunkEnd);
                    for (var i = 0; i < q.progress.length; i++) {
                        var clen = q.progress[i].length;
                        len += clen;
                        if (len <= pos.curChunkEnd) {
                            data.set(q.progress[i], cur);
                            cur += clen;
                            if (len == pos.curChunkEnd) {
                                q.progress = [];
                                q.chunkEnd = pos.nextChunkEnd;
                                q.chunkStartTime = pos.nextChunkStartTime;
                                q.chunkDur = pos.nextChunkDur;
                                break;
                            }
                        }
                        else {
                            var sa1 = q.progress[i].subarray(0, clen - (len - pos.curChunkEnd));
                            var sa2 = q.progress[i].subarray(clen - (len - pos.curChunkEnd), clen);
                            data.set(sa1, cur);
                            q.progress = [sa2];
                            q.chunkEnd =
                                pos.nextChunkEnd > 0 ? pos.nextChunkEnd - pos.curChunkEnd : 0;
                            q.chunkStartTime = pos.nextChunkStartTime;
                            q.chunkDur = pos.nextChunkDur;
                            break;
                        }
                    }
                }
                chunk.data = data;
                chunk.start = pos.curChunkStartTime;
                chunk.dur = pos.curChunkDur;
                if (!q.appending && q.chunks.length == 0) {
                    q.time = chunk.start;
                }
                q.chunks.push(chunk);
            }
            //appendFromBufferQForAB.call(self);
            _this.appendFromBufferQ.call(self);
        };
        this.onChunkLoadedError = function (q) {
            var idx = _this.buffer.queue.indexOf(q);
            if (idx > -1) {
                _this.buffer.queue.splice(idx, 1);
            }
            q = null;
            return;
        };
        /* istanbul ignore next */
        this.onMediaLoaded = function (request, data) {
            var self = _this;
            var curRep = request.representation;
            var path = request.url.split('/');
            _this.NXDebug.info('str: [' +
                request.streamType +
                '] loaded, ' +
                path[path.length - 1] +
                ', i=' +
                request.index +
                ' ,t=' +
                Math.floor(request.startTime) +
                ' total=' +
                (request.requestEndTime - request.requestStartTime) +
                'ms' +
                ', ' +
                (data != null ? data.length : 'NULL') +
                'bytes' +
                ' rst:' +
                new Date().getTime());
            if (_this.isDynamic) {
                curRep.adaptation.period.liveEdgeFromRequest = Math.max(curRep.adaptation.period.liveEdgeFromRequest, request.startTime + request.duration);
            }
            if (!_this.fragmentDuration && !isNaN(request.duration)) {
                _this.fragmentDuration = request.duration;
            }
            if (data !== null) {
                _this.appendToBuffer.call(self, data, request, function (f) {
                    if (f) {
                        if (curRep.lastRequestIndex === request.index &&
                            !_this.isBufferingCompleted) {
                            _this.isBufferingCompleted = true;
                            if (_this.stalled) {
                                _this.stalled = false;
                                _this.stallStream.call(self, _this.stalled, 1);
                            }
                            _this.setState.call(self, _this.READY);
                            _this.eventBus.dispatchEvent({
                                type: 'bufferingCompleted',
                                data: _this.type,
                            });
                        }
                        else {
                            if (_this.fragmentController.needToPrepareNewRequest(self)) {
                                _this.getPlaybackQuality.call(self);
                                _this.requestNewFragment.call(self);
                            }
                        }
                        if (!_this.useFetch) {
                            _this.appendFromBufferQ.call(self);
                        }
                    }
                    else {
                        _this.NXDebug.debug('ERROR: appentToBuffer');
                    }
                });
            }
            else {
                _this.NXDebug.log('No ' + _this.type + ' bytes to push.');
            }
        };
        /* istanbul ignore next */
        this.appendToBuffer = function (data, req, callback) {
            var self = _this;
            var currentVideoTime = _this.videoModel.getCurrentTime();
            var currentTime = new Date();
            var quality = req.quality;
            var rstime = req.startTime;
            var startTime = 0;
            var dur = req.duration;
            var offset = req.MSETimeOffset;
            var curRep = req.representation;
            var curAset = curRep.adaptation;
            var asetIdx = req.adaptationIdx;
            var pStart = curAset.period.start;
            var initData;
            var diff_debug = 0;
            if (_this.playListTraceMetricsClosed === true &&
                _this.state !== _this.WAITING &&
                _this.requiredQuality !== -1) {
                _this.playListTraceMetricsClosed = false;
                _this.playListTraceMetrics = _this.metrics.appendPlayListTrace(_this.playListMetrics, curRep.id, null, currentTime, currentVideoTime, null, 1.0, null);
            }
            if (!_this.hasData()) {
                callback(false);
                return;
            }
            if (_this.preAppendTime !== rstime) {
                diff_debug = Math.floor(rstime) - Math.floor(_this.preAppendTime);
                if (_this.preAppendTime === -1)
                    diff_debug = '-';
                _this.preAppendTime = rstime;
            }
            else {
                if (_this.type === 'video') {
                    _this.logHandler.log_V2(_this.type[0] +
                        '[' +
                        quality +
                        '] t=' +
                        parseInt(String(rstime * 100.0)) / 100.0 +
                        ' dup');
                }
                else {
                    _this.logHandler.log_A2(_this.type[0] +
                        '[' +
                        quality +
                        '] t=' +
                        parseInt(String(rstime * 100.0)) / 100.0 +
                        ' dup');
                }
            }
            if (_this.currentQuality !== quality) {
                _this.currentQuality = quality;
                if (_this.type === 'video') {
                    _this.logHandler.log_V2(_this.type[0] + '[' + _this.currentQuality + '] init');
                    _this.logHandler.log_V2(_this.type[0] +
                        '[' +
                        quality +
                        '] t=' +
                        parseInt(String(rstime * 100.0)) / 100.0 +
                        ' : ' +
                        diff_debug);
                    _this.logHandler.log_item('bw_video', 'Video: ' +
                        curRep.bandwidth / 1000 +
                        ' Kbps' +
                        ' (' +
                        curRep.width +
                        'x' +
                        curRep.height +
                        ')');
                }
                else {
                    _this.logHandler.log_A2(_this.type[0] + '[' + _this.currentQuality + '] init');
                    _this.logHandler.log_A2(_this.type[0] +
                        '[' +
                        quality +
                        '] t=' +
                        parseInt(String(rstime * 100.0)) / 100.0 +
                        ' : ' +
                        diff_debug);
                    _this.logHandler.log_item('bw_audio', 'Audio: ' + curRep.bandwidth / 1000 + ' Kbps');
                }
            }
            else {
                if (_this.type === 'video') {
                    _this.logHandler.log_V2(_this.type[0] +
                        '[' +
                        quality +
                        '] t=' +
                        parseInt(String(rstime * 100.0)) / 100.0 +
                        ' : ' +
                        diff_debug);
                }
                else {
                    _this.logHandler.log_A2(_this.type[0] +
                        '[' +
                        quality +
                        '] t=' +
                        parseInt(String(rstime * 100.0)) / 100.0 +
                        ' : ' +
                        diff_debug);
                }
            }
            if (_this.useFetch) {
                callback(true);
                return;
            }
            try {
                initData = _this.initializationData[pStart][curAset.index][quality];
            }
            catch (e) {
                initData = undefined;
            }
            if (!initData) {
                _this.fragmentModel.removeExecutedRequest(req);
                return;
            }
            if (_this.type == 'video' && _this.EXTRACT_ALL_IDR_IN_MOOF) {
                data = _this.indexHandler.extractIDRinMOOF(data, initData.params.timescale, curRep.codecs);
            }
            var moofs = _this.indexHandler.parseFragment(data, initData.params.timescale, initData.params.dsd, offset, _this.type, _this.periodInfo.inEventList);
            startTime = moofs[0].time;
            dur =
                moofs[moofs.length - 1].time + moofs[moofs.length - 1].dur - startTime;
            if (dur < _this.MSE_APPEND_ENABLE_THRESHOLD + 1 || moofs.length < 2) {
                if (data != undefined)
                    _this.sourceBufferExt.append(_this.buffer, data, initData, rstime, startTime, dur, pStart, offset, _this.minBufferTime, quality, asetIdx, 0, req.index);
            }
            else {
                var s_offset = undefined;
                var s_startTime = undefined;
                var s_dur = 0;
                var divNum = 0;
                for (var i = 0; i < moofs.length; i++) {
                    var t_offset = moofs[i].offset;
                    var t_size = moofs[i].size;
                    var t_startTime = moofs[i].time;
                    var t_dur = moofs[i].dur;
                    var tmp = void 0;
                    if (s_dur === 0) {
                        //s_startTime = t_startTime + pStart;
                        //s_startTime = startTime + (t_startTime-earliestStartTime);
                        s_startTime = t_startTime;
                        s_offset = t_offset;
                    }
                    s_dur += t_dur;
                    if (s_dur > _this.MSE_APPEND_ENABLE_THRESHOLD ||
                        i == moofs.length - 1) {
                        tmp = data.subarray(s_offset, t_offset + t_size);
                        _this.sourceBufferExt.append(_this.buffer, tmp, initData, rstime, s_startTime, s_dur, pStart, offset, _this.minBufferTime, quality, asetIdx, divNum, req.index);
                        s_dur = 0;
                        divNum++;
                    }
                }
            }
            data = void 0;
            // if (!isScheduled && isSchedulingRequired.call(self)) {
            //   start.call(self, '222222');
            // }
            _this.updateBufferLevel.call(self);
            var ranges = _this.sourceBufferExt.getAllRanges(_this.buffer);
            if (ranges) {
                if (ranges.length > 0) {
                    var len = ranges.length;
                    for (var i = 0; i < len; i += 1) {
                        _this.NXDebug.debug('[' +
                            _this.type +
                            '] Buffered Range[' +
                            i +
                            ']: ' +
                            ranges.start(i) +
                            ' - ' +
                            ranges.end(i));
                    }
                }
            }
            callback(true);
        };
        this.firstSegmentInCurrentPeriod = function () {
            if (_this.buffer.queue.length == 0)
                return false;
            var q = _this.buffer.queue[0];
            if (q.pStart == _this.periodInfo.start) {
                if (q.time - _this.periodInfo.start <= _this.tolerance) {
                    var ct = _this.videoModel.getCurrentTime();
                    if (_this.periodInfo.start - ct < _this.MSE_APPEND_ENABLE_THRESHOLD) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            return false;
        };
        this.appendFromBufferQv01 = function () {
            if (_this.bufferLevel < _this.MSE_APPEND_ENABLE_THRESHOLD ||
                _this.waitingForBuffer ||
                _this.firstSegmentInCurrentPeriod()) {
                _this.sourceBufferExt.appendFromQ(_this.buffer, _this.waitingForBuffer, _this.bufferStartThreshold);
            }
        };
        /* istanbul ignore next */
        this.appendFromBufferQForAB = function () {
            if (_this.appendFromBufferQisProcessing)
                return;
            if (_this.bufferLevel < _this.MSE_APPEND_ENABLE_THRESHOLD ||
                _this.waitingForBuffer ||
                _this.firstSegmentInCurrentPeriod() ||
                _this.videoModel.getNeedsMoreData()) {
                _this.appendFromBufferQisProcessing = true;
                _this.sourceBufferExt.waitForUpdateEnd(_this.buffer, function () {
                    if ('remove' in _this.buffer && _this.buffer.buffered.length > 0) {
                        var curTime = _this.videoModel.getCurrentTime();
                        var bStart = _this.buffer.buffered.start(0);
                        if (bStart + 35 < curTime) {
                            _this.sourceBufferExt.remove(_this.buffer, bStart, curTime - 30, _this.periodInfo.duration, _this.mediaSource, function () {
                                _this.sourceBufferExt.appendFromQ(_this.buffer, _this.waitingForBuffer, _this.bufferStartThreshold);
                                _this.appendFromBufferQisProcessing = false;
                            });
                        }
                        else {
                            _this.sourceBufferExt.appendFromQ(_this.buffer, _this.waitingForBuffer, _this.bufferStartThreshold);
                            _this.appendFromBufferQisProcessing = false;
                        }
                    }
                    else {
                        _this.sourceBufferExt.appendFromQ(_this.buffer, _this.waitingForBuffer, _this.bufferStartThreshold);
                        _this.appendFromBufferQisProcessing = false;
                    }
                });
            }
        };
        this.updateBufferLevel = function () {
            if (!_this.hasData())
                return false;
            var self = _this;
            var currentTime = _this.getWorkingTime.call(self);
            var bufferLength = _this.sourceBufferExt.getBufferLength(_this.buffer, currentTime, _this.tolerance);
            _this.tlen = _this.sourceBufferExt.getBufferLength(_this.buffer, currentTime + 1.0, _this.tolerance);
            if (!_this.hasData()) {
                return false;
            }
            _this.bufferLevel = bufferLength;
            _this.buffer.level = _this.bufferLevel;
            _this.metrics.addBufferLevel(_this.type, new Date().getTime(), _this.bufferLevel, _this.sourceBufferExt.dataQduration(_this.buffer, _this.isSegmentTemplate), currentTime);
            _this.checkIfSufficientBuffer.call(self);
            /* istanbul ignore if */
            if (!_this.started) {
                if (_this.type === 'video') {
                    _this.logHandler.log_item('ctime', 'time: ' +
                        new Number(_this.videoModel.getCurrentTime()).toFixed(2) +
                        ', dur: ' +
                        (isFinite(_this.videoModel.getDuration())
                            ? new Number(_this.videoModel.getDuration()).toFixed(2)
                            : _this.videoModel.getDuration()));
                    _this.logHandler.log_item('vlog', _this.type +
                        ' len: ' +
                        _this.buffer.buffered.length +
                        ', buffer: ' +
                        parseInt(String(_this.bufferLevel * 100.0)) / 100.0);
                }
                else {
                    _this.logHandler.log_item('alog', _this.type +
                        ' len: ' +
                        _this.buffer.buffered.length +
                        ', buffer: ' +
                        parseInt(String(_this.bufferLevel * 100.0)) / 100.0);
                }
                _this.logHandler.log_slider(_this.videoModel.getCurrentTime(), _this.videoModel.getDuration());
            }
            return true;
        };
        //NSV-a  const clearBuffer = (_callback) => {
        //NSV-a    const callback = _callback || (() => {});
        //NSV-a    const currentTime = videoModel.getCurrentTime();
        //NSV-a    let removeStart = 0;
        //NSV-a    let removeEnd;
        //NSV-a    let req;
        //NSV-a    let range;
        //NSV-a
        //NSV-a    req = fragmentController.getExecutedRequestForTime(
        //NSV-a      fragmentModel,
        //NSV-a      currentTime
        //NSV-a    );
        //NSV-a    removeEnd =
        //NSV-a      req && !isNaN(req.startTime)
        //NSV-a        ? req.startTime - 5
        //NSV-a        : Math.floor(currentTime - 5);
        //NSV-a    fragmentDuration = req && !isNaN(req.duration) ? req.duration : 1;
        //NSV-a
        //NSV-a    range = sourceBufferExt.getBufferRange(buffer, currentTime, tolerance);
        //NSV-a
        //NSV-a    if (
        //NSV-a      range === null &&
        //NSV-a      seekTarget === currentTime &&
        //NSV-a      buffer.buffered.length > 0
        //NSV-a    ) {
        //NSV-a      removeEnd = buffer.buffered.end(buffer.buffered.length - 1);
        //NSV-a    }
        //NSV-a    removeStart = buffer.buffered.start(0);
        //NSV-a    sourceBufferExt.remove(
        //NSV-a      buffer,
        //NSV-a      removeStart,
        //NSV-a      removeEnd,
        //NSV-a      periodInfo.duration,
        //NSV-a      mediaSource,
        //NSV-a      (f) => {
        //NSV-a        if (f) {
        //NSV-a          fragmentController.removeExecutedRequestsBeforeTime(
        //NSV-a            fragmentModel,
        //NSV-a            removeEnd
        //NSV-a          );
        //NSV-a          callback(removeEnd - removeStart);
        //NSV-a        } else {
        //NSV-a          callback(0);
        //NSV-a        }
        //NSV-a      }
        //NSV-a    );
        //NSV-a  };
        this.onInitializationLoaded = function (request, data) {
            var quality = request.quality;
            _this.NXDebug.log('Initialization finished loading: ' + request.streamType);
            if (data !== null) {
                _this.initializationData[_this.periodInfo.start][_this.currentAdaptation.index][quality].data = data;
                //NSV-a      initIsLoading = false;
            }
            else {
                _this.NXDebug.log('No ' + _this.type + ' bytes to push.');
            }
        };
        /* istanbul ignore next */
        this.onBytesError = function (evType, request) {
            var self = _this;
            if (_this.state === _this.LOADING) {
                _this.setState.call(_this, _this.READY);
            }
            if (!_this.isScheduled) {
                _this.cancelPendingRequests.call(self, _this.type, _this.UPDATE, 4);
                return;
            }
            if (evType == 'onloadend') {
                var failedList_1;
                var lq = request.quality;
                if (request.failedList) {
                    failedList_1 = request.failedList;
                    if (failedList_1[request.baseURLIdx].indexOf(lq) < 0) {
                        failedList_1[request.baseURLIdx].push(lq);
                    }
                }
                else {
                    failedList_1 = new Array(request.baseURL.length);
                    for (var i = 0; i < failedList_1.length; i++) {
                        failedList_1[i] = [];
                    }
                    failedList_1[request.baseURLIdx].push(request.quality);
                }
                var bs = request.baseURL.length;
                for (var i = 0; i < bs; i++) {
                    if (failedList_1[i].indexOf(lq) < 0) {
                        request.baseURLIdx = i;
                        request.failedList = failedList_1;
                        if (_this.useFetch)
                            _this.checkRemoveQForTime.call(self, request.startTime);
                        if (!_this.fragmentController.isFragmentLoadingOrPending(self, request)) {
                            _this.fragmentModel.addRequest(request);
                        }
                        return;
                    }
                }
                var qs_1 = request.representation.adaptation.representations.length;
                var q = 0;
                var sbidx = request.representation.adaptation.period.selectedBaseURLIdx;
                var bidx_1 = sbidx;
                var decision = false;
                for (var i = 0; i < qs_1; i++) {
                    if (failedList_1[sbidx].indexOf(i) < 0) {
                        q = i;
                        decision = true;
                        break;
                    }
                }
                if (decision == false) {
                    for (var ii = 0; ii < bs; ii++) {
                        if (ii == sbidx)
                            continue;
                        for (var i = 0; i < qs_1; i++) {
                            if (failedList_1[ii].indexOf(i) < 0) {
                                q = i;
                                bidx_1 = ii;
                                decision = true;
                                break;
                            }
                        }
                        if (decision == true)
                            break;
                    }
                }
                _this.indexHandler.getSegmentRequestForTime(request.representation.adaptation.representations[q], request.startTime, _this.type, 6, function (d) {
                    var request;
                    if (d.status === 'ok') {
                        if (d.data) {
                            request = d.data;
                            if (request != null) {
                                request.baseURLIdx = bidx_1;
                                request.failedList = failedList_1;
                                if (_this.useFetch)
                                    _this.checkRemoveQForTime.call(self, request.startTime);
                                if (!_this.fragmentController.isFragmentLoadingOrPending(self, request)) {
                                    _this.fragmentModel.addRequest(request);
                                }
                            }
                        }
                    }
                    else {
                        request = null;
                    }
                });
            }
            else if (evType == 'onabort') {
                // eslint-disable-line no-empty
            }
        };
        this.checkRemoveQForTime = function (rstime) {
            for (var i = 0; i < _this.buffer.queue.length; i++) {
                if (_this.buffer.queue[i].rstime == rstime) {
                    if (!_this.buffer.queue[i].done) {
                        _this.buffer.queue.splice(i, 1);
                    }
                    break;
                }
            }
        };
        //NSV-a  const searchForLiveEdge = function (_callback) {
        //NSV-a    const self = this; // set the time span that limits our search range to a 12 hours in seconds
        //NSV-a    const callback = _callback || (() => {});
        //NSV-a
        //NSV-a    // all segments are supposed to be available in this interval
        //NSV-a    const availabilityRange = currentRepresentation.segmentAvailabilityRange;
        //NSV-a
        //NSV-a    const searchTimeSpan = 12 * 60 * 60;
        //NSV-a    // start position of the search, it is supposed to be a live edge - the last available segment for the current mpd
        //NSV-a    liveEdgeInitialSearchPosition = availabilityRange.end;
        //NSV-a    // we should search for a live edge in a time range which is limited by searchTimeSpan.
        //NSV-a    liveEdgeSearchRange = {
        //NSV-a      start: Math.max(0, liveEdgeInitialSearchPosition - searchTimeSpan),
        //NSV-a      end: liveEdgeInitialSearchPosition + searchTimeSpan,
        //NSV-a    };
        //NSV-a    // we have to use half of the availability interval (window) as a search step to ensure that we find a segment in the window
        //NSV-a    liveEdgeSearchStep = Math.floor(
        //NSV-a      (availabilityRange.end - availabilityRange.start) / 2
        //NSV-a    );
        //NSV-a    // start search from finding a request for the initial search time
        //NSV-a
        //NSV-a    indexHandler.getSegmentRequestForTime(
        //NSV-a      currentRepresentation,
        //NSV-a      liveEdgeInitialSearchPosition,
        //NSV-a      type,
        //NSV-a      findLiveEdge.bind(
        //NSV-a        self,
        //NSV-a        liveEdgeInitialSearchPosition,
        //NSV-a        onSearchForSegmentSucceeded,
        //NSV-a        onSearchForSegmentFailed,
        //NSV-a        callback
        //NSV-a      )
        //NSV-a    );
        //NSV-a  };
        this.findLiveEdge = function (searchTime, onSuccess, onError, _callback, d) {
            var self = _this;
            var callback = _callback;
            var request;
            if (d.status === 'ok') {
                request = d.data;
            }
            else {
                request = null;
            }
            if (request === null) {
                // request can be null because it is out of the generated list of request. In this case we need to
                // update the list and the segmentAvailabilityRange
                _this.currentRepresentation.segments = null;
                _this.currentRepresentation.segmentAvailabilityRange = {
                    start: searchTime - _this.liveEdgeSearchStep,
                    end: searchTime + _this.liveEdgeSearchStep,
                };
                // try to get request object again
                _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, searchTime, _this.type, 0, _this.findLiveEdge.bind(self, searchTime, onSuccess, onError, callback));
            }
            else {
                _this.fragmentController.isFragmentExists(self, request, function (isExist) {
                    if (isExist) {
                        onSuccess.call(self, request, searchTime, callback);
                    }
                    else {
                        onError.call(self, request, searchTime, callback);
                    }
                });
            }
        };
        this.onSearchForSegmentFailed = function (_request, lastSearchTime, callback) {
            var searchTime = lastSearchTime - 5;
            if (searchTime < _this.currentRepresentation.segmentAvailabilityRange.start) {
                _this.eventBus.dispatchEvent({
                    type: 'segmentLoadingFailed',
                    data: {},
                });
            }
            else {
                _this.setState.call(_this, _this.READY);
                _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, searchTime, _this.type, 0, _this.findLiveEdge.bind(_this, searchTime, _this.onSearchForSegmentSucceeded, _this.onSearchForSegmentFailed, callback));
            }
        };
        this.onSearchForSegmentSucceeded = function (request, lastSearchTime, _callback) {
            var startTime = request.startTime;
            var self = _this;
            var callback = _callback || (function () { });
            var searchTime;
            if (!_this.useBinarySearch) {
                // if the fragment duration is unknown we cannot use binary search because we will not be able to
                // decide when to stop the search, so let the start time of the current segment be a liveEdge
                if (_this.fragmentDuration === 0) {
                    callback(startTime);
                    return;
                }
                _this.useBinarySearch = true;
                _this.liveEdgeSearchRange.end = startTime + 2 * _this.liveEdgeSearchStep;
                //if the first request has succeeded we should check next segment - if it does not exist we have found live edge,
                // otherwise start binary search to find live edge
                if (lastSearchTime === _this.liveEdgeInitialSearchPosition) {
                    searchTime = lastSearchTime + _this.fragmentDuration;
                    _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, searchTime, _this.type, 0, _this.findLiveEdge.bind(self, searchTime, function () {
                        _this.binarySearch.call(self, true, searchTime, callback);
                    }, function () {
                        callback(searchTime);
                    }, callback));
                    return;
                }
            }
            _this.binarySearch.call(_this, true, lastSearchTime, callback);
        };
        this.binarySearch = function (lastSearchSucceeded, lastSearchTime, _callback) {
            var isSearchCompleted;
            var callback = _callback || (function () { });
            var searchTime;
            if (lastSearchSucceeded) {
                _this.liveEdgeSearchRange.start = lastSearchTime;
            }
            else {
                _this.liveEdgeSearchRange.end = lastSearchTime;
            }
            isSearchCompleted =
                Math.floor(_this.liveEdgeSearchRange.end - _this.liveEdgeSearchRange.start) <= _this.fragmentDuration;
            if (isSearchCompleted) {
                // search completed, we should take the time of the last found segment. If the last search succeded we
                // take this time. Otherwise, we should subtract the time of the search step which is equal to fragment duaration
                callback(lastSearchSucceeded
                    ? lastSearchTime
                    : lastSearchTime - _this.fragmentDuration);
            }
            else {
                // update the search time and continue searching
                searchTime =
                    (_this.liveEdgeSearchRange.start + _this.liveEdgeSearchRange.end) / 2;
                _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, searchTime, _this.type, 0, _this.findLiveEdge.bind(_this, searchTime, _this.onSearchForSegmentSucceeded, _this.onSearchForSegmentFailed, callback));
            }
        };
        this.signalStreamComplete = function (request) {
            if (request.periodIdx != _this.periodInfo.index) {
                return;
            }
            _this.stop.call(_this);
            _this.keepCurrentRequests.call(_this);
            _this.isStreamCompleted = true;
            _this.eventBus.dispatchEvent({
                type: 'streamIsCompleted',
                data: {
                    type: _this.type,
                    periodIdx: request.periodIdx,
                    pStart: request.representation.adaptation.period.start,
                    pEnd: request.representation.adaptation.period.end,
                },
            });
        };
        //NSV-a  const loadInitialization = function (_callback) {
        //NSV-a    const callback = _callback || (() => {});
        //NSV-a    if (initialPlayback) {
        //NSV-a      NXDebug.log('Marking a special seek for initial ' + type + ' playback.');
        //NSV-a
        //NSV-a      // If we weren't already seeking, 'seek' to the beginning of the stream.
        //NSV-a      if (!seeking) {
        //NSV-a        seeking = true;
        //NSV-a        seekTarget = 0;
        //NSV-a        setIncrementalMode.call(this, false, 2);
        //NSV-a      }
        //NSV-a
        //NSV-a      initialPlayback = false;
        //NSV-a    }
        //NSV-a
        //NSV-a    if (currentQuality !== requiredQuality || currentQuality === -1) {
        //NSV-a      if (
        //NSV-a        initializationData[periodInfo.start][currentAdaptation.index][
        //NSV-a          requiredQuality
        //NSV-a        ]
        //NSV-a      ) {
        //NSV-a        initIsLoading = false;
        //NSV-a        callback({
        //NSV-a          status: 'ok',
        //NSV-a          data: null,
        //NSV-a        });
        //NSV-a      } else if (initIsLoading) {
        //NSV-a        callback({
        //NSV-a          status: 'ok',
        //NSV-a          data: null,
        //NSV-a        });
        //NSV-a      } else {
        //NSV-a        initIsLoading = true;
        //NSV-a        indexHandler.getInitRequest(
        //NSV-a          availableRepresentations[requiredQuality],
        //NSV-a          type,
        //NSV-a          callback
        //NSV-a        );
        //NSV-a      }
        //NSV-a    }
        //NSV-a  };
        /* istanbul ignore next */
        this.loadFirstSegmentRequestAfterSeek = function (seekTarget) {
            var self = _this;
            var segmentTime;
            var time = seekTarget;
            var request;
            var ctime = _this.videoModel.getCurrentTime();
            var range = _this.sourceBufferExt.getBufferRange(_this.buffer, time, _this.tolerance);
            if (_this.isDynamic &&
                _this.seeking &&
                (_this.currentRepresentation.segmentInfoType === 'SegmentTimeline' ||
                    _this.currentRepresentation.segmentInfoType === 'SegmentTemplate' ||
                    _this.currentRepresentation.segmentInfoType === 'SegmentList')) {
                _this.currentRepresentation.segments = null;
            }
            segmentTime = range ? range.end : time;
            if (segmentTime < _this.periodInfo.start) {
                return;
            }
            if (range) {
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] Loading the fragment for seek time: ' +
                    segmentTime +
                    ', ' +
                    time +
                    ' [' +
                    range.start +
                    '-' +
                    range.end +
                    ']');
            }
            else {
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] Loading the fragment for seek time: ' +
                    segmentTime +
                    ', ' +
                    time);
            }
            if (ctime === 0 ||
                segmentTime < ctime + _this.BUFFER_PREFETCH_THRESHOLD * 1.5) {
                _this.setIncrementalMode.call(self, false, 3);
                _this.seeking = false;
                _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, segmentTime, _this.type, 1, function (d) {
                    if (d.status == 'ok') {
                        request = d.data;
                        if (request != null) {
                            _this.buffer.startTimeAfterSeek = request.startTime;
                            _this.NXDebug.info('[' +
                                _this.type +
                                '] startTimeAfterSeek:' +
                                _this.buffer.startTimeAfterSeek);
                            request.keep = true;
                            request.las = true;
                        }
                        else {
                            _this.buffer.startTimeAfterSeek = Number.MAX_VALUE;
                        }
                        var rqs = [
                            _this.fragmentModel.getLoadingRequests(),
                            _this.fragmentModel.getPendingRequests(),
                        ];
                        rqs.forEach(function (l) {
                            for (var i = 0; i < l.length; i++) {
                                if (l[i].las) {
                                    l[i].keep = false;
                                }
                            }
                        });
                        _this.checkQ.call(self, seekTarget);
                        if (_this.useFetch)
                            _this.checkRemoveQForTime.call(self, request.startTime);
                        if (request != null &&
                            !_this.fragmentController.isFragmentLoadingOrPending(self, request)) {
                            _this.fragmentModel.addRequest(request);
                        }
                    }
                    _this.setIncrementalMode.call(self, true, 33);
                    _this.seeking = false;
                    _this.setState.call(self, _this.READY);
                });
            }
            else {
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] Loading the fragment for time: skip ' +
                    ctime +
                    ' : ' +
                    segmentTime);
                _this.seeking = false;
            }
        };
        /* istanbul ignore next */
        this.loadNextFragment = function (_callback) {
            var callback = _callback;
            var self = _this;
            var ctime = _this.videoModel.getCurrentTime();
            if (_this.incrementalMode &&
                !_this.indexHandler.isInitialIndex(_this.type)) {
                _this.indexHandler.getNextSegmentRequest(_this.currentRepresentation, _this.type, function (d) {
                    if (d.status === 'ok') {
                        if (d.data != null &&
                            ctime + _this.BUFFER_PREFETCH_THRESHOLD * 1.5 < d.data.startTime) {
                            _this.setIncrementalMode.call(self, true, 4);
                        }
                    }
                    callback(d);
                });
            }
            else {
                var segmentTime = void 0;
                var time = void 0;
                if (_this.seeking) {
                    time = _this.seekTarget;
                }
                else {
                    time = ctime > 0 ? ctime : _this.videoModel.getStartTime();
                }
                var range = _this.sourceBufferExt.getBufferRange(_this.buffer, time, _this.tolerance);
                if (_this.isDynamic &&
                    _this.seeking &&
                    (_this.currentRepresentation.segmentInfoType === 'SegmentTimeline' ||
                        _this.currentRepresentation.segmentInfoType === 'SegmentTemplate' ||
                        _this.currentRepresentation.segmentInfoType === 'SegmentList')) {
                    _this.currentRepresentation.segments = null;
                }
                segmentTime = range ? range.end : time;
                if (segmentTime < _this.periodInfo.start) {
                    // if (isScheduled) {
                    //   segmentTime = periodInfo.start;
                    // } else {
                    //   return;
                    // }
                    return;
                }
                if (range) {
                    _this.NXDebug.debug('[' +
                        _this.type +
                        '] Loading the fragment for time: ' +
                        segmentTime +
                        ', ' +
                        time +
                        ' [' +
                        range.start +
                        '-' +
                        range.end +
                        ']');
                }
                else {
                    _this.NXDebug.debug('[' +
                        _this.type +
                        '] Loading the fragment for time: ' +
                        segmentTime +
                        ', ' +
                        time);
                }
                if (ctime === 0 ||
                    segmentTime < ctime + _this.BUFFER_PREFETCH_THRESHOLD * 1.5) {
                    //reject
                    _this.setIncrementalMode.call(self, true, 5);
                    _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, segmentTime, _this.type, 1, callback);
                }
                else {
                    _this.NXDebug.debug('[' +
                        _this.type +
                        '] Loading the fragment for time: skip ' +
                        ctime +
                        ' : ' +
                        segmentTime);
                    _this.seeking = false;
                    callback({
                        status: 'ok',
                        data: null,
                    });
                }
                //seeking = false;
            }
        };
        //NSV-a  const hasAlreadyBuffered = (request) => {
        //NSV-a    let flag = false;
        //NSV-a    const length = sourceBufferExt.getBufferLength(
        //NSV-a      buffer,
        //NSV-a      request.startTime,
        //NSV-a      tolerance
        //NSV-a    );
        //NSV-a
        //NSV-a    flag = length > 0 ? true : false;
        //NSV-a    return flag;
        //NSV-a  };
        /* istanbul ignore next */
        this.onFragmentRequest = function (d) {
            var self = _this;
            var request;
            if (d.status === 'ok') {
                request = d.data;
            }
            else {
                request = null;
            }
            if (request !== null) {
                var length_1 = _this.sourceBufferExt.getBufferLength(_this.buffer, request.startTime, _this.tolerance);
                if (length_1 > request.duration) {
                    _this.setIncrementalMode.call(self, false, 6);
                    _this.setState.call(self, _this.READY);
                }
                // If we have already loaded the given fragment ask for the next one. Otherwise prepare it to get loaded
                else if (_this.fragmentController.isFragmentLoadedOrPending(self, request)) {
                    if (request.action !== 'complete') {
                        _this.NXDebug.debug('[' +
                            _this.type +
                            '] Index for time Next!!! cur idx: ' +
                            request.index +
                            ', t=' +
                            request.startTime);
                        _this.indexHandler.getNextSegmentRequest(_this.currentRepresentation, _this.type, _this.onFragmentRequest.bind(self));
                    }
                    else {
                        _this.stop.call(self);
                        _this.setState.call(self, _this.READY);
                    }
                }
                else {
                    _this.NXDebug.debug('[' +
                        _this.type +
                        '] startTime:' +
                        request.startTime +
                        ', length:' +
                        length_1);
                    if (_this.seeking) {
                        _this.buffer.startTimeAfterSeek = request.startTime;
                        _this.NXDebug.info('[' +
                            _this.type +
                            '] startTimeAfterSeek:' +
                            _this.buffer.startTimeAfterSeek +
                            ', length:' +
                            length_1);
                        request.keep = true;
                        _this.seeking = false;
                    }
                    _this.fragmentModel.addRequest(request);
                    _this.setState.call(self, _this.READY);
                }
            }
            else {
                if (_this.isDynamic &&
                    _this.isTargetType.call(self, _this.type) &&
                    !_this.isSegmentTemplate) {
                    _this.manifestModel.manifestUpdateStartPoll();
                }
                if (d.time != null) {
                    if (d.time < _this.periodInfo.start) {
                        _this.keepCurrentRequests.call(self);
                        _this.seek.call(self, _this.periodInfo.start, 'no data');
                    }
                }
                _this.setState.call(self, _this.READY);
            }
        };
        this.keepCurrentRequests = function () {
            var loadings = _this.fragmentModel.getLoadingRequests();
            var pendings = _this.fragmentModel.getPendingRequests();
            if (loadings.length > 0) {
                for (var i = 0; i < loadings.length; i++) {
                    loadings[i].keep = true;
                }
            }
            if (pendings.length > 0) {
                for (var i = 0; i < pendings.length; i++) {
                    pendings[i].keep = true;
                }
            }
        };
        /* istanbul ignore next */
        this.checkIfSufficientBuffer = function () {
            if (_this.waitingForBuffer) {
                var currentTime = _this.getWorkingTime();
                var timeToEnd = isNaN(_this.getMSEDuration())
                    ? Infinity
                    : _this.getMSEDuration() - currentTime;
                if (_this.bufferLevel < _this.tlen) {
                    _this.logHandler.log('bufferLevel:' + _this.bufferLevel + ', tlen:' + _this.tlen);
                }
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] currentTime:' +
                    currentTime +
                    ', bufferLevel:' +
                    _this.tlen +
                    ', minBufferTime:' +
                    _this.minBufferTime +
                    ', timeToEnd:' +
                    timeToEnd +
                    ', isBufferingCompleted:' +
                    _this.isBufferingCompleted +
                    ',qlen:' +
                    _this.buffer.queue.length +
                    ',stalled:' +
                    _this.stalled);
                if (_this.tlen < _this.minBufferTime &&
                    (_this.minBufferTime < timeToEnd ||
                        (_this.minBufferTime >= timeToEnd && !_this.isBufferingCompleted))) {
                    if (!_this.stalled) {
                        _this.NXDebug.debug('[' +
                            _this.type +
                            '] Waiting for more buffer before starting playback.');
                        _this.logHandler.log('[' +
                            _this.type +
                            '] Waiting for more buffer before starting playback.');
                        _this.stalled = true;
                        _this.stallStream.call(_this, _this.stalled, 3);
                        if (_this.abrController.getAutoSwitchBitrate()) {
                            _this.abrController.setPlaybackQuality(_this.type, _this.videoModel.getPlaybackState()
                                ? 0
                                : _this.abrController.getDefaultQualityFor(_this.type));
                        }
                    }
                }
                else {
                    _this.NXDebug.debug('[' +
                        _this.type +
                        '] Got enough buffer to start.' +
                        _this.tlen +
                        ', stalled:' +
                        _this.stalled);
                    _this.waitingForBuffer = false;
                    _this.seeking = false; ///
                    _this.buffer.startTimeAfterSeek = Number.MAX_VALUE;
                    if (_this.stalled) {
                        _this.stalled = false;
                        _this.stallStream.call(_this, _this.stalled, 4);
                    }
                }
            }
        };
        this.onNeedToModifyOffset = function (evt) {
            if (evt.data.type == _this.type) {
                var r = _this.currentAdaptation.representations;
                for (var i = 0; i < r.length; i++) {
                    r[i].segments = null;
                    r[i].presentationTimeOffset += evt.data.minDiff;
                }
                _this.cancelPendingRequests.call(self, _this.type, _this.RESET, 5);
                if (_this.useFetch) {
                    var ld = _this.fragmentModel.getLoadingRequests();
                    for (var i = 0; i < ld.length; i++) {
                        var keep = false;
                        for (var j = 0; j < _this.buffer.queue.length; j++) {
                            if (ld[i].startTime == _this.buffer.queue[j].rstime) {
                                keep = true;
                                break;
                            }
                        }
                        if (!keep) {
                            _this.fragmentModel.abortRequestForTime(ld[i].startTime);
                        }
                    }
                }
                else {
                    _this.fragmentModel.abortRequests();
                }
                _this.setIncrementalMode.call(_this, false, 7);
            }
        };
        /* istanbul ignore next */
        this.onAppendedEnoughDataToStart = function (evt) {
            var self = _this;
            var _started = false;
            var checkStateId = null;
            var element = _this.videoModel.getElement();
            var start = function () {
                var ranges = _this.sourceBufferExt.getAllRanges(_this.buffer);
                var i;
                var len;
                for (i = 0, len = ranges.length; i < len; i += 1) {
                    _this.logHandler.log('[' +
                        _this.type +
                        '] Buffered Range[' +
                        i +
                        ']: ' +
                        ranges.start(i) +
                        ' - ' +
                        ranges.end(i) +
                        ', state:' +
                        _this.videoModel.getReadyState() +
                        ', c:' +
                        _this.videoModel.getCurrentTime() +
                        ', paused:' +
                        _this.videoModel.isPaused());
                }
                _this.NXDebug.debug('[' +
                    _this.type +
                    '] Appended enough data to start.' +
                    element.readyState);
                _this.logHandler.log('[' +
                    _this.type +
                    '] Appended enough data to start.' +
                    element.readyState);
                _started = true;
                if (_this.buffer.updating != undefined) {
                    element.removeEventListener('canplay', start);
                    _this.buffer.removeEventListener('updateend', start);
                    clearTimeout(checkStateId);
                }
                else {
                    // if (type == 'video') {
                    //   const ctime = getWorkingTime.call(self);
                    //   let blen = 0;
                    //   blen = sourceBufferExt.getBufferLength(
                    //     buffer,
                    //     ctime + 0.8,
                    //     tolerance
                    //   );
                    //   if (blen == 0 && cnt > 0) {
                    //     setTimeout(start, 50);
                    //     cnt--;
                    //     return;
                    //   }
                    // }
                }
                _this.buffer.startTimeAfterSeek = Number.MAX_VALUE;
                if (_this.stalled) {
                    _this.stalled = false;
                    _this.stallStream.call(self, _this.stalled, 5);
                }
                _this.playbackStarted = true;
            };
            var checkState = function () {
                if (!_started) {
                    if (element.readyState > 2) {
                        start();
                    }
                    else {
                        var ctime = _this.getWorkingTime.call(self);
                        var blen = 0;
                        blen = _this.sourceBufferExt.getBufferLength(_this.buffer, ctime + 0.5, _this.tolerance);
                        if (blen > 10 && element.readyState < 3) {
                            start();
                        }
                        else {
                            checkStateId = setTimeout(checkState, 1000);
                        }
                    }
                }
                else {
                    // eslint-disable-line no-empty
                }
            };
            if (_this.type === evt.data.type) {
                _this.waitingForBuffer = false;
                if (!_this.playbackStarted && evt.data.modOffset) {
                    var r = _this.currentAdaptation.representations;
                    for (var i = 0; i < r.length; i++) {
                        r[i].segments = null;
                        r[i].presentationTimeOffset += evt.data.minDiff;
                    }
                    for (var i = 0; i < _this.buffer.queue.length; i++) {
                        _this.buffer.queue[i].offset -= evt.data.minDiff;
                    }
                    _this.cancelPendingRequests.call(self, _this.type, _this.UPDATE, 6);
                    if (_this.useFetch) {
                        var ld = _this.fragmentModel.getLoadingRequests();
                        for (var i = 0; i < ld.length; i++) {
                            var keep = false;
                            for (var j = 0; j < _this.buffer.queue.length; j++) {
                                if (ld[i].startTime == _this.buffer.queue[j].rstime) {
                                    keep = true;
                                    break;
                                }
                            }
                            if (!keep) {
                                _this.fragmentModel.abortRequestForTime(ld[i].startTime);
                            }
                        }
                    }
                    else {
                        _this.fragmentModel.abortRequests();
                    }
                    _this.setIncrementalMode.call(self, false, 8);
                }
                if (_this.buffer.updating != undefined) {
                    if (_this.listenToCanplay && element.readyState < 3) {
                        element.addEventListener('canplay', start);
                        checkStateId = setTimeout(checkState, 1000);
                    }
                    else if (_this.buffer.updating) {
                        _this.buffer.addEventListener('updateend', start);
                    }
                    else {
                        start();
                    }
                }
                else {
                    setTimeout(start, 50);
                }
            }
        };
        /* istanbul ignore next */
        this.onCheckBufferGap = function (evt) {
            var self = _this;
            if (evt.data.type == _this.type) {
                _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, evt.data.time, _this.type, 2, function (d) {
                    if (d.status === 'ok') {
                        var request = d.data;
                        if (request != null) {
                            if (_this.useFetch)
                                _this.checkRemoveQForTime.call(self, request.startTime);
                            if (!_this.fragmentController.isFragmentLoadingOrPending(self, request)) {
                                _this.fragmentModel.addRequest(request);
                                _this.setIncrementalMode.call(self, false, 9);
                            }
                        }
                    }
                    else {
                        _this.logHandler.log('ERROR: getSegmentsStartTime ' + d.msg);
                    }
                });
            }
        };
        this.isSchedulingRequired = function () {
            var isPaused = _this.videoModel.isPaused();
            return !isPaused || (isPaused && _this.scheduleWhilePaused);
        };
        this.hasData = function () {
            return _this.currentAdaptation != null && _this.buffer != null;
        };
        this.getTimeToEnd = function () {
            var currentTime = _this.videoModel.getCurrentTime();
            return _this.getMSEDuration.call(_this) - currentTime;
        };
        this.getMSEDuration = function () {
            if (_this.mediaSource != null)
                return _this.mediaSource.duration;
            else
                return Infinity;
        };
        this.setMSEDuration = function (dur, msg) {
            if (_this.mediaSource != null) {
                try {
                    if (_this.isTargetType(_this.type)) {
                        if (isNaN(_this.getMSEDuration()) ||
                            _this.getMSEDuration() == Infinity ||
                            dur > _this.getMSEDuration()) {
                            _this.mediaSource.duration = dur;
                        }
                    }
                }
                catch (e) {
                    _this.NXDebug.debug('duration set failed!' + msg);
                }
            }
        };
        this.getWorkingTime = function () {
            var time = -1;
            time = _this.videoModel.getPlaybackState()
                ? _this.videoModel.getCurrentTime()
                : _this.videoModel.getStartTime();
            return time;
        };
        //NSV-a  const getBufferLevelFromExecutedRequests = function () {
        //NSV-a    const ex = fragmentController.getExecutedRequests(this);
        //NSV-a    const ct = videoModel.getCurrentTime();
        //NSV-a    let ii;
        //NSV-a
        //NSV-a    if (ex != null && ex.length > 0) {
        //NSV-a      const eb = [];
        //NSV-a      for (ii = 0; ii < ex.length; ii++) {
        //NSV-a        eb.push({
        //NSV-a          start: ex[ii].startTime,
        //NSV-a          end: ex[ii].startTime + ex[ii].duration,
        //NSV-a        });
        //NSV-a      }
        //NSV-a      const compare = (d1, d2) => {
        //NSV-a        if (d1.start < d2.start) return -1;
        //NSV-a        if (d1.start > d2.start) return 1;
        //NSV-a        return 0;
        //NSV-a      };
        //NSV-a      eb.sort(compare);
        //NSV-a
        //NSV-a      const bStart = eb[0].start;
        //NSV-a      let bEnd = eb[0].end;
        //NSV-a      for (ii = 1; ii < eb.length; ii++) {
        //NSV-a        if (bEnd + tolerance >= eb[ii].start) {
        //NSV-a          bEnd = eb[ii].end;
        //NSV-a        } else {
        //NSV-a          break;
        //NSV-a        }
        //NSV-a      }
        //NSV-a
        //NSV-a      if (bStart <= ct && ct <= bEnd) {
        //NSV-a        return bEnd - ct;
        //NSV-a      } else {
        //NSV-a        if (type === 'audio') {
        //NSV-a          logHandler.log(
        //NSV-a            'bStart:' +
        //NSV-a              '0' +
        //NSV-a              ', bEnd:' +
        //NSV-a              '0' +
        //NSV-a              ', ct:' +
        //NSV-a              videoModel.getCurrentTime()
        //NSV-a          );
        //NSV-a        }
        //NSV-a        return 0;
        //NSV-a      }
        //NSV-a    } else {
        //NSV-a      logHandler.log(
        //NSV-a        'bStart:' +
        //NSV-a          '-1' +
        //NSV-a          ', bEnd:' +
        //NSV-a          '-1' +
        //NSV-a          ', ct:' +
        //NSV-a          videoModel.getCurrentTime()
        //NSV-a      );
        //NSV-a      return 0;
        //NSV-a    }
        //NSV-a  };
        this.getRequiredFragmentCount = function (_quality, _callback) {
            var playbackRate = _this.videoModel.getPlaybackRate();
            var actualBufferedDuration = (_this.bufferLevel +
                _this.sourceBufferExt.dataQduration(_this.buffer, _this.isSegmentTemplate)) /
                Math.max(playbackRate, 1);
            var callback = _callback;
            var requiredBufferLength = _this.getRequiredBufferLength.call(_this, _this.waitingForBuffer, _this.SCHEDULE_EXECUTE_INTERVAL / 1000, _this.isDynamic, _this.periodInfo.duration);
            _this.indexHandler.getSegmentCountForDuration(_this.currentRepresentation, requiredBufferLength, actualBufferedDuration, function (d) {
                if (d.status === 'ok') {
                    if (d.data > 0) {
                        callback(d.data);
                    }
                    else {
                        callback(0);
                    }
                }
                else {
                    callback(0);
                }
            });
            _this.setBufferState.call(_this, actualBufferedDuration, requiredBufferLength);
        };
        this.requestNewFragment = function () {
            var self = _this;
            var pendingRequests = _this.fragmentController.getPendingRequests(self);
            var loadingRequests = _this.fragmentController.getLoadingRequests(self);
            var ln = (pendingRequests ? pendingRequests.length : 0) +
                (loadingRequests ? loadingRequests.length : 0);
            if (_this.fragmentsToLoad - ln > 0) {
                _this.fragmentsToLoad--;
                _this.loadNextFragment.call(self, _this.onFragmentRequest.bind(self));
            }
            else {
                if (_this.state === _this.VALIDATING) {
                    _this.setState.call(self, _this.READY);
                }
                _this.finishValidation.call(_this);
            }
        };
        this.getCurrentHttpRequestLatency = function (tmetrics) {
            var httpRequest = tmetrics.getCurrentHttpRequest();
            if (httpRequest !== null) {
                return (httpRequest.tresponse - httpRequest.trequest) / 1000;
            }
            return 0;
        };
        this.decideBufferLength = function (_minBufferTime, duration /*, waitingForBuffer*/) {
            var minBufferTarget;
            var minBufferTime = _this.forceDefaultMBT == false
                ? _minBufferTime
                : _this.DEFAULT_MIN_BUFFER_TIME;
            if (isNaN(duration) ||
                duration < 0 ||
                (_this.DEFAULT_MIN_BUFFER_TIME < duration && minBufferTime < duration)) {
                minBufferTarget =
                    _this.ullMode == true
                        ? minBufferTime
                        : Math.max(_this.DEFAULT_MIN_BUFFER_TIME, minBufferTime);
            }
            else if (minBufferTime >= duration) {
                minBufferTarget = Math.min(duration, _this.DEFAULT_MIN_BUFFER_TIME);
            }
            else {
                minBufferTarget = Math.min(duration, minBufferTime);
            }
            return minBufferTarget;
        };
        this.getRequiredBufferLength = function (_waitingForBuffer, delay, _isDynamic, _duration) {
            // eslint-disable-line no-unused-vars
            var vmetrics = _this.metricsModel.getMetricsFor('video');
            var ametrics = _this.metricsModel.getMetricsFor('audio');
            var requiredBufferLength;
            requiredBufferLength =
                _this.BUFFER_PREFETCH_THRESHOLD +
                    delay +
                    Math.max(_this.getCurrentHttpRequestLatency.call(_this, vmetrics), _this.getCurrentHttpRequestLatency.call(_this, ametrics));
            return requiredBufferLength;
        };
        //NSV-a  const createPSSHBox = (data) => {
        //NSV-a    // * desc@ getInitData
        //NSV-a    // *   generate PSSH data from PROHeader defined in MPD file
        //NSV-a    // *   PSSH format:
        //NSV-a    // *   size (4)
        //NSV-a    // *   box type(PSSH) (8)
        //NSV-a    // *   Protection SystemID (16)
        //NSV-a    // *   protection system data size (4) - length of decoded PROHeader
        //NSV-a    // *   decoded PROHeader data from MPD file
        //NSV-a    let byteCursor = 0;
        //NSV-a
        //NSV-a    let PROSize = 0;
        //NSV-a    let PSSHSize = 0;
        //NSV-a
        //NSV-a    //'PSSH' 8 bytes
        //NSV-a    const PSSHBoxType = new Uint8Array([
        //NSV-a      0x70,
        //NSV-a      0x73,
        //NSV-a      0x73,
        //NSV-a      0x68,
        //NSV-a      0x00,
        //NSV-a      0x00,
        //NSV-a      0x00,
        //NSV-a      0x00,
        //NSV-a    ]);
        //NSV-a
        //NSV-a    const playreadySystemID = new Uint8Array([
        //NSV-a      0x9a,
        //NSV-a      0x04,
        //NSV-a      0xf0,
        //NSV-a      0x79,
        //NSV-a      0x98,
        //NSV-a      0x40,
        //NSV-a      0x42,
        //NSV-a      0x86,
        //NSV-a      0xab,
        //NSV-a      0x92,
        //NSV-a      0xe6,
        //NSV-a      0x5b,
        //NSV-a      0xe0,
        //NSV-a      0x88,
        //NSV-a      0x5f,
        //NSV-a      0x95,
        //NSV-a    ]);
        //NSV-a
        //NSV-a    let uint8arraydecodedPROHeader = null;
        //NSV-a    let PSSHBoxBuffer = null;
        //NSV-a    let PSSHBox = null;
        //NSV-a    let PSSHData = null;
        //NSV-a
        //NSV-a    if ('pro' in data) {
        //NSV-a      uint8arraydecodedPROHeader = BASE64.decodeArray(data.pro);
        //NSV-a    } else if ('prheader' in data) {
        //NSV-a      // uint8arraydecodedPROHeader = BASE64.decodeArray(data.prheader);
        //NSV-a    } else {
        //NSV-a      return null;
        //NSV-a    }
        //NSV-a
        //NSV-a    PROSize = uint8arraydecodedPROHeader.length;
        //NSV-a    PSSHSize =
        //NSV-a      0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize;
        //NSV-a
        //NSV-a    PSSHBoxBuffer = new ArrayBuffer(PSSHSize);
        //NSV-a
        //NSV-a    PSSHBox = new Uint8Array(PSSHBoxBuffer);
        //NSV-a    PSSHData = new DataView(PSSHBoxBuffer);
        //NSV-a
        //NSV-a    PSSHData.setUint32(byteCursor, PSSHSize);
        //NSV-a    byteCursor += 0x4;
        //NSV-a
        //NSV-a    PSSHBox.set(PSSHBoxType, byteCursor);
        //NSV-a    byteCursor += PSSHBoxType.length;
        //NSV-a
        //NSV-a    PSSHBox.set(playreadySystemID, byteCursor);
        //NSV-a    byteCursor += playreadySystemID.length;
        //NSV-a
        //NSV-a    PSSHData.setUint32(byteCursor, PROSize);
        //NSV-a    byteCursor += 0x4;
        //NSV-a
        //NSV-a    PSSHBox.set(uint8arraydecodedPROHeader, byteCursor);
        //NSV-a    byteCursor += PROSize;
        //NSV-a
        //NSV-a    return PSSHBox;
        //NSV-a  };
        //NSV-a
        //NSV-a  const checkAndInsertPSSHBox = (initData, aset) => {
        //NSV-a    if (aset.getContentProtectionData() == null) {
        //NSV-a      return initData;
        //NSV-a    } else {
        //NSV-a      let type = '';
        //NSV-a      let size = 0;
        //NSV-a      const ab = new ArrayBuffer(initData.length);
        //NSV-a      const ab8 = new Uint8Array(ab);
        //NSV-a      const d = new DataView(ab);
        //NSV-a      let pos = 0;
        //NSV-a      let i;
        //NSV-a      let c;
        //NSV-a      let moovPos = 0;
        //NSV-a      let psshBoxAvailable = false;
        //NSV-a
        //NSV-a      ab8.set(initData);
        //NSV-a      while (type !== 'moov' && pos < d.byteLength) {
        //NSV-a        size = d.getUint32(pos); // subtract 8 for including the size and type
        //NSV-a        pos += 4;
        //NSV-a
        //NSV-a        type = '';
        //NSV-a        for (i = 0; i < 4; i += 1) {
        //NSV-a          c = d.getInt8(pos);
        //NSV-a          type += String.fromCharCode(c);
        //NSV-a          pos += 1;
        //NSV-a        }
        //NSV-a
        //NSV-a        if (type !== 'moov') {
        //NSV-a          pos += size - 8;
        //NSV-a        } else {
        //NSV-a          moovPos = pos - 8;
        //NSV-a          type = '';
        //NSV-a          while (type !== 'pssh' && pos < d.byteLength) {
        //NSV-a            size = d.getUint32(pos); // subtract 8 for including the size and type
        //NSV-a            pos += 4;
        //NSV-a
        //NSV-a            type = '';
        //NSV-a            for (i = 0; i < 4; i += 1) {
        //NSV-a              c = d.getInt8(pos);
        //NSV-a              type += String.fromCharCode(c);
        //NSV-a              pos += 1;
        //NSV-a            }
        //NSV-a
        //NSV-a            if (type !== 'pssh') {
        //NSV-a              pos += size - 8;
        //NSV-a            } else {
        //NSV-a              psshBoxAvailable = true;
        //NSV-a            }
        //NSV-a          }
        //NSV-a          break;
        //NSV-a        }
        //NSV-a      }
        //NSV-a
        //NSV-a      if (psshBoxAvailable !== true) {
        //NSV-a        const cps = aset.getContentProtectionData();
        //NSV-a        for (let j = 0; j < cps.length; j++) {
        //NSV-a          if (
        //NSV-a            cps[j].schemeIdUri ==
        //NSV-a            'urn:uuid:79f0049a-4098-8642-ab92-e65be0885f95'
        //NSV-a          ) {
        //NSV-a            const psshBox = createPSSHBox(cps[j]);
        //NSV-a
        //NSV-a            NXDebug.info(psshBox);
        //NSV-a            const newInitDataBuffer = new ArrayBuffer(
        //NSV-a              initData.length + psshBox.length
        //NSV-a            );
        //NSV-a            const newInitData = new Uint8Array(newInitDataBuffer);
        //NSV-a            const newInitDataView = new DataView(newInitDataBuffer);
        //NSV-a
        //NSV-a            newInitData.set(initData, 0);
        //NSV-a            newInitData.set(psshBox, initData.length);
        //NSV-a            newInitDataView.setUint32(moovPos, newInitData.length - moovPos);
        //NSV-a            NXDebug.info(newInitData);
        //NSV-a            return newInitData;
        //NSV-a          }
        //NSV-a        }
        //NSV-a      } else {
        //NSV-a        return initData;
        //NSV-a      }
        //NSV-a    }
        //NSV-a  };
        /* istanbul ignore next */
        this.initializationDataLoads = function (adaptation, callback) {
            var representationCount = 0;
            var periods = adaptation.period.mpd.periods;
            var codec = adaptation.getCodec();
            var convertCodecType = undefined;
            for (var i = 0; i < periods.length; i++) {
                if (i < _this.periodInfo.index - 2 || _this.periodInfo.index + 2 < i) {
                    if (periods[i].start in _this.initializationData) {
                        delete _this.initializationData[periods[i].start];
                    }
                    if (periods[i].start in _this.buffer.initQ) {
                        delete _this.buffer.initQ[periods[i].start];
                    }
                }
            }
            if (_this.periodInfo.start in _this.initializationData) {
                // eslint-disable-line no-empty
            }
            else {
                _this.initializationData[_this.periodInfo.start] = {};
            }
            if (adaptation.index in _this.initializationData[_this.periodInfo.start]) {
                // eslint-disable-line no-empty
            }
            else {
                _this.initializationData[_this.periodInfo.start][adaptation.index] = [];
            }
            if (_this.initializationData[_this.periodInfo.start][adaptation.index]
                .length === 0) {
                if (codec.indexOf('hev1') > -1) {
                    if (_this.videoModel.getCanPlayType(codec) !== 'probably') {
                        convertCodecType = true;
                    }
                }
                _this.initializationData[_this.periodInfo.start][adaptation.index] = [];
                representationCount = _this.availableRepresentations.length;
                for (var i = 0; i < _this.availableRepresentations.length; i++) {
                    _this.indexHandler.getInitializationData(_this.availableRepresentations[i], convertCodecType, _this.initializationData[_this.periodInfo.start][adaptation.index], function (d) {
                        if (d.status === 'ok') {
                            // eslint-disable-line no-empty
                        }
                        else {
                            _this.logHandler.log(d.msg);
                        }
                        representationCount--;
                        if (representationCount === 0) {
                            var initialized_1 = function () {
                                _this.eventBus.dispatchEvent({
                                    type: 'initDataReceived',
                                    data: {
                                        type: _this.type,
                                        initData: _this.initializationData[_this.periodInfo.start][adaptation.index],
                                    },
                                });
                                callback(true);
                            };
                            if (!_this.isDynamic &&
                                _this.silaInsertMode &&
                                _this.dmyData === null) {
                                _this.indexHandler.getFillerData(_this.isProtection, _this.type, _this.availableRepresentations[0].adaptation.getCodec(), 'SILA_INSERT_MODE', function (d) {
                                    if (d.status === 'ok') {
                                        _this.dmyData = d.data;
                                        _this.logHandler.log('[' +
                                            _this.type +
                                            '] dmyData len: ' +
                                            _this.dmyData.byteLength);
                                    }
                                    else {
                                        _this.logHandler.log('[' + _this.type + ']' + d.msg);
                                    }
                                    initialized_1();
                                });
                            }
                            else if (_this.type === 'video' &&
                                _this.bDatInsertMode &&
                                _this.buffer.updating === undefined &&
                                _this.dmyData === null) {
                                _this.indexHandler.getDummyData(_this.isProtection, _this.type, function (d) {
                                    if (d.status === 'ok') {
                                        _this.dmyData = d.data;
                                    }
                                    else {
                                        _this.logHandler.log(d.msg);
                                    }
                                    initialized_1();
                                });
                            }
                            else {
                                initialized_1();
                            }
                        }
                    });
                }
            }
            else {
                callback(true);
            }
        };
        this.setDummy = function () {
            if (_this.silaInsertMode && _this.dmyData !== null) {
                if (_this.buffer.appendBuffer) {
                    _this.buffer.appendBuffer(_this.dmyData);
                }
                else {
                    _this.buffer.append(_this.dmyData);
                }
            }
        };
        this.clearTimer = function () {
            if (_this.buffer.timerId) {
                clearInterval(_this.buffer.timerId);
            }
            _this.appendFromBufferQisProcessing = false;
        };
        this.isTargetType = function (type) {
            if (_this.periodInfo.type === 'video/audio') {
                if (type === 'video') {
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (_this.periodInfo.type === 'video') {
                if (type === 'video') {
                    return true;
                }
            }
            else if (_this.periodInfo.type === 'audio') {
                if (type === 'audio') {
                    return true;
                }
            }
            return false;
        };
        this.convertInitData = function () {
            var ps;
            var aid;
            var q;
            for (ps in _this.initializationData) {
                for (aid in _this.initializationData[ps]) {
                    for (q in _this.initializationData[ps][aid]) {
                        _this.initializationData[ps][aid][q].data =
                            _this.indexHandler.checkAndConvertCodecType(_this.initializationData[ps][aid][q].data);
                    }
                }
            }
            for (ps in _this.buffer.initQ) {
                for (aid in _this.buffer.initQ[ps]) {
                    for (q in _this.buffer.initQ[ps][aid]) {
                        _this.buffer.initQ[ps][aid][q].data =
                            _this.indexHandler.checkAndConvertCodecType(_this.buffer.initQ[ps][aid][q].data);
                    }
                }
            }
        };
        // NSV-a  const updateForLiveEdge = (liveEdgeTime) => {};
        // liveMulti
        this.updateForLiveEdgeMPD = function () {
            _this.NXDebug.debug('================= updateForLiveEdge ====================================');
            var startTime = _this.periodInfo.mpd.liveEdgeE;
            _this.indexHandler.updateForLiveEdgeMPD(_this.type, _this.periodInfo);
            _this.setMSEDuration.call(_this, _this.periodInfo.mpd.liveEdge, 'updateForLiveEdgeMPD');
            _this.NXDebug.debug('liveEdge:' +
                _this.periodInfo.mpd.liveEdge +
                ', minBufferTime:' +
                _this.minBufferTime +
                ', startTime:' +
                startTime +
                ', dur:' +
                _this.mediaSource.duration);
            return startTime;
        };
        // liveMulti
        this.getPlaybackQuality = function () {
            var totalBufferLevel = _this.bufferLevel +
                _this.sourceBufferExt.dataQduration(_this.buffer, _this.isSegmentTemplate);
            var aborted = _this.checkLoadingRequests.call(_this, _this.type, totalBufferLevel);
            var qResult = _this.abrController.getPlaybackQuality(_this.type, _this.currentAdaptation, _this.metrics, totalBufferLevel, aborted, _this.stalled);
            var quality = qResult.quality;
            var qualityChanged = false;
            var newQuality;
            var now = new Date();
            if (quality !== undefined) {
                newQuality = quality;
            }
            qualityChanged = quality !== _this.requiredQuality;
            if (qualityChanged === true) {
                _this.requiredQuality = newQuality;
                // The quality has beeen changed so we should abort the requests that has not been loaded yet
                if (_this.type === 'video') {
                    _this.cancelPendingRequests.call(_this, _this.type, _this.UPDATE, 7);
                }
                _this.currentRepresentation = _this.getRepresentationForQuality.call(self, newQuality);
                if (_this.currentRepresentation === null ||
                    _this.currentRepresentation === undefined) {
                    throw 'Unexpected error!';
                }
                _this.isSegmentTemplate =
                    _this.currentRepresentation.segmentInfoType === 'SegmentTemplate';
                _this.clearPlayListTraceMetrics(now, _this.REPRESENTATION_SWITCH_STOP_REASON);
                _this.metrics.addRepresentationSwitch(_this.type, now, _this.videoModel.getCurrentTime(), _this.currentRepresentation.id, undefined);
            }
            return quality;
        };
        /* istanbul ignore next */
        this.validate = function () {
            var self = _this;
            var currentVideoTime = _this.videoModel.getCurrentTime();
            _this.updateBufferLevel.call(self);
            if (_this.type === 'video') {
                _this.logHandler.log_item('ctime', 'time: ' +
                    new Number(currentVideoTime).toFixed(2) +
                    ', dur: ' +
                    (isFinite(_this.videoModel.getDuration())
                        ? new Number(_this.videoModel.getDuration()).toFixed(2)
                        : _this.videoModel.getDuration()));
                _this.logHandler.log_item('vlog', _this.type +
                    ' len: ' +
                    _this.buffer.buffered.length +
                    ', buffer: ' +
                    parseInt(String(_this.bufferLevel * 100.0)) / 100.0);
            }
            else {
                _this.logHandler.log_item('alog', _this.type +
                    ' len: ' +
                    _this.buffer.buffered.length +
                    ', buffer: ' +
                    parseInt(String(_this.bufferLevel * 100.0)) / 100.0);
            }
            _this.logHandler.log_slider(currentVideoTime, _this.videoModel.getDuration());
            _this.checkIfSufficientBuffer.call(self);
            if (!_this.isSchedulingRequired.call(self) &&
                !_this.initialPlayback &&
                !_this.waitingForBuffer) {
                _this.stop.call(self);
                return;
            }
            if (_this.bufferLevel <= _this.STALL_THRESHOLD &&
                !_this.stalled &&
                !_this.videoModel.onAdjusting()) {
                if (_this.tlen > _this.STALL_THRESHOLD) {
                    _this.videoModel.adjustCurrentTime(function (t) {
                        _this.logHandler.log('skip small buffer gap.' + t);
                    });
                }
                else {
                    _this.NXDebug.log('Stalling ' + _this.type + ' Buffer: ' + _this.bufferLevel);
                    _this.clearPlayListTraceMetrics(new Date(), _this.REBUFFERING_REASON);
                    _this.stalled = true;
                    _this.waitingForBuffer = true;
                    _this.bufferStartThreshold = Math.min(_this.minBufferTime || _this.DEFAULT_MIN_BUFFER_TIME, _this.getTimeToEnd());
                    _this.cancelPendingRequests.call(_this, _this.type, _this.RESET, 8);
                    _this.stallStream.call(self, _this.stalled, 6);
                    if (_this.abrController.getAutoSwitchBitrate()) {
                        _this.abrController.setPlaybackQuality(_this.type, 0);
                    }
                }
            }
            if (_this.state === _this.READY) {
                _this.setState.call(self, _this.VALIDATING);
                var manifestMinBufferTime = _this.manifestModel.getValue().mpd.minBufferTime;
                var minBufferTarget = _this.decideBufferLength.call(self, manifestMinBufferTime, _this.periodInfo.duration);
                _this.setMinBufferTime(minBufferTarget);
                _this.abrController.setMinBufferTime(minBufferTarget);
                var quality = _this.getPlaybackQuality.call(self);
                _this.getRequiredFragmentCount.call(self, quality, function (count) {
                    if (count === -1) {
                        _this.fragmentsToLoad = 0;
                        _this.setIncrementalMode.call(self, false, 10);
                    }
                    else {
                        _this.fragmentsToLoad =
                            count > 0 || _this.buffer.underThreshold == false ? count : 1;
                    }
                    _this.requestNewFragment.call(self);
                });
                if (_this.isDynamic) {
                    _this.setMSEDuration.call(self, _this.periodInfo.mpd.liveEdge, 'validate');
                }
            }
            else if (_this.state === _this.VALIDATING) {
                _this.setState.call(self, _this.READY);
            }
        };
        this.getVideoModel = function () {
            return _this.videoModel;
        };
        this.STALL_THRESHOLD = 0.1;
        //PlayList
        this.INITIAL_PLAY_START_REASON = 'initial_start';
        this.SEEK_START_REASON = 'seek';
        //PlayList.Trace
        this.USER_REQUEST_STOP_REASON = 'user_request';
        this.REPRESENTATION_SWITCH_STOP_REASON = 'representation_switch';
        this.REBUFFERING_REASON = 'rebuffering';
        this.WAITING = 'WAITING';
        this.READY = 'READY';
        this.VALIDATING = 'VALIDATING';
        this.LOADING = 'LOADING';
        this.RESET = 1;
        this.UPDATE = 2;
        this.NOCHANGE = 3;
        this.updateDataReason = _StreamController__WEBPACK_IMPORTED_MODULE_0__.UpdateDataReason;
        this.state = this.WAITING;
        this.ready = false;
        this.started = false;
        this.waitingForBuffer = false;
        this.initialPlayback = true;
        this.playbackStarted = false;
        this.initializationData = [];
        this.seeking = false;
        this.seekTarget = -1;
        this.isSegmentTemplate = false;
        this.requiredQuality = -1;
        this.currentQuality = -1;
        this.stalled = false;
        this.isDynamic = false;
        this.isBufferingCompleted = false;
        this.isStreamCompleted = false;
        //NSV-a  this.initIsLoading = false;
        this.preAppendTime = -1;
        this.periodInfo = null;
        this.fragmentsToLoad = 0;
        this.fragmentModel = null;
        this.bufferLevel = 0;
        this.tlen = 0;
        this.fragmentDuration = 0;
        this.appendFromBufferQisProcessing = false;
        this.liveEdgeSearchRange = {
            start: null,
            end: null,
        };
        this.liveEdgeInitialSearchPosition = null;
        this.liveEdgeSearchStep = null;
        this.useBinarySearch = false;
        this.setLiveStartTime = false;
        this.currentAdaptation = null;
        this.buffer = null;
        this.forceDefaultMBT = false;
        this.useFetch = false;
        this.listenToCanplay = false;
        this.bDatInsertMode = false;
        this.silaInsertMode = false;
        this.ullMode = false;
        this.dmyData = null;
        this.isProtection = false;
        this.tolerance = 0.15;
        this.incrementalMode = false;
        this.playListMetrics = null;
        this.playListTraceMetrics = null;
        this.playListTraceMetricsClosed = true;
        this.scheduleWhilePaused = false;
        this.SCHEDULE_EXECUTE_INTERVAL = 500;
        this.isScheduled = false;
        this.bufferState = 0;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }
    /* istanbul ignore next */
    BufferController.prototype.initialize = function (params, type, periodInfo, data, buffer, videoModel, fragmentController, source, _eventBus, _manifestModel, _metricsModel, _abrController, _sourceBufferExt, _indexHandler, _iniStartTime, callback) {
        var _this = this;
        var self = this;
        var manifest;
        self.setMediaSource(source);
        self.setVideoModel(videoModel);
        self.setType(type);
        self.setBuffer(buffer);
        self.setFragmentController(fragmentController);
        this.eventBus = _eventBus;
        this.manifestModel = _manifestModel;
        this.metricsModel = _metricsModel;
        this.abrController = _abrController;
        this.sourceBufferExt = _sourceBufferExt;
        this.indexHandler = _indexHandler;
        this.fragmentModel = fragmentController.attachBufferController(self);
        fragmentController.prepareFragmentForLoading(self, this.onBytesLoadingStart, this.onBytesLoaded, this.onBytesError, this.signalStreamComplete, this.onFirstChunkLoaded, this.onChunkLoaded, this.onChunkLoadedError);
        this.sourceBufferExt.attachBuffer(this.buffer);
        this.metrics = this.metricsModel.getMetricsFor(this.type);
        this.listenToCanplay =
            params.LISTEN_TO_CANPLAY_AFTER_SEEK !== undefined
                ? params.LISTEN_TO_CANPLAY_AFTER_SEEK
                : false;
        this.bDatInsertMode =
            params.BDAT_INSERT_MODE !== undefined && type === 'video'
                ? params.BDAT_INSERT_MODE
                : false;
        this.silaInsertMode =
            params.SILA_INSERT_MODE !== undefined ? params.SILA_INSERT_MODE : false;
        this.MSE_APPEND_ENABLE_THRESHOLD =
            type == 'video'
                ? 'MSE_APPEND_ENABLE_THRESHOLD_V' in params
                    ? params['MSE_APPEND_ENABLE_THRESHOLD_V']
                    : params['MSE_APPEND_ENABLE_THRESHOLD'] || 5
                : 'MSE_APPEND_ENABLE_THRESHOLD_A' in params
                    ? params['MSE_APPEND_ENABLE_THRESHOLD_A']
                    : params['MSE_APPEND_ENABLE_THRESHOLD'] || 5;
        this.DEFAULT_MIN_BUFFER_TIME =
            params.DEFAULT_MIN_BUFFER_TIME !== undefined
                ? params.DEFAULT_MIN_BUFFER_TIME
                : 0.6;
        this.forceDefaultMBT = params.FORCE_DEFAULT_MBT || false;
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.BUFFER_PREFETCH_THRESHOLD =
            type == 'video'
                ? 'BUFFER_PREFETCH_THRESHOLD_V' in params
                    ? params['BUFFER_PREFETCH_THRESHOLD_V']
                    : params['BUFFER_PREFETCH_THRESHOLD'] || 15
                : 'BUFFER_PREFETCH_THRESHOLD_A' in params
                    ? params['BUFFER_PREFETCH_THRESHOLD_A']
                    : params['BUFFER_PREFETCH_THRESHOLD'] || 15;
        this.EXTRACT_ALL_IDR_IN_MOOF = params.EXTRACT_ALL_IDR_IN_MOOF || false;
        this.DEV_TYPE = params.DEV_TYPE || 'NORMAL';
        this.STORE_MEASURED_DATA = params.STORE_MEASURED_DATA || false;
        this.START_FROM_MPDTOP_FORLIVE = params.START_FROM_MPDTOP_FORLIVE || false;
        this.ullMode = 'ULL_MODE' in params ? params['ULL_MODE'] : false;
        if (this.STORE_MEASURED_DATA) {
            this.metrics.setStoreMeasuredData(this.STORE_MEASURED_DATA);
        }
        if (this.type === 'video') {
            this.tolerance = Math.ceil(1000 / data.getFrameRate()) / 1000;
        }
        else {
            this.tolerance =
                Math.ceil((1000 * 1024) / data.getAudioSamplingRate()) / 1000;
        }
        this.videoModel.setEpsilonFor(this.type, this.tolerance);
        this.indexHandler.setEpsilonFor(this.type, this.tolerance);
        this.eventBus.addEventListener('appendedEnoughDataToStart', this.onAppendedEnoughDataToStart.bind(this));
        this.eventBus.addEventListener('needToModifyOffset', this.onNeedToModifyOffset.bind(this));
        this.eventBus.addEventListener('checkBufferGap', this.onCheckBufferGap.bind(this));
        manifest = this.manifestModel.getValue();
        this.isDynamic = this.manifestModel.getIsDynamic(manifest);
        this.isStreamCompleted = false;
        this.abrController.setMaxQualityIndex(this.type, data.representations.length);
        this.indexHandler.setupRequestStatus(this.type);
        MSE_ver(buffer);
        this.videoModel.setSourceBuffer(this.type, buffer);
        this.isProtection = data.getContentProtectionData() === null ? false : true;
        buffer.queue = [];
        buffer.updatingRange = {
            start: 0,
            end: 0,
        };
        buffer.laData = null;
        buffer.initQ = {};
        buffer.quality = -1;
        buffer.asetIdx = -1;
        buffer.appendStart = false;
        buffer.type = this.type;
        buffer.timerId = null;
        this.appendFromBufferQisProcessing = false;
        buffer.lastAppendtime = -1;
        buffer.preDur = 0;
        buffer.pStart = -1;
        buffer.underThreshold = false;
        buffer.startTimeAfterSeek = Number.MAX_VALUE;
        buffer.offset = periodInfo.start;
        buffer.level = 0;
        if (!this.videoModel.isDummy()) {
            if (buffer.updating !== undefined) {
                this.appendFromBufferQ = this.appendFromBufferQForAB;
                //buffer.timerId = setInterval(appendFromBufferQForAB.bind(self), 500);
                buffer.timerId = setInterval(this.appendFromBufferQ.bind(self), 500);
                buffer.addEventListener('updateend', function (_e) {
                    // eslint-disable-line no-unused-vars
                    if (_this.isDynamic)
                        _this.setMSEDuration.call(self, periodInfo.mpd.liveEdge, 'updateend');
                    var ranges = _this.sourceBufferExt.getAllRanges(buffer);
                    if (ranges) {
                        if (ranges.length > 0) {
                            for (var i = 0, len = ranges.length; i < len; i += 1) {
                                _this.NXDebug.log('[' +
                                    _this.type +
                                    '] Buffered Range[' +
                                    i +
                                    ']: ' +
                                    ranges.start(i) +
                                    ' - ' +
                                    ranges.end(i) +
                                    ', state:' +
                                    _this.videoModel.getReadyState() +
                                    ', c:' +
                                    _this.videoModel.getCurrentTime() +
                                    ', paused:' +
                                    _this.videoModel.isPaused());
                            }
                        }
                    }
                    _this.updateBufferLevel.call(self);
                    //appendFromBufferQForAB.call(self);
                });
            }
            else {
                this.appendFromBufferQ = this.appendFromBufferQv01;
                buffer.timerId = setInterval(this.appendFromBufferQ.bind(self), 500);
            }
        }
        else {
            this.appendFromBufferQ = function () { };
        }
        self.updateData(this.updateDataReason.INITIAL_UPDATE, data, periodInfo, _iniStartTime, function (f) {
            if (f.status == 'ok') {
                if (!_this.isDynamic) {
                    _this.ready = true;
                    _this.startPlayback.call(self);
                    callback({
                        status: 'ok',
                        data: f.data,
                    });
                    return;
                }
                //liveMulti
                _this.NXDebug.debug('================= searchForLiveEdge ====================================');
                var startTime_1;
                var segmentStart_1;
                if (_this.setLiveStartTime == false &&
                    _this.START_FROM_MPDTOP_FORLIVE == true) {
                    startTime_1 = periodInfo.mpd.liveEdgeS;
                }
                else {
                    //liveMulti
                    if (!isNaN(_iniStartTime)) {
                        startTime_1 = _iniStartTime;
                        if (startTime_1 < periodInfo.mpd.liveEdgeS) {
                            startTime_1 = periodInfo.mpd.liveEdgeS;
                        }
                        if (startTime_1 > periodInfo.mpd.liveEdgeE) {
                            startTime_1 = periodInfo.mpd.liveEdgeE;
                        }
                    }
                    else {
                        startTime_1 = Math.max(periodInfo.mpd.liveEdgeE, periodInfo.mpd.liveEdgeS);
                    }
                    //liveMulti
                }
                _this.indexHandler.getSegmentRequestForTime(_this.currentRepresentation, startTime_1, _this.type, 3, function (d) {
                    if (d.status === 'ok') {
                        var request = d.data;
                        segmentStart_1 = request.startTime;
                        //const tst: number = segmentStart;
                        var tst = _this.ullMode == true ? startTime_1 : segmentStart_1;
                        if (isNaN(periodInfo.mpd.liveEdgeC) ||
                            tst > periodInfo.mpd.liveEdgeC) {
                            periodInfo.liveEdgeC = tst;
                            //liveMulti
                            periodInfo.mpd.liveEdgeC = tst;
                            //liveMulti
                        }
                        else {
                            // eslint-disable-line no-empty
                        }
                        if (!_this.setLiveStartTime) {
                            //liveMulti
                            var st = _this.START_FROM_MPDTOP_FORLIVE == true
                                ? periodInfo.mpd.liveEdgeS
                                : periodInfo.mpd.liveEdgeC;
                            //liveMulti
                            if (isNaN(_this.videoModel.getStartTime())) {
                                _this.videoModel.setStartTime(st);
                            }
                            else {
                                if (st > _this.videoModel.getStartTime()) {
                                    _this.videoModel.setStartTime(st);
                                }
                            }
                            _this.setLiveStartTime = true;
                        }
                        _this.ready = true;
                        if (_this.DEV_TYPE === 'xxxxxx') {
                            _this.indexHandler.getFillerData(_this.isProtection, _this.type, _this.currentRepresentation.adaptation.getCodec(), 'FILL_UP_THE_HEAD', function (d) {
                                if (d.status === 'ok') {
                                    _this.dmyData = d.data;
                                    _this.logHandler.log('dmyData len: ' + _this.dmyData.byteLength);
                                    buffer.appendBuffer(_this.dmyData);
                                }
                                else {
                                    _this.logHandler.log(d.msg);
                                }
                                callback({
                                    status: 'ok',
                                    data: segmentStart_1,
                                });
                            });
                        }
                        else {
                            callback({
                                status: 'ok',
                                data: segmentStart_1,
                            });
                        }
                    }
                    else {
                        callback({
                            status: 'fail',
                            msg: d.msg,
                        });
                    }
                });
            }
            else {
                callback({
                    status: 'fail',
                    msg: f.msg,
                });
            }
        });
        this.indexHandler.setIsDynamic(this.isDynamic);
        self.setMinBufferTime(this.decideBufferLength.call(self, manifest.mpd.minBufferTime, periodInfo.duration
        // this.waitingForBuffer
        ));
    };
    /* istanbul ignore next */
    BufferController.prototype.update = function (_buffer, _videoModel, _source, convertCodecType) {
        var _this = this;
        if (convertCodecType === void 0) { convertCodecType = false; }
        _buffer.queue = this.buffer.queue;
        _buffer.updatingRange = this.buffer.updatingRange;
        _buffer.laData = this.buffer.laData;
        _buffer.initQ = this.buffer.initQ;
        _buffer.quality = this.buffer.quality;
        _buffer.asetIdx = this.buffer.asetIdx;
        _buffer.appendStart = this.buffer.appendStart;
        _buffer.type = this.buffer.type;
        _buffer.timerId = this.buffer.timerId;
        _buffer.lastAppendtime = this.buffer.lastAppendtime;
        _buffer.preDur = this.buffer.preDur;
        _buffer.pStart = this.buffer.pStart;
        _buffer.startTimeAfterSeek = this.buffer.startTimeAfterSeek;
        _buffer.offset = this.buffer.offset;
        _buffer.level = this.buffer.level;
        _buffer.underThreshold = this.buffer.underThreshold;
        this.sourceBufferExt.detachBuffer(this.buffer);
        this.setBuffer(_buffer);
        this.sourceBufferExt.attachBuffer(_buffer);
        this.setMediaSource(_source);
        this.setVideoModel(_videoModel);
        if (convertCodecType) {
            this.convertInitData.call(this);
        }
        if (this.buffer.updating !== undefined) {
            if (this.buffer.timerId != null) {
                clearInterval(this.buffer.timerId);
            }
            this.appendFromBufferQ = this.appendFromBufferQForAB;
            this.buffer.timerId = setInterval(this.appendFromBufferQ.bind(self), 500);
            this.buffer.addEventListener('updateend', function (_e) {
                var ranges = _this.sourceBufferExt.getAllRanges(_this.buffer);
                if (ranges) {
                    if (ranges.length > 0) {
                        var len = ranges.length;
                        for (var i = 0; i < len; i += 1) {
                            _this.NXDebug.log('[' +
                                _this.type +
                                '] Buffered Range[' +
                                i +
                                ']: ' +
                                ranges.start(i) +
                                ' - ' +
                                ranges.end(i) +
                                ', state:' +
                                _this.videoModel.getReadyState() +
                                ', c:' +
                                _this.videoModel.getCurrentTime() +
                                ', paused:' +
                                _this.videoModel.isPaused());
                        }
                    }
                }
                _this.updateBufferLevel.call(self);
                //appendFromBufferQForAB.call(self);
            });
        }
        else {
            if (this.buffer.timerId != null) {
                clearInterval(this.buffer.timerId);
            }
            this.appendFromBufferQ = this.appendFromBufferQv01;
            this.buffer.timerId = setInterval(this.appendFromBufferQ.bind(self), 500);
        }
    };
    BufferController.prototype.getType = function () {
        return this.type;
    };
    BufferController.prototype.setType = function (value) {
        this.type = value;
    };
    BufferController.prototype.getPeriodInfo = function () {
        return this.periodInfo;
    };
    BufferController.prototype.setVideoModel = function (value) {
        this.videoModel = value;
    };
    // getFragmentController(): FragmentController {
    //   return this.fragmentController!;
    // }
    BufferController.prototype.setFragmentController = function (value) {
        this.fragmentController = value;
    };
    BufferController.prototype.getAutoSwitchBitrate = function () {
        return this.abrController.getAutoSwitchBitrate();
    };
    // setAutoSwitchBitrate(value: boolean): void {
    //   this.abrController!.setAutoSwitchBitrate(value);
    // }
    BufferController.prototype.getData = function () {
        return this.currentAdaptation;
    };
    /* istanbul ignore next */
    BufferController.prototype.updateData = function (reason, dataValue, periodInfoValue, curTime, _callback) {
        var _this = this;
        var self = this;
        var callback = _callback || (function () { });
        var from = this.currentAdaptation;
        var currentSegments = null;
        var dynamicPeriodChange = false;
        var initReceived = false;
        if (!from) {
            from = dataValue;
        }
        this.currentAdaptation = dataValue;
        this.stop.call(self);
        this.NXDebug.info(reason);
        this.availableRepresentations = dataValue.getRepresentations();
        this.isDynamic = this.manifestModel.getIsDynamic(this.manifestModel.getValue());
        this.indexHandler.setIsDynamic(this.isDynamic);
        if (this.isDynamic) {
            //liveMulti
            if (this.currentRepresentation != null &&
                this.currentRepresentation.adaptation.period.id == periodInfoValue.id) {
                currentSegments = this.currentRepresentation
                    ? this.currentRepresentation.segments
                    : null;
            }
            else {
                this.currentRepresentation = null;
            }
            if (reason === this.updateDataReason.PERIOD_CHANGE) {
                this.indexHandler.setupRequestStatus(dataValue.type);
                this.requiredQuality = -1;
                this.currentQuality = -1;
                dynamicPeriodChange = true;
            }
            else if (reason === this.updateDataReason.MPD_UPDATE) {
                if (this.periodInfo != null &&
                    this.periodInfo.start != periodInfoValue.start) {
                    this.indexHandler.setupRequestStatus(dataValue.type);
                    this.requiredQuality = -1;
                    this.currentQuality = -1;
                    this.setIncrementalMode.call(self, false, 11);
                    dynamicPeriodChange = true;
                }
            }
            //liveMulti
        }
        else {
            if (reason === this.updateDataReason.MPD_UPDATE) {
                this.initializationData = [];
                this.buffer.initQ = {};
                this.buffer.queue = [];
                this.buffer.quality = -1;
                this.buffer.laData = null;
            }
            this.currentRepresentation = null;
            this.indexHandler.setupRequestStatus(dataValue.type);
            this.requiredQuality = -1;
            this.currentQuality = -1;
        }
        this.periodInfo = periodInfoValue;
        this.abrController.matchingQualityBetweenDifferentAdaptation(from, dataValue);
        //@ts-ignore
        var qResult = this.abrController.getPlaybackQuality(this.type, dataValue, this.metrics);
        if (!this.currentRepresentation) {
            this.currentRepresentation = this.getRepresentationForQuality.call(self, qResult.quality);
            this.isSegmentTemplate =
                this.currentRepresentation.segmentInfoType === 'SegmentTemplate';
        }
        this.initializationDataLoads.call(self, dataValue, function () {
            initReceived = true;
        });
        this.indexHandler.getCurrentTime(this.currentRepresentation, curTime, function (d) {
            var handler = function () {
                _this.eventBus.removeEventListener('initDataReceived', handler);
                if (d.status === 'ok') {
                    var time = d.data;
                    _this.requiredQuality = qResult.quality;
                    _this.currentRepresentation = _this.getRepresentationForQuality.call(self, qResult.quality);
                    _this.isSegmentTemplate =
                        _this.currentRepresentation.segmentInfoType === 'SegmentTemplate';
                    if (_this.isDynamic) {
                        _this.currentRepresentation.segments = currentSegments;
                    }
                    if (_this.isDynamic) {
                        if (dynamicPeriodChange == false) {
                            _this.indexHandler.updateSegmentList(_this.currentRepresentation, function (d) {
                                if (d.status === 'ok') {
                                    var requestedTimeFromCurrentIndex = d.data;
                                    var startTime = void 0;
                                    startTime = _this.updateForLiveEdgeMPD.call(self);
                                    //liveMulti
                                    if (requestedTimeFromCurrentIndex === -1) {
                                        _this.indexHandler.setupRequestStatus(dataValue.type);
                                        _this.setIncrementalMode.call(self, false, 12);
                                        _this.start.call(self, 4444);
                                        callback({
                                            status: 'ok',
                                            data: startTime,
                                        });
                                    }
                                    else {
                                        _this.start.call(self, 4444);
                                        callback({
                                            status: 'ok',
                                            data: startTime,
                                        });
                                    }
                                }
                                else {
                                    _this.NXDebug.debug('ERROR:' + d.msg);
                                    callback({
                                        status: 'fail',
                                        msg: d.msg,
                                    });
                                }
                            });
                        }
                        else {
                            _this.setIncrementalMode.call(self, false, 13);
                            callback({
                                status: 'ok',
                                data: time,
                            });
                        }
                    }
                    else if (reason === _this.updateDataReason.MPD_UPDATE) {
                        _this.fragmentController.clearAllRequestsForModel(_this.fragmentModel);
                        _this.fragmentModel.abortRequests(true);
                        _this.setIncrementalMode.call(self, false, 14);
                        _this.start.call(self, 4444);
                        callback({
                            status: 'ok',
                            data: time,
                        });
                    }
                    else if (reason === _this.updateDataReason.INITIAL_UPDATE) {
                        if (_this.type == 'video') {
                            self.getSegmentStartTime(time, function (t) {
                                callback({
                                    status: 'ok',
                                    data: t,
                                });
                            });
                        }
                        else {
                            callback({
                                status: 'ok',
                                data: time,
                            });
                        }
                    }
                    else if (reason == _this.updateDataReason.ADAPTATION_CHANGE) {
                        _this.fragmentController.clearAllRequestsForModel(_this.fragmentModel);
                        _this.fragmentModel.abortRequests(true);
                        _this.setIncrementalMode.call(self, false, 15);
                        _this.buffer.queue = [];
                        _this.buffer.quality = -1;
                        _this.start.call(self, 4444);
                        callback({
                            status: 'ok',
                            data: time,
                        });
                    }
                    else if (reason == _this.updateDataReason.PERIOD_CHANGE) {
                        _this.setIncrementalMode.call(self, false, 16);
                        callback({
                            status: 'ok',
                            data: time,
                        });
                    }
                    else {
                        _this.seek.call(self, time, '[' + _this.type + '] end of initialize');
                        callback({
                            status: 'ok',
                            data: time,
                        });
                    }
                }
                else {
                    _this.logHandler.log('ERROR:::' + d.msg);
                    callback({
                        status: 'fail',
                        msg: 'updateData ERROR',
                    });
                }
            };
            if (initReceived) {
                handler();
            }
            else {
                _this.eventBus.addEventListener('initDataReceived', handler);
            }
        });
    };
    // getCurrentRepresentation(): Nullable<Representation> {
    //   return this.currentRepresentation!;
    // }
    BufferController.prototype.getBuffer = function () {
        return this.buffer;
    };
    BufferController.prototype.setBuffer = function (value) {
        this.buffer = value;
    };
    // getMinBufferTime(): number {
    //   return this.minBufferTime!;
    // }
    BufferController.prototype.setMinBufferTime = function (value) {
        this.minBufferTime = value;
    };
    BufferController.prototype.setMediaSource = function (value) {
        this.mediaSource = value;
    };
    BufferController.prototype.isReady = function () {
        return this.state === this.READY;
    };
    // isStopped(): boolean {
    //   return this.started === false;
    // }
    BufferController.prototype.clearMetrics = function () {
        if (this.type === null || this.type === '') {
            return;
        }
        this.metrics = null;
    };
    BufferController.prototype.updateBufferState = function () {
        var self = this;
        this.updateBufferLevel.call(self);
    };
    BufferController.prototype.updateStalledState = function () {
        this.stalled = this.videoModel.isStalled();
        this.checkIfSufficientBuffer.call(this);
    };
    BufferController.prototype.setStalledState = function (value) {
        this.stalled = value;
        this.waitingForBuffer = value;
        this.bufferStartThreshold = Math.min(this.minBufferTime || this.DEFAULT_MIN_BUFFER_TIME, this.getTimeToEnd());
        this.stallStream.call(this, this.stalled, 7);
        if (this.stalled) {
            if (this.abrController.getAutoSwitchBitrate()) {
                this.abrController.setPlaybackQuality(this.type, 0);
            }
        }
    };
    BufferController.prototype.appendFromQ = function () {
        this.appendFromBufferQ.call(this);
    };
    BufferController.prototype.reset = function (errored) {
        var self = this;
        //NSV-a      cancel = function cancelDeferred(d) {
        //NSV-a        if (d) {
        //NSV-a          d.reject();
        //NSV-a          d = null;
        //NSV-a        }
        //NSV-a      };
        this.stop.call(self);
        //NSV-a      initIsLoading = false;
        this.isStreamCompleted = false;
        self.clearMetrics();
        this.fragmentController.abortRequestsForModel(this.fragmentModel);
        this.fragmentController.detachBufferController(this.fragmentModel);
        this.fragmentModel = null;
        this.initializationData = [];
        this.initialPlayback = true;
        this.playbackStarted = false;
        this.liveEdgeSearchRange = {
            start: null,
            end: null,
        };
        this.liveEdgeInitialSearchPosition = null;
        this.useBinarySearch = false;
        this.liveEdgeSearchStep = null;
        this.setLiveStartTime = false;
        this.currentRepresentation = null;
        this.isSegmentTemplate = false;
        this.requiredQuality = -1;
        this.currentQuality = -1;
        this.stalled = false;
        this.isDynamic = false;
        this.isBufferingCompleted = false;
        this.preAppendTime = -1;
        if (!errored) {
            this.sourceBufferExt.abort(this.mediaSource, this.buffer);
            this.sourceBufferExt.removeSourceBuffer(this.mediaSource, this.buffer);
        }
        this.buffer.queue = [];
        this.buffer.updatingRange = {
            start: 0,
            end: 0,
        };
        this.buffer.initQ = {};
        if (this.buffer.timerId) {
            clearInterval(this.buffer.timerId);
        }
        this.buffer.timerId = null;
        this.appendFromBufferQisProcessing = false;
        this.buffer.quality = -1;
        this.buffer.underThreshold = false;
        this.buffer.appendStart = false;
        this.currentAdaptation = null;
        this.buffer = null;
        if (this.requestScheduler) {
            clearInterval(this.requestScheduler);
            this.requestScheduler = null;
        }
        this.isScheduled = false;
    };
    BufferController.prototype.getBufferState = function () {
        return this.bufferState;
    };
    BufferController.prototype.getSegmentStartTime = function (time, _callback) {
        var _this = this;
        var callback = _callback;
        this.indexHandler.getSegmentRequestForTime(this.currentRepresentation, time, this.type, 9, function (d) {
            if (d.status === 'ok') {
                var request = d.data;
                if (request === null) {
                    callback(time);
                }
                else {
                    callback(request.startTime);
                }
            }
            else {
                _this.logHandler.log('ERROR: getSegmentsStartTime ' + d.msg);
                callback(time);
            }
        });
    };
    BufferController.prototype.getTolerance = function () {
        return this.tolerance;
    };
    BufferController.prototype.getIsStreamCompleted = function () {
        return this.isStreamCompleted;
    };
    return BufferController;
}());

//NSV-a BufferControllerParameterSets = () => {};


/***/ }),

/***/ "./ts/dash/streaming/FragmentController.ts":
/*!*************************************************!*\
  !*** ./ts/dash/streaming/FragmentController.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FragmentController": function() { return /* binding */ FragmentController; }
/* harmony export */ });
/* harmony import */ var _FragmentModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FragmentModel */ "./ts/dash/streaming/FragmentModel.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * FragmentController
 *
 * @module FragmentController（FragmentControllerモジュール）
 */
/**
 * FragmentController
 * @constructor
 */
var FragmentController = /** @class */ (function () {
    function FragmentController(params, eventBus, metricsModel, xhrCustom) {
        var _this = this;
        this.findModel = function (bufferController) {
            var ln = _this.fragmentModels.length;
            // We expect one-to-one relation between FragmentModel and BufferController,
            // so just compare the given BufferController object with the one that stored in the model to find the model for it
            for (var i = 0; i < ln; i++) {
                if (_this.fragmentModels[i].getContext() == bufferController) {
                    return _this.fragmentModels[i];
                }
            }
            return null;
        };
        //NSV-a const isReadyToLoadNextFragment = () => {
        //NSV-a   let isReady = true;
        //NSV-a   const ln = fragmentModels.length;
        //NSV-a   // Loop through the models and check if all of them are in the ready state
        //NSV-a   for (let i = 0; i < ln; i++) {
        //NSV-a     if (!fragmentModels[i].isReady()) {
        //NSV-a       isReady = false;
        //NSV-a       break;
        //NSV-a     }
        //NSV-a   }
        //NSV-a
        //NSV-a   return isReady;
        //NSV-a };
        // executeRequests2 = (): void => {
        //   for (let i = 0; i < this.fragmentModels.length; i++) {
        //     if (this.fragmentModels[i].isReady()) {
        //       this.fragmentModels[i].executeCurrentRequest();
        //     }
        //   }
        // };
        //NSV-a const executeRequests = () => {
        //NSV-a   for (let i = 0; i < fragmentModels.length; i++) {
        //NSV-a     fragmentModels[i].executeCurrentRequest();
        //NSV-a   }
        //NSV-a };
        //NSV-a const checkForExistence = (request, _callback) => {
        //NSV-a   const callback = _callback || (() => {});
        //NSV-a   if (!request) {
        //NSV-a     callback({
        //NSV-a       status: 'ok',
        //NSV-a       data: null,
        //NSV-a     });
        //NSV-a     return;
        //NSV-a   }
        //NSV-a
        //NSV-a   const req = new XMLHttpRequest();
        //NSV-a   let isSuccessful = false;
        //NSV-a
        //NSV-a   req.open('HEAD', request.url, true);
        //NSV-a
        //NSV-a   req.onload = () => {
        //NSV-a     if (req.status < 200 || req.status > 299) {
        //NSV-a     } else {
        //NSV-a       isSuccessful = true;
        //NSV-a
        //NSV-a       callback({
        //NSV-a         status: 'ok',
        //NSV-a         data: request,
        //NSV-a       });
        //NSV-a     }
        //NSV-a   };
        //NSV-a
        //NSV-a   req.onloadend = req.onerror = () => {
        //NSV-a     if (!isSuccessful) {
        //NSV-a       callback({
        //NSV-a         status: 'error',
        //NSV-a         msg: 'checkForExistence error',
        //NSV-a       });
        //NSV-a     }
        //NSV-a   };
        //NSV-a
        //NSV-a   req.send();
        //NSV-a };
        this.attachBufferController = function (bufferController) {
            if (!bufferController)
                return null;
            // Wrap the buffer controller into model and store it to track the loading state and execute the requests
            var model = _this.findModel(bufferController);
            if (!model) {
                model = new _FragmentModel__WEBPACK_IMPORTED_MODULE_0__.FragmentModel(_this.params, _this.eventBus, _this.metricsModel.getMetricsFor(bufferController.getType()), _this.xhrCustom);
                model.setContext(bufferController);
                _this.fragmentModels.push(model);
            }
            return model;
        };
        this.detachBufferController = function (bufferController) {
            var idx = _this.fragmentModels.indexOf(bufferController);
            // If we have the model for the given buffer just remove it from array
            if (idx > -1) {
                _this.fragmentModels.splice(idx, 1);
            }
        };
        // onBufferControllerStateChange = (): void => {
        //   this.executeRequests2.call(this);
        // };
        this.isFragmentLoadedOrPending = function (bufferController, request) {
            var fragmentModel = _this.findModel(bufferController);
            var isLoaded;
            if (!fragmentModel) {
                return false;
            }
            isLoaded = fragmentModel.isFragmentLoadedOrPending(request, bufferController.getBuffer().queue, bufferController.getTolerance());
            return isLoaded;
        };
        this.isFragmentLoadingOrPending = function (bufferController, request) {
            var fragmentModel = _this.findModel(bufferController);
            var isLoaded;
            if (!fragmentModel) {
                return false;
            }
            isLoaded = fragmentModel.isFragmentLoadingOrPending(request, bufferController.getBuffer().queue, bufferController.getTolerance());
            return isLoaded;
        };
        this.getExecutedRequests = function (bufferController) {
            var fragmentModel = _this.findModel(bufferController);
            if (!fragmentModel) {
                return null;
            }
            return fragmentModel.getExecutedRequests();
        };
        this.getPendingRequests = function (bufferController) {
            var fragmentModel = _this.findModel(bufferController);
            if (!fragmentModel) {
                return null;
            }
            return fragmentModel.getPendingRequests();
        };
        this.getLoadingRequests = function (bufferController) {
            var fragmentModel = _this.findModel(bufferController);
            if (!fragmentModel) {
                return null;
            }
            return fragmentModel.getLoadingRequests();
        };
        this.needToPrepareNewRequest = function (bufferController) {
            var fragmentModel = _this.findModel(bufferController);
            if (!fragmentModel) {
                return null;
            }
            return fragmentModel.needToPrepareNewRequest();
        };
        this.isInitializationRequest = function (request) {
            if (request &&
                request.type &&
                request.type.toLowerCase() === 'initialization segment')
                return true;
            return false;
        };
        // getLoadingTime = (bufferController: BufferController): Nullable<number> => {
        //   const fragmentModel: Nullable<FragmentModel> = this.findModel(
        //     bufferController
        //   );
        //   if (!fragmentModel) {
        //     return null;
        //   }
        //   return fragmentModel.getLoadingTime();
        // };
        this.getExecutedRequestForTime = function (model, time) {
            if (model) {
                return model.getExecutedRequestForTime(time);
            }
            return null;
        };
        this.removeExecutedRequest = function (model, request) {
            if (model) {
                model.removeExecutedRequest(request);
            }
        };
        this.removeExecutedRequestsBeforeTime = function (model, time) {
            if (model) {
                model.removeExecutedRequestsBeforeTime(time);
            }
        };
        // cancelPendingRequestsForModel = (model: Nullable<FragmentModel>): void => {
        //   if (model) {
        //     model.cancelPendingRequests();
        //   }
        // };
        this.clearAllRequestsForModel = function (model) {
            if (model) {
                model.clearAllRequests();
            }
        };
        this.abortRequestsForModel = function (model) {
            if (model) {
                model.abortRequests();
            }
        };
        this.isFragmentExists = function (bfController, request, _callback) {
            var callback = _callback || (function () { });
            var fragmentModel = _this.findModel(bfController);
            if (!fragmentModel) {
                callback(false);
                return;
            }
            fragmentModel.checkForExistence.call(_this, request, function (d) {
                if (d.status === 'ok') {
                    if (d.data != null) {
                        callback(true);
                    }
                    else {
                        callback(false);
                    }
                }
                else {
                    callback(false);
                }
            });
        };
        this.prepareFragmentForLoading = function (bufferController, startLoadingCallback, successLoadingCallback, errorLoadingCallback, streamEndCallback, firstChunkLoadingCallback, chunkLoadingCallback, errorChunkLoadingCallback) {
            var fragmentModel = _this.findModel(bufferController);
            if (!fragmentModel) {
                return null;
            }
            fragmentModel.setCallbacks(startLoadingCallback, successLoadingCallback, errorLoadingCallback, streamEndCallback, firstChunkLoadingCallback, chunkLoadingCallback, errorChunkLoadingCallback);
            return true;
        };
        this.reset = function () {
            for (var i = 0; i < _this.fragmentModels.length; i++) {
                _this.clearAllRequestsForModel(_this.fragmentModels[i]);
            }
            _this.fragmentModels = [];
        };
        this.fragmentModels = []; //NSV-a,
        this.params = params;
        this.eventBus = eventBus;
        this.metricsModel = metricsModel;
        this.xhrCustom = xhrCustom;
    }
    return FragmentController;
}());



/***/ }),

/***/ "./ts/dash/streaming/FragmentModel.ts":
/*!********************************************!*\
  !*** ./ts/dash/streaming/FragmentModel.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FragmentModel": function() { return /* binding */ FragmentModel; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */




/**
 * FragmentModel
 *
 * @module FragmentModel（FragmentModelモジュール）
 */
/**
 * FragmentModel
 * @constructor
 */
var abortWrapper = function (f, c) {
    return new Promise(function (resolve, reject) {
        c.listener = function (evt) {
            if (evt.data.lid == c.lid) {
                c.unlisten();
                reject(new Error('abort'));
            }
        };
        c.listen();
        f.then(resolve, reject);
    });
};
var getRequestUrl = function (relative, baseURL) {
    var url;
    if (relative === baseURL) {
        url = relative;
    }
    else if (relative.indexOf('http://') !== -1 ||
        relative.indexOf('https://') !== -1) {
        url = relative;
    }
    else {
        url = baseURL + relative;
    }
    return url;
};
var FragmentModel = /** @class */ (function () {
    function FragmentModel(params, eventBus, metrics, xhrCustom) {
        var _this = this;
        /* istanbul ignore next */
        this.doLoadX = function (request, remainingAttempts, _callback) {
            var callback = _callback;
            var req = new XMLHttpRequest();
            var httpRequestMetrics = null;
            var firstProgress = true;
            var waitingForNext = true;
            var needFailureReport = true;
            var lastTraceTime = null;
            var qrys = _this.commonQrys.concat();
            var hdrs = _this.commonHdrs.concat();
            var self = _this;
            _this.xhrs.push(req);
            request.requestStartTime = new Date().getTime();
            req.startTime = request.requestStartTime;
            if (request.range) {
                request.url += '?range=' + request.range;
                qrys.push({
                    name: 'range',
                    value: request.range,
                });
            }
            request.url = getRequestUrl.call(self, request.relativeURL, request.baseURL[request.baseURLIdx].url);
            _this.onPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: req,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            httpRequestMetrics = _this.metrics.addHttpRequest(request.streamType, null, request.type, request.url, request.baseURL[request.baseURLIdx].url, request.range, request.requestStartTime, null, null, null, null, request.duration, request.bandwidth);
            _this.metrics.appendHttpTrace(httpRequestMetrics, request.requestStartTime, request.requestStartTime - request.requestStartTime, [0]);
            lastTraceTime = request.requestStartTime;
            if (req.open)
                req.open('GET', request.url, true);
            req.responseType = 'arraybuffer';
            var path = request.url.split('/');
            if (request.range) {
                if (req.setRequestHeader)
                    req.setRequestHeader('Range', 'bytes=' + request.range);
            }
            if (hdrs.length > 0) {
                hdrs.forEach(function (hdr) {
                    if (req.setRequestHeader)
                        req.setRequestHeader(hdr.name, hdr.value);
                });
            }
            req.onprogress = function (event) {
                var currentTime = new Date().getTime();
                if (firstProgress) {
                    firstProgress = false;
                    if (!event.lengthComputable ||
                        (event.lengthComputable && event.total != event.loaded)) {
                        request.firstByteTime = currentTime;
                    }
                    if (event.lengthComputable) {
                        request.total = event.total;
                    }
                    else {
                        if (request.range) {
                            var r = request.range.split('-');
                            if (r.length > 1) {
                                request.total = parseInt(r[1]) - parseInt(r[0]) + 1;
                            }
                        }
                        else {
                            request.total = 0;
                        }
                    }
                }
                request.loaded = event.loaded;
                if (waitingForNext && _this.pendingRequests.length > 0) {
                    if (request.loaded > 0 && request.total > 0) {
                        var remainingTime = ((currentTime - request.requestStartTime) / request.loaded) *
                            (request.total - request.loaded);
                        if (remainingTime <
                            request.firstByteTime - request.requestStartTime) {
                            waitingForNext = false;
                            self.executeCurrentRequest();
                        }
                    }
                }
            };
            req.onload = function () {
                if (request.timeouttimerId) {
                    clearTimeout(request.timeouttimerId);
                    request.timeouttimerId = null;
                }
                if (waitingForNext && _this.pendingRequests.length > 0) {
                    waitingForNext = false;
                    self.executeCurrentRequest();
                }
                if (req.status < 200 || req.status > 299) {
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__["default"].log_d(req.status + ': ' + path[path.length - 1] + ' , ' + request.range);
                }
                else {
                    needFailureReport = false;
                    var currentTime = new Date().getTime();
                    var bytes = void 0;
                    var latency = void 0;
                    var download = void 0;
                    if (!request.firstByteTime) {
                        request.firstByteTime = request.requestStartTime;
                    }
                    request.requestEndTime = currentTime;
                    latency = request.firstByteTime - request.requestStartTime;
                    download = request.requestEndTime - request.firstByteTime;
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__["default"].log_d('X' +
                        req.status +
                        ': ' +
                        path[path.length - 1] +
                        ', i=' +
                        request.index +
                        ' ,t=' +
                        Math.floor(request.startTime) +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms, ');
                    _this.NXDebug.debug('[' +
                        request.streamType +
                        '] loaded : ' +
                        request.type +
                        ':' +
                        request.startTime +
                        ' (' +
                        req.status +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms)');
                    _this.NXDebug.info('[' +
                        request.streamType +
                        '] loaded : ' +
                        request.type +
                        ':' +
                        request.startTime +
                        ' (' +
                        req.status +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms)');
                    request.size = req.response.byteLength;
                    httpRequestMetrics.tresponse = request.firstByteTime;
                    httpRequestMetrics.tfinish = request.requestEndTime;
                    httpRequestMetrics.responsecode = req.status;
                    request.code = 200;
                    httpRequestMetrics.size = req.response.byteLength;
                    _this.onSuccess({
                        status: req.status,
                        req: request,
                        xhr: req,
                    });
                    bytes = req.response;
                    _this.metrics.appendHttpTrace(httpRequestMetrics, currentTime, currentTime - lastTraceTime, [bytes ? bytes.byteLength : 0]);
                    lastTraceTime = currentTime;
                    callback({
                        status: 'ok',
                        data: new Uint8Array(bytes),
                    });
                }
            };
            // eslint-disable-next-line no-unused-vars
            req.onabort = function (_evt) {
                request.requestEndTime = new Date().getTime();
                if (!isNaN(request.firstByteTime)) {
                    request.firstByteTime = request.requestEndTime;
                }
                if (request.canceled || isNaN(request.loaded)) {
                    request.code = 400;
                }
                else {
                    request.size = request.loaded;
                    request.code = 408;
                }
                callback({
                    status: 'error',
                    type: 'onabort',
                    msg: 'aborted: ' +
                        request.streamType +
                        ':' +
                        request.type +
                        ':' +
                        request.startTime,
                    data: req,
                });
            };
            req.onloadend = req.onerror = function () {
                if (request.timeouttimerId) {
                    clearTimeout(request.timeouttimerId);
                    request.timeouttimerId = null;
                }
                if (_this.xhrs.indexOf(req) === -1) {
                    return;
                }
                else {
                    _this.xhrs.splice(_this.xhrs.indexOf(req), 1);
                }
                if (!needFailureReport) {
                    return;
                }
                _this.onError({
                    status: req.status,
                    req: request,
                    xhr: req,
                });
                needFailureReport = false;
                var currentTime = new Date().getTime();
                var bytes = req.response;
                var latency;
                var download;
                if (!request.firstByteTime) {
                    request.firstByteTime = request.requestStartTime;
                }
                request.requestEndTime = currentTime;
                latency = request.firstByteTime - request.requestStartTime;
                download = request.requestEndTime - request.firstByteTime;
                _this.NXDebug.log('failed ' +
                    request.streamType +
                    ':' +
                    request.type +
                    ':' +
                    request.startTime +
                    ' (' +
                    req.status +
                    ', ' +
                    latency +
                    'ms, ' +
                    download +
                    'ms)');
                httpRequestMetrics.tresponse = request.firstByteTime;
                httpRequestMetrics.tfinish = request.requestEndTime;
                httpRequestMetrics.responsecode = req.status;
                _this.metrics.appendHttpTrace(httpRequestMetrics, currentTime, currentTime - lastTraceTime, [bytes ? bytes.byteLength : 0]);
                if (_this.STORE_MEASURED_DATA) {
                    _this.metrics.addReportHttpRequest(httpRequestMetrics, _this.context.getVideoModel().getCurrentTime());
                    _this.eventBus.dispatchEvent({
                        type: 'httpRequestReceived',
                        data: httpRequestMetrics,
                    });
                }
                lastTraceTime = currentTime;
                if (remainingAttempts > 0 && req.status < 399) {
                    _this.NXDebug.log('Failed loading segment: ' +
                        request.streamType +
                        ':' +
                        request.type +
                        ':' +
                        request.startTime +
                        ', retry in ' +
                        _this.RETRY_INTERVAL +
                        'ms' +
                        ' attempts: ' +
                        remainingAttempts);
                    remainingAttempts--;
                    _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__["default"].downloadError(_this.eventBus, 'content', request.url, req, request);
                    setTimeout(function () {
                        _this.doLoadX.call(self, request, remainingAttempts, callback);
                    }, _this.RETRY_INTERVAL);
                }
                else {
                    _this.NXDebug.log('Failed loading segment: ' +
                        request.streamType +
                        ':' +
                        request.type +
                        ':' +
                        request.startTime +
                        ' no retry attempts left');
                    request.code = 400;
                    callback({
                        status: 'error',
                        type: 'onloadend',
                        msg: 'Failed loading segment: ' +
                            request.streamType +
                            ':' +
                            request.type +
                            ':' +
                            request.startTime +
                            ' no retry attempts left',
                        data: req,
                    });
                }
            };
            _this.NXDebug.info('str: [' +
                request.streamType +
                '] ' +
                path[path.length - 1] +
                ', i=' +
                request.index +
                ' ,t=' +
                Math.floor(request.startTime));
            if (req.send)
                req.send();
            _this.startLoadingCallback.call(_this.context, request);
        };
        /* istanbul ignore next */
        this.doLoadF = function (request, remainingAttempts, _callback) {
            var callback = _callback || (function () { });
            var eventBus = _this.eventBus;
            var acon = {
                aborted: false,
                listener: null,
                lid: null,
                startTime: null,
                listen: function () {
                    eventBus.addEventListener('abortFetch', this.listener);
                },
                unlisten: function () {
                    eventBus.removeEventListener('abortFetch', this.listener);
                },
                abort: function () {
                    this.aborted = true;
                    eventBus.dispatchEvent({
                        type: 'abortFetch',
                        data: {
                            lid: this.lid,
                        },
                    });
                },
            };
            var req = {};
            var init = {
                method: 'GET',
                headers: {},
                credentials: 'same-origin',
            };
            var chunkQ;
            var httpRequestMetrics = null;
            var firstProgress = true;
            var waitingForNext = true;
            var lastTraceTime = null;
            var qrys = _this.commonQrys.concat();
            var hdrs = _this.commonHdrs.concat();
            var self = _this;
            // eslint-disable-next-line no-unused-vars
            var onerror = function (_err) {
                if (_this.xhrs.indexOf(acon) > -1) {
                    _this.xhrs.splice(_this.xhrs.indexOf(acon), 1);
                }
                if (chunkQ) {
                    _this.errorChunkLoadingCallback(chunkQ);
                    chunkQ = null;
                }
                if (acon.aborted || req.ok == true) {
                    request.requestEndTime = new Date().getTime();
                    if (!isNaN(request.firstByteTime)) {
                        request.firstByteTime = request.requestEndTime;
                    }
                    if (request.canceled || isNaN(request.loaded)) {
                        request.code = 400;
                        req.status = 400;
                    }
                    else {
                        request.size = request.loaded;
                        request.code = 408;
                        req.status = 408;
                    }
                    callback({
                        status: 'error',
                        type: 'onabort',
                        msg: 'aborted: ' +
                            request.streamType +
                            ':' +
                            request.type +
                            ':' +
                            request.startTime,
                        data: req,
                    });
                }
                else {
                    if (!req.status)
                        req.status = -1;
                    _this.onError({
                        status: req.status,
                        req: request,
                        xhr: req,
                    });
                    var currentTime = new Date().getTime();
                    //const bytes: Nullable<ArrayBuffer> = null;
                    var latency = void 0;
                    var download = void 0;
                    if (!request.firstByteTime) {
                        request.firstByteTime = request.requestStartTime;
                    }
                    request.requestEndTime = currentTime;
                    latency = request.firstByteTime - request.requestStartTime;
                    download = request.requestEndTime - request.firstByteTime;
                    _this.NXDebug.log('failed ' +
                        request.streamType +
                        ':' +
                        request.type +
                        ':' +
                        request.startTime +
                        ' (' +
                        req.status +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms)');
                    if (httpRequestMetrics) {
                        httpRequestMetrics.tresponse = request.firstByteTime;
                        httpRequestMetrics.tfinish = request.requestEndTime;
                        httpRequestMetrics.responsecode = req.status;
                    }
                    _this.metrics.appendHttpTrace(httpRequestMetrics, currentTime, currentTime - lastTraceTime, [0] //eslint Error ==> [bytes ? bytes!.byteLength : 0]
                    );
                    if (_this.STORE_MEASURED_DATA) {
                        _this.metrics.addReportHttpRequest(httpRequestMetrics, _this.context.getVideoModel().getCurrentTime());
                        eventBus.dispatchEvent({
                            type: 'httpRequestReceived',
                            data: httpRequestMetrics,
                        });
                    }
                    lastTraceTime = currentTime;
                    if (remainingAttempts > 0 && req.status < 399) {
                        _this.NXDebug.log('Failed loading segment: ' +
                            request.streamType +
                            ':' +
                            request.type +
                            ':' +
                            request.startTime +
                            ', retry in ' +
                            _this.RETRY_INTERVAL +
                            'ms' +
                            ' attempts: ' +
                            remainingAttempts);
                        remainingAttempts--;
                        _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__["default"].downloadError(eventBus, 'content', request.url, req, request);
                        setTimeout(function () {
                            _this.doLoadF.call(self, request, remainingAttempts, callback);
                        }, _this.RETRY_INTERVAL);
                    }
                    else {
                        _this.NXDebug.log('Failed loading segment: ' +
                            request.streamType +
                            ':' +
                            request.type +
                            ':' +
                            request.startTime +
                            ' no retry attempts left');
                        request.code = 400;
                        callback({
                            status: 'error',
                            type: 'onloadend',
                            msg: 'Failed loading segment: ' +
                                request.streamType +
                                ':' +
                                request.type +
                                ':' +
                                request.startTime +
                                ' no retry attempts left',
                            data: req,
                        });
                    }
                }
                acon = null;
            };
            request.requestStartTime = new Date().getTime();
            req.startTime = request.requestStartTime;
            acon.startTime = request.startTime;
            acon.lid = request.startTime + ',' + request.requestStartTime;
            _this.xhrs.push(acon);
            if (request.range) {
                request.url += '?range=' + request.range;
                qrys.push({
                    name: 'range',
                    value: request.range,
                });
            }
            request.url = getRequestUrl.call(self, request.relativeURL, request.baseURL[request.baseURLIdx].url);
            _this.onPrepare({
                req: request,
                qrys: qrys,
                hdrs: hdrs,
                xhr: req,
            });
            if (qrys.length > 0) {
                qrys.forEach(function (qry) {
                    request.url += request.url.indexOf('?') > 0 ? '&' : '?';
                    request.url += qry.name + '=' + qry.value;
                });
            }
            httpRequestMetrics = _this.metrics.addHttpRequest(request.streamType, null, request.type, request.url, request.baseURL[request.baseURLIdx].url, request.range, request.requestStartTime, null, null, null, null, request.duration, request.bandwidth);
            _this.metrics.appendHttpTrace(httpRequestMetrics, request.requestStartTime, request.requestStartTime - request.requestStartTime, [0]);
            lastTraceTime = request.requestStartTime;
            var path = request.url.split('/');
            if (request.range) {
                init.headers['Range'] = 'bytes=' + request.range;
            }
            if (hdrs.length > 0) {
                hdrs.forEach(function (hdr) {
                    init.headers[hdr.name] = hdr.value;
                });
            }
            var progress = function (result, total, reader) {
                var currentTime;
                acon.unlisten();
                if (acon.aborted) {
                    onerror(new Error('AbortError'));
                    return;
                }
                if (result.done) {
                    var latency = void 0;
                    var download = void 0;
                    currentTime = new Date().getTime();
                    if (_this.xhrs.indexOf(acon) > -1) {
                        _this.xhrs.splice(_this.xhrs.indexOf(acon), 1);
                    }
                    _this.chunkLoadingCallback(result.done, chunkQ, new Uint8Array());
                    if (waitingForNext && _this.pendingRequests.length > 0) {
                        waitingForNext = false;
                        self.executeCurrentRequest();
                    }
                    if (!request.firstByteTime) {
                        request.firstByteTime = request.requestStartTime;
                    }
                    request.requestEndTime = currentTime;
                    latency = request.firstByteTime - request.requestStartTime;
                    download = request.requestEndTime - request.firstByteTime;
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_3__["default"].log_d('F' +
                        req.status +
                        ': ' +
                        path[path.length - 1] +
                        ', i=' +
                        request.index +
                        ' ,t=' +
                        Math.floor(request.startTime) +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms, ');
                    _this.NXDebug.debug('[' +
                        request.streamType +
                        '] loaded : ' +
                        request.type +
                        ':' +
                        request.startTime +
                        ' (' +
                        req.status +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms)');
                    _this.NXDebug.info('[' +
                        request.streamType +
                        '] loaded : ' +
                        request.type +
                        ':' +
                        request.startTime +
                        ' (' +
                        req.status +
                        ', ' +
                        latency +
                        'ms, ' +
                        download +
                        'ms)');
                    request.size = request.loaded;
                    httpRequestMetrics.tresponse = request.firstByteTime;
                    httpRequestMetrics.tfinish = request.requestEndTime;
                    httpRequestMetrics.responsecode = req.status;
                    request.code = 200;
                    httpRequestMetrics.size = request.loaded;
                    _this.onSuccess({
                        status: req.status,
                        req: request,
                        xhr: req,
                    });
                    _this.metrics.appendHttpTrace(httpRequestMetrics, currentTime, currentTime - lastTraceTime, [request.loaded]);
                    lastTraceTime = currentTime;
                    //callback({status:"ok", data: bytes});
                    callback({
                        status: 'ok',
                        data: new Uint8Array(0),
                    });
                    return;
                }
                currentTime = new Date().getTime();
                if (firstProgress) {
                    firstProgress = false;
                    request.firstByteTime = currentTime;
                    request.total = total;
                    request.loaded = result.value.length;
                    chunkQ = _this.firstChunkLoadingCallback(request);
                }
                else {
                    request.loaded += result.value.length;
                }
                _this.chunkLoadingCallback(result.done, chunkQ, result.value);
                if (waitingForNext && _this.pendingRequests.length > 0) {
                    var remainingTime = Number.MAX_VALUE;
                    if (total != null && total > 0) {
                        if (request.loaded > 0) {
                            remainingTime =
                                ((currentTime - request.requestStartTime) / request.loaded) *
                                    (request.total - request.loaded);
                        }
                    }
                    else {
                        if (chunkQ) {
                            if (chunkQ.chunks.length > 0) {
                                var dur = chunkQ.dur;
                                var cdur = chunkQ.chunks[chunkQ.chunks.length - 1].start +
                                    chunkQ.chunks[chunkQ.chunks.length - 1].dur -
                                    chunkQ.time;
                                remainingTime = dur - cdur;
                            }
                        }
                    }
                    if (remainingTime < request.firstByteTime - request.requestStartTime) {
                        waitingForNext = false;
                        self.executeCurrentRequest();
                    }
                }
                return abortWrapper(reader.read(), acon)
                    .then(function (res) { return progress(res, total, reader); })
                    .catch(function (err) {
                    acon.unlisten();
                    onerror(err);
                    return;
                });
            };
            abortWrapper(fetch(request.url, init), acon)
                .then(function (res) {
                acon.unlisten();
                req.status = res.status;
                req.ok = res.ok;
                if (res.ok == true) {
                    var contentLength = res.headers.get('content-length');
                    var total_1 = contentLength
                        ? parseInt(contentLength, 10)
                        : null;
                    var reader_1 = res.body.getReader();
                    if (!total_1 && request.range) {
                        var r = request.range.split('-');
                        if (r.length > 1) {
                            total_1 = parseInt(r[1]) - parseInt(r[0]) + 1;
                        }
                    }
                    return abortWrapper(reader_1.read(), acon)
                        .then(function (result) { return progress(result, total_1, reader_1); })
                        .catch(function (err) {
                        onerror(err);
                        return;
                    });
                }
                else {
                    _this.NXDebug.debug('404 Not Found');
                    return Promise.reject(new Error('res.false'));
                }
            })
                .catch(function (err) {
                onerror(err);
                return;
            });
            _this.NXDebug.info('str: [' +
                request.streamType +
                '] ' +
                path[path.length - 1] +
                ', i=' +
                request.index +
                ' ,t=' +
                Math.floor(request.startTime) +
                ', rst:' +
                request.requestStartTime);
            //logHandler.log("str: ["+request.streamType+"] " + path[(path.length-1)]  + ", i=" + request.index + " ,t=" + Math.floor(request.startTime)+", rst:"+request.requestStartTime);
            _this.startLoadingCallback.call(_this.context, request);
        };
        this.fragmentLoad = function (req, _callback) {
            var callback = _callback;
            if (!req) {
                callback({
                    status: 'ok',
                    data: null,
                });
            }
            req.loading = true;
            if (_this.useFetch) {
                _this.doLoadF(req, _this.RETRY_ATTEMPTS, callback);
            }
            else {
                _this.doLoadX(req, _this.RETRY_ATTEMPTS, callback);
            }
        };
        this.abort = function () {
            var req;
            var ln = _this.xhrs.length;
            for (var i = 0; i < ln; i += 1) {
                req = _this.xhrs[i];
                //xhrs[i] = null;
                if (req.abort)
                    req.abort();
                //req = null;
            }
            _this.xhrs = [];
        };
        this.getRecent2ExecutedDownloadRequestIndex = function () {
            var rqsts = [];
            for (var i = _this.executedRequests.length - 1; i >= 0; i--) {
                if (_this.executedRequests[i].action === 'download') {
                    rqsts.push(i);
                    if (rqsts.length >= 2) {
                        break;
                    }
                }
            }
            return rqsts;
        };
        this.reviseRequestStatus = function (request) {
            var rqsts = _this.getRecent2ExecutedDownloadRequestIndex.call(_this);
            var revRequest = {};
            var prOlBytes = 0;
            var lrOlBytes = 0;
            if (rqsts.length > 0) {
                var pr = _this.executedRequests[rqsts.shift()];
                var prTime = pr.requestEndTime - pr.requestStartTime;
                var prOlTime = pr.requestEndTime > request.requestStartTime
                    ? pr.requestEndTime - request.requestStartTime
                    : 0;
                var prOlRate = prTime > prOlTime ? prOlTime / prTime : 1;
                prOlBytes = pr.size * prOlRate;
            }
            if (_this.loadingRequests.length > 0) {
                var lr = _this.loadingRequests[0];
                lrOlBytes = isNaN(lr.loaded) ? 0 : lr.loaded;
            }
            revRequest.stream = request.streamType;
            revRequest.trequest = request.requestStartTime;
            revRequest.tresponse = request.firstByteTime;
            revRequest.tfinish = request.requestEndTime;
            revRequest.mediaduration = request.duration;
            revRequest.size = Math.round(request.size + prOlBytes + lrOlBytes);
            revRequest.bandwidth = request.bandwidth;
            revRequest.url = request.url;
            revRequest.baseURL = request.baseURL[0].url;
            revRequest.responsecode = request.code;
            revRequest.index = request.index;
            _this.metrics.addRevisedHttpRequest(revRequest);
            if (_this.STORE_MEASURED_DATA) {
                var r = _this.metrics.addReportHttpRequest(revRequest, _this.context.getVideoModel().getCurrentTime());
                _this.eventBus.dispatchEvent({
                    type: 'httpRequestReceived',
                    data: r,
                });
            }
            if (revRequest.responsecode != 408 &&
                revRequest.tfinish - revRequest.trequest < revRequest.mediaduration * 1000) {
                _this.restrictMultiLoad = false;
            }
        };
        this.loadCurrentFragment = function (request) {
            var self = _this;
            var _onSuccess = function (request, response) {
                var idx = _this.loadingRequests.indexOf(request);
                if (idx > -1) {
                    _this.loadingRequests.splice(idx, 1);
                }
                _this.reviseRequestStatus.call(self, request);
                _this.executedRequests.push(request);
                if (_this.executedRequests.length > 20)
                    _this.executedRequests.shift();
                _this.successLoadingCallback.call(_this.context, request, response);
                request.loading = false;
            };
            var _onError = function (type, request) {
                var idx = _this.loadingRequests.indexOf(request);
                if (idx > -1) {
                    _this.loadingRequests.splice(idx, 1);
                }
                if (request.code != 400) {
                    _this.reviseRequestStatus.call(self, request);
                    _this.executedRequests.push(request);
                }
                _this.errorLoadingCallback.call(_this.context, type, request);
                request.loading = false;
            };
            _this.fragmentLoad.call(self, request, function (d) {
                if (d.status === 'ok') {
                    _onSuccess(request, d.data);
                }
                else {
                    _onError(d.type, request);
                }
            });
        };
        /*
          const sortRequestsByProperty = (requestsArray, sortProp) => {
            const compare = (req1, req2) => {
                if (req1[sortProp] < req2[sortProp]) return -1;
                if (req1[sortProp] > req2[sortProp]) return 1;
                return 0;
            };
      
            requestsArray.sort(compare);
          };
        */
        this.sortRequestsByProperty = function (requestsArray) {
            var compare = function (req1, req2) {
                if (req1.pStart < req2.pStart)
                    return -1;
                if (req1.pStart == req2.pStart) {
                    if (req1.index < req2.index)
                        return -1;
                    if (req1.index > req2.index)
                        return 1;
                    return 0;
                }
                if (req1.pStart > req2.pStart)
                    return 1;
                return 0;
            };
            requestsArray.sort(compare);
        };
        this.checkLoaded = function (r1, r2, tol) {
            var o1 = r1.MSETimeOffset;
            var o2 = r2.action ? r2.MSETimeOffset : r2.offset;
            var q1 = r1.quality;
            var q2 = r2.quality;
            var s1 = r1.startTime;
            var s2 = r2.action ? r2.startTime : r2.rstime;
            if (o1 != o2)
                return false;
            if (q1 == q2) {
                if (s1 == s2)
                    return true;
            }
            else {
                if (Math.abs(s1 - s2) <= tol)
                    return true;
            }
            return false;
        };
        this.removeExecutedRequest = function (request) {
            var idx = _this.executedRequests.indexOf(request);
            if (idx !== -1) {
                _this.executedRequests.splice(idx, 1);
            }
        };
        this.setContext = function (value) {
            _this.context = value;
        };
        this.getContext = function () {
            return _this.context;
        };
        /*
          addRequest = (value) => {
            if (value) {
                if (!agressive && this.isFragmentLoadedOrPending(value)) return;
      
                pendingRequests.push(value);
                sortRequestsByProperty.call(this, pendingRequests, "index");
            }
          };
        */
        this.addRequest = function (value) {
            if (value) {
                _this.pendingRequests.push(value);
                //sortRequestsByProperty.call(this, pendingRequests, "index");
                _this.sortRequestsByProperty.call(_this, _this.pendingRequests);
            }
        };
        this.setCallbacks = function (onLoadingStart, onLoadingSuccess, onLoadingError, onStreamEnd, onFirstChunkLoadingSuccess, onChunkLoadingSuccess, onChunkLoadingError) {
            _this.startLoadingCallback = onLoadingStart;
            _this.streamEndCallback = onStreamEnd;
            _this.errorLoadingCallback = onLoadingError;
            _this.successLoadingCallback = onLoadingSuccess;
            _this.firstChunkLoadingCallback = onFirstChunkLoadingSuccess;
            _this.chunkLoadingCallback = onChunkLoadingSuccess;
            _this.errorChunkLoadingCallback = onChunkLoadingError;
        };
        this.isFragmentLoadedOrPending = function (request, _q, _tol) {
            var q = _q || [];
            var tol = _tol || 0;
            if (_this.isFragmentQueued(request, q, tol) ||
                _this.isFragmentLoaded(request, tol) ||
                _this.isFragmentPending(request, tol) ||
                _this.isFragmentLoading(request, tol)) {
                return true;
            }
            else {
                return false;
            }
        };
        this.isFragmentLoadingOrPending = function (request, _q, _tol) {
            var q = _q || [];
            var tol = _tol || 0;
            if (_this.isFragmentQueued(request, q, tol) ||
                _this.isFragmentPending(request, tol) ||
                _this.isFragmentLoading(request, tol)) {
                return true;
            }
            else {
                return false;
            }
        };
        this.isFragmentLoaded = function (request, _tol) {
            var isLoaded = false;
            var tol = _tol || 0;
            var ln = _this.executedRequests.length;
            var req;
            if (!isLoaded) {
                for (var i = 0; i < ln; i++) {
                    req = _this.executedRequests[i];
                    if (req.code != 200)
                        continue;
                    if (_this.checkLoaded(request, req, tol) ||
                        (req.action === 'complete' && request.action === req.action)) {
                        isLoaded = true;
                        break;
                    }
                }
            }
            return isLoaded;
        };
        this.isFragmentPending = function (request, _tol) {
            var isLoaded = false;
            var tol = _tol || 0;
            var ln = _this.pendingRequests.length;
            var req;
            for (var i = 0; i < ln; i++) {
                req = _this.pendingRequests[i];
                if (_this.checkLoaded(request, req, tol)) {
                    isLoaded = true;
                }
            }
            return isLoaded;
        };
        this.isFragmentLoading = function (request, _tol) {
            var isLoaded = false;
            var tol = _tol || 0;
            var ln = _this.loadingRequests.length;
            var req;
            for (var i = 0; i < ln; i++) {
                req = _this.loadingRequests[i];
                if (_this.checkLoaded(request, req, tol)) {
                    isLoaded = true;
                }
            }
            return isLoaded;
        };
        this.isReady = function () {
            return _this.context.isReady();
        };
        this.getExecutedRequests = function () {
            return _this.executedRequests;
        };
        this.getPendingRequests = function () {
            return _this.pendingRequests;
        };
        this.getLoadingRequests = function () {
            return _this.loadingRequests;
        };
        // getLoadingRequestThreshold = (): number => {
        //   return this.LOADING_REQUEST_THRESHOLD;
        // };
        this.needToPrepareNewRequest = function () {
            return _this.loadingRequests.length < _this.LOADING_REQUEST_THRESHOLD
                ? true
                : false;
        };
        // getLoadingTime = (): number => {
        //   let loadingTime: number = 0;
        //   let req: RequestType;
        //   for (let i = this.executedRequests.length - 1; i >= 0; i -= 1) {
        //     req = this.executedRequests[i];
        //     if (!isNaN(req.requestEndTime) && !isNaN(req.firstByteTime)) {
        //       loadingTime = req.requestEndTime - req.firstByteTime;
        //       break;
        //     }
        //   }
        //   return loadingTime;
        // };
        this.getExecutedRequestForTime = function (time) {
            var lastIdx = _this.executedRequests.length - 1;
            var start = NaN;
            var end = NaN;
            var req = null;
            // loop through the executed requests and pick the one for which the playback interval matches the given time
            for (var i = lastIdx; i >= 0; i -= 1) {
                req = _this.executedRequests[i];
                start = req.startTime;
                end = start + req.duration;
                if (!isNaN(start) && !isNaN(end) && time > start && time < end) {
                    return req;
                }
            }
            return null;
        };
        // getExecutedRequestForQualityAndIndex = (
        //   quality: number,
        //   index: number
        // ): Nullable<RequestType> => {
        //   const lastIdx: number = this.executedRequests.length - 1;
        //   let req: Nullable<RequestType> = null;
        //   for (let i = lastIdx; i >= 0; i -= 1) {
        //     req = this.executedRequests[i];
        //     if (req.quality === quality && req.index === index) {
        //       return req;
        //     }
        //   }
        //   return null;
        // };
        this.removeAllExecutedRequests = function () {
            _this.executedRequests = [];
        };
        this.removeExecutedRequestsBeforeTime = function (time) {
            var lastIdx = _this.executedRequests.length - 1;
            var start = NaN;
            var req = null;
            // loop through the executed requests and remove the ones for which startTime is less than the given time
            for (var i = lastIdx; i >= 0; i -= 1) {
                req = _this.executedRequests[i];
                start = req.startTime;
                if (!isNaN(start) && start < time) {
                    _this.removeExecutedRequest.call(_this, req);
                }
            }
        };
        this.cancelPendingRequests = function () {
            if (_this.pendingRequests.length) {
                for (var i = _this.pendingRequests.length - 1; i >= 0; i--) {
                    if (!_this.pendingRequests[i].keep) {
                        _this.pendingRequests.splice(i, 1);
                    }
                }
            }
        };
        this.clearAllRequests = function () {
            _this.pendingRequests = [];
            _this.abort.call(_this);
            _this.loadingRequests = [];
            _this.executedRequests = [];
        };
        this.abortRequests = function (_cancel) {
            if (_cancel === void 0) { _cancel = false; }
            var cancel = _cancel;
            if (cancel) {
                for (var i = 0; i < _this.loadingRequests.length; i++) {
                    _this.loadingRequests[i].canceled = true;
                }
            }
            _this.abort.call(_this);
            _this.loadingRequests = [];
        };
        this.abortRequestForTime = function (time) {
            for (var i = 0; i < _this.xhrs.length; i++) {
                if (_this.xhrs[i].startTime == time) {
                    var req = _this.xhrs.splice(i, 1)[0];
                    if (req.abort)
                        req.abort();
                    //req.abort();
                    req = undefined;
                    break;
                }
            }
        };
        this.setRestrictMultiLoad = function (value) {
            _this.restrictMultiLoad = value;
        };
        this.executeCurrentRequest = function () {
            var self = _this;
            var currentRequest;
            if (_this.pendingRequests.length === 0)
                return;
            if (_this.loadingRequests.length >= _this.LOADING_REQUEST_THRESHOLD) {
                // too many requests have been loading, do nothing until some of them are loaded or aborted
                return;
            }
            if (_this.loadingRequests.length > 0 && _this.restrictMultiLoad) {
                return;
            }
            // take the next request to execute and remove it from the list of pending requests
            currentRequest = _this.pendingRequests.shift();
            switch (currentRequest.action) {
                case 'complete':
                    // Stream has completed, execute the correspoinding callback
                    _this.executedRequests.push(currentRequest);
                    _this.streamEndCallback.call(_this.context, currentRequest);
                    break;
                case 'download':
                    var level = _this.metrics.getCurrentBufferLevel();
                    if (level) {
                        currentRequest.bufferLevelAtStartDate = level.totalLevel;
                    }
                    _this.loadingRequests.push(currentRequest);
                    _this.loadCurrentFragment.call(self, currentRequest);
                    break;
                default:
                    _this.NXDebug.log('Unknown request action.');
                    if (currentRequest.loading) {
                        currentRequest.loading = false;
                    }
                    else {
                        _this.errorLoadingCallback.call(_this.context, '', currentRequest);
                    }
            }
        };
        this.checkForExistence = function (request, _callback) {
            var callback = _callback;
            if (!request) {
                callback({
                    status: 'ok',
                    data: null,
                });
                return;
            }
            request.url = getRequestUrl.call(_this, request.relativeURL, request.baseURL[request.baseURLIdx].url);
            var req = new XMLHttpRequest();
            var isSuccessful = false;
            req.open('HEAD', request.url, true);
            req.onload = function () {
                if (req.status < 200 || req.status > 299) {
                    // eslint-disable-line no-empty
                }
                else {
                    isSuccessful = true;
                    callback({
                        status: 'ok',
                        data: request,
                    });
                }
            };
            req.onloadend = req.onerror = function () {
                if (!isSuccessful) {
                    callback({
                        status: 'error',
                        msg: 'checkForExistence error',
                    });
                }
            };
            req.send();
        };
        this.context = undefined;
        this.executedRequests = [];
        this.pendingRequests = [];
        this.loadingRequests = [];
        this.startLoadingCallback = function () { };
        this.successLoadingCallback = function () { };
        this.chunkLoadingCallback = function () { };
        this.errorChunkLoadingCallback = function () { };
        this.errorLoadingCallback = function () { };
        this.streamEndCallback = function () { };
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.LOADING_REQUEST_THRESHOLD = params.LOADING_REQUEST_THRESHOLD || 2;
        this.STORE_MEASURED_DATA = params.STORE_MEASURED_DATA || false;
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.RETRY_ATTEMPTS = 0;
        this.RETRY_INTERVAL = 500;
        this.xhrs = [];
        this.restrictMultiLoad = false;
        this.commonQrys = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(xhrCustom, 'query')
            ? xhrCustom['query']
            : [];
        this.commonHdrs = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(xhrCustom, 'header')
            ? xhrCustom['header']
            : [];
        this.onPrepare = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(xhrCustom, 'onPrepare')
            ? xhrCustom['onPrepare']
            : function () { };
        this.onSuccess = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(xhrCustom, 'onSuccess')
            ? xhrCustom['onSuccess']
            : function () { };
        this.onError = (0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(xhrCustom, 'onError')
            ? xhrCustom['onError']
            : function () { };
        this.params = params;
        this.eventBus = eventBus;
        this.metrics = metrics;
        this.xhrCustom = xhrCustom;
    }
    FragmentModel.prototype.isFragmentQueued = function (request, _q, _tol) {
        var isLoaded = false;
        var q = _q || [];
        var tol = _tol || 0;
        var ln = q.length;
        for (var i = 0; i < ln; i++) {
            if (this.checkLoaded(request, q[i], tol)) {
                isLoaded = true;
                break;
            }
        }
        return isLoaded;
    };
    return FragmentModel;
}());



/***/ }),

/***/ "./ts/dash/streaming/MetricsModel.ts":
/*!*******************************************!*\
  !*** ./ts/dash/streaming/MetricsModel.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Metrics": function() { return /* binding */ Metrics; }
/* harmony export */ });
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * MetricsModel
 *
 * @module MetricsModel（MetricsModelモジュール）
 */
/**
 * Metrics
 * @constructor
 */
var Metrics = /** @class */ (function () {
    function Metrics() {
        var _this = this;
        this.TcpList = [];
        this.HttpList = [];
        this.revHttpList = [];
        this.RepSwitchList = [];
        this.BufferLevel = [];
        this.PlayList = [];
        this.DroppedFrames = [];
        this.ReportHttpList = [];
        this.ReportBufferLevel = [];
        this.ReportBufferingEvent = [];
        this.storeMeasuredData = false;
        this.setStoreMeasuredData = function (value) {
            _this.storeMeasuredData = value;
        };
        this.getCurrentBufferLevel = function () {
            var bufferLevelLength = _this.BufferLevel.length;
            if (bufferLevelLength <= 0) {
                return null;
            }
            return _this.BufferLevel[bufferLevelLength - 1];
        };
        this.getCurrentHttpRequest = function () {
            var httpListLength = _this.HttpList.length;
            var httpListLastIndex;
            if (httpListLength <= 0) {
                return null;
            }
            httpListLastIndex = httpListLength - 1;
            while (httpListLastIndex >= 0) {
                if (_this.HttpList[httpListLastIndex].responsecode) {
                    return _this.HttpList[httpListLastIndex];
                }
                httpListLastIndex -= 1;
            }
            return null;
        };
        this.getCurrentRevisedHttpRequest = function () {
            var revHttpListLength = _this.revHttpList.length;
            if (revHttpListLength <= 0) {
                return null;
            }
            return _this.revHttpList[revHttpListLength - 1];
        };
        // getHttpRequests = (): Array<HttpRequestMetrics> => {
        //   return this.HttpList;
        // };
        // getCurrentDroppedFrames = (): Nullable<DroppedFramesMetrics> => {
        //   const droppedFramesLength = this.DroppedFrames.length;
        //   if (droppedFramesLength <= 0) {
        //     return null;
        //   }
        //   return this.DroppedFrames[droppedFramesLength - 1];
        // };
        this.shiftMetrics = function (metricsList) {
            var defaultMetrics = {};
            if (metricsList && metricsList.length > 9) {
                return metricsList.shift() || defaultMetrics;
            }
            return defaultMetrics;
        };
        // addTcpConnection = (
        //   _streamType: string, // unused argument
        //   tcpid: any,
        //   dest: any,
        //   topen: any,
        //   tclose: any,
        //   tconnect: any
        // ): TcpConnectionMetrics => {
        //   const vo = this.shiftMetrics<TcpConnectionMetrics>(this.TcpList);
        //   vo.tcpid = tcpid;
        //   vo.dest = dest;
        //   vo.topen = topen;
        //   vo.tclose = tclose;
        //   vo.tconnect = tconnect;
        //   this.TcpList.push(vo);
        //   return vo;
        // };
        this.addHttpRequest = function (streamType, tcpid, type, url, baseURL, range, trequest, tresponse, tfinish, responsecode, interval, mediaduration, bandwidth) {
            var vo = _this.shiftMetrics(_this.HttpList);
            vo.stream = streamType;
            vo.tcpid = tcpid;
            vo.type = type;
            vo.url = url;
            vo.baseURL = baseURL;
            vo.range = range;
            vo.trequest = trequest;
            vo.tresponse = tresponse;
            vo.tfinish = tfinish;
            vo.responsecode = responsecode;
            vo.interval = interval;
            vo.mediaduration = mediaduration;
            vo.bandwidth = bandwidth;
            vo.trace = [];
            vo.size = 0;
            _this.HttpList.push(vo);
            return vo;
        };
        this.addReportHttpRequest = function (httpRequest, ctime) {
            var rvo = {};
            rvo.type = httpRequest.stream;
            rvo.url = httpRequest.url;
            rvo.baseURL = httpRequest.baseURL;
            rvo.treq = httpRequest.trequest;
            rvo.tres = httpRequest.tresponse;
            rvo.tfin = httpRequest.tfinish;
            rvo.code = httpRequest.responsecode;
            rvo.dur = httpRequest.mediaduration;
            rvo.bw = httpRequest.bandwidth;
            rvo.size = httpRequest.size;
            rvo.index = httpRequest.index;
            rvo.c = ctime.toFixed(3);
            _this.ReportHttpList.push(rvo);
            return rvo;
        };
        this.addRevisedHttpRequest = function (httpRequest) {
            var rvo = _this.shiftMetrics(_this.revHttpList);
            rvo.stream = httpRequest.stream;
            rvo.trequest = httpRequest.trequest;
            rvo.tresponse = httpRequest.tresponse;
            rvo.tfinish = httpRequest.tfinish;
            rvo.mediaduration = httpRequest.mediaduration;
            rvo.bandwidth = httpRequest.bandwidth;
            rvo.size = httpRequest.size;
            rvo.code = httpRequest.responsecode;
            rvo.index = httpRequest.index;
            _this.revHttpList.push(rvo);
            return rvo;
        };
        this.appendHttpTrace = function (httpRequest, s, d, b) {
            var vo = _this.shiftMetrics(httpRequest.trace);
            vo.s = s;
            vo.d = d;
            vo.b = b;
            httpRequest.trace.push(vo);
            return vo;
        };
        this.addRepresentationSwitch = function (_streamType, t, mt, to, lto) {
            var vo = _this.shiftMetrics(_this.RepSwitchList);
            vo.t = t;
            vo.mt = mt;
            vo.to = to;
            vo.lto = lto;
            _this.RepSwitchList.push(vo);
            return vo;
        };
        this.addBufferLevel = function (_streamType, t, level, qlv, ctime) {
            var vo = _this.shiftMetrics(_this.BufferLevel);
            vo.t = t;
            vo.level = level;
            vo.totalLevel = level + qlv;
            _this.BufferLevel.push(vo);
            if (_this.storeMeasuredData) {
                var rvo = {};
                rvo.t = t;
                rvo.l = new Number(level).toFixed(3);
                rvo.ql = new Number(qlv).toFixed(3);
                rvo.c = ctime.toFixed(3);
                _this.ReportBufferLevel.push(rvo);
            }
            return vo;
        };
        this.addBufferingEvent = function (t, onOff, ctime) {
            var vo = {};
            vo.t = t;
            vo.e = onOff;
            vo.c = ctime.toFixed(3);
            _this.ReportBufferingEvent.push(vo);
            return vo;
        };
        // addDroppedFrames = (_streamType: string, quality: any) => {
        //   const list = this.DroppedFrames;
        //   const vo = this.shiftMetrics<DroppedFramesMetrics>(list);
        //   vo.time = quality.creationTime;
        //   vo.droppedFrames = quality.droppedVideoFrames;
        //   if (list.length > 0 && list[list.length - 1] == vo) {
        //     return list[list.length - 1];
        //   }
        //   list.push(vo);
        //   return vo;
        // };
        this.addPlayList = function (streamType, start, mstart, starttype) {
            var vo = _this.shiftMetrics(_this.PlayList);
            vo.stream = streamType;
            vo.start = start;
            vo.mstart = mstart;
            vo.starttype = starttype;
            vo.trace = [];
            _this.PlayList.push(vo);
            return vo;
        };
        this.appendPlayListTrace = function (playList, representationid, subreplevel, start, mstart, duration, playbackspeed, stopreason) {
            var vo = _this.shiftMetrics(playList.trace);
            vo.representationid = representationid;
            vo.subreplevel = subreplevel;
            vo.start = start;
            vo.mstart = mstart;
            vo.duration = duration;
            vo.playbackspeed = playbackspeed;
            vo.stopreason = stopreason;
            playList.trace.push(vo);
            return vo;
        };
    }
    return Metrics;
}());

/**
 * MetricsModel
 * @constructor
 */
var MetricsModel = /** @class */ (function () {
    function MetricsModel() {
        var _this = this;
        this.streamMetrics = {};
        // clearCurrentMetricsForType = (type: string): void => {
        //   delete this.streamMetrics[type];
        // };
        // clearAllCurrentMetrics = (): void => {
        //   this.streamMetrics = {};
        // };
        this.getReadOnlyMetricsFor = function (type) {
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(_this.streamMetrics, type)) {
                return _this.streamMetrics[type];
            }
            return null;
        };
        this.getMetricsFor = function (type) {
            var metrics;
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_0__.hasProperty)(_this.streamMetrics, type)) {
                metrics = _this.streamMetrics[type];
            }
            else {
                metrics = new Metrics();
                _this.streamMetrics[type] = metrics;
            }
            return metrics;
        };
    }
    return MetricsModel;
}());
/* harmony default export */ __webpack_exports__["default"] = (MetricsModel);


/***/ }),

/***/ "./ts/dash/streaming/SourceBufferExtensions.ts":
/*!*****************************************************!*\
  !*** ./ts/dash/streaming/SourceBufferExtensions.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SourceBufferExtensions": function() { return /* binding */ SourceBufferExtensions; }
/* harmony export */ });
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * SourceBufferExtensions
 *
 * @module SourceBufferExtensions（SourceBufferExtensionsモジュール）
 */
var logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"];
var NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_1__["default"]();
/**
 * SourceBufferExtensions
 * @constructor
 */
var SourceBufferExtensions = /** @class */ (function () {
    function SourceBufferExtensions(params, eventBus) {
        var _this = this;
        this.findBuffer = function (b) {
            for (var i = 0; i < _this.buffers.length; i++) {
                if (_this.buffers[i] === b) {
                    return _this.buffers[i];
                }
            }
            return null;
        };
        //NSV-a  const tmp64BitNumber = (high, low) => high * 4294967296 + low;
        //NSV-a
        //NSV-a  const tmp64to32Bit = (num) => {
        //NSV-a    let high;
        //NSV-a    let low;
        //NSV-a    high = num / 4294967296;
        //NSV-a    low = num & 0xffffffff;
        //NSV-a    return {
        //NSV-a      high,
        //NSV-a      low,
        //NSV-a    };
        //NSV-a  };
        this._appendBuffer = function (buffer, data, dur, dataStart, dataEnd) {
            if ('appendBuffer' in buffer) {
                buffer.appendBuffer(data);
            }
            else if ('append' in buffer) {
                // @ts-ignore
                buffer.append(data);
            }
            buffer.lastAppendtime = new Date().getTime();
            if (_this.videoModel && !_this.videoModel.getNeedsMoreData()) {
                buffer.preDur = dur * 1000;
            }
            buffer.updatingRange = {
                start: dataStart,
                end: dataEnd,
            };
            data = void 0;
        };
        this.appendX = function (buffer, bytes, init, reqstarttime, starttime, dur, pStart, offset, _minSize, quality, asetIdx, divNum, index) {
            try {
                if (init) {
                    if (!(pStart in buffer.initQ)) {
                        buffer.initQ[pStart] = [];
                    }
                    if (!(asetIdx in buffer.initQ[pStart])) {
                        buffer.initQ[pStart][asetIdx] = [];
                    }
                    buffer.initQ[pStart][asetIdx][quality] = init;
                }
                for (var _i = 0, _a = buffer.queue; _i < _a.length; _i++) {
                    var q = _a[_i];
                    if (pStart == q.pStart &&
                        starttime == q.time &&
                        dur == q.dur &&
                        quality == q.quality &&
                        asetIdx == q.asetIdx) {
                        return buffer.queue.length;
                    }
                }
                buffer.queue.push({
                    type: 'data',
                    data: bytes,
                    rstime: reqstarttime,
                    time: starttime,
                    dur: dur,
                    quality: quality,
                    pStart: pStart,
                    offset: offset,
                    asetIdx: asetIdx,
                    divNum: divNum,
                    ridx: index,
                });
                // sort
                // const compare3 = (d1, d2) => {
                //   if (d1.pStart < d2.pStart) return -1;
                //   if (d1.pStart == d2.pStart) {
                //     if (d1.time < d2.time) return -1;
                //     if (d1.time > d2.time) return 1;
                //   }
                //   if (d1.pStart > d2.pStart) return 1;
                //   return 0;
                // };
                /* istanbul ignore next */
                var compare3 = function (d1, d2) {
                    if (d1.pStart < d2.pStart)
                        return -1;
                    if (d1.pStart == d2.pStart) {
                        if (d1.rstime < d2.rstime)
                            return -1;
                        if (d1.rstime > d2.rstime)
                            return 1;
                        if (d1.rstime == d2.rstime) {
                            if (d1.divNum < d2.divNum)
                                return -1;
                            if (d1.divNum > d2.divNum)
                                return 1;
                        }
                    }
                    if (d1.pStart > d2.pStart)
                        return 1;
                    return 0;
                };
                buffer.queue.sort(compare3);
                if (buffer.updating === undefined) {
                    // eslint-disable-line no-empty
                }
                else {
                    if (buffer.updating === false) {
                        // eslint-disable-line no-empty
                    }
                    else {
                        // waiting updateend event
                    }
                }
            }
            catch (err) {
                logHandler.log(err);
                NXDebug.info(err);
            }
            return buffer.queue.length;
        };
        this.appendF = function (buffer, bytes, init, reqstarttime, starttime, dur, pStart, offset, _minSize, quality, asetIdx, divNum, index) {
            var q;
            try {
                if (init) {
                    if (!(pStart in buffer.initQ)) {
                        buffer.initQ[pStart] = [];
                    }
                    if (!(asetIdx in buffer.initQ[pStart])) {
                        buffer.initQ[pStart][asetIdx] = [];
                    }
                    buffer.initQ[pStart][asetIdx][quality] = init;
                }
                for (var _i = 0, _a = buffer.queue; _i < _a.length; _i++) {
                    var qq = _a[_i];
                    if (pStart == qq.pStart &&
                        starttime == qq.time &&
                        dur == qq.dur &&
                        quality == qq.quality &&
                        asetIdx == qq.asetIdx) {
                        return q;
                    }
                }
                q = {
                    type: 'data',
                    data: bytes,
                    rstime: reqstarttime,
                    time: starttime,
                    dur: dur,
                    quality: quality,
                    pStart: pStart,
                    offset: offset,
                    asetIdx: asetIdx,
                    divNum: divNum,
                    ridx: index,
                    chunks: [],
                    progress: [],
                    chunkEnd: 0,
                    chunkStartTime: -1,
                    chunkDur: 0,
                    done: false,
                    appending: false,
                    params: init.params,
                };
                buffer.queue.push(q);
                // sort
                // const compare3 = (d1, d2) => {
                //   if (d1.pStart < d2.pStart) return -1;
                //   if (d1.pStart == d2.pStart) {
                //     if (d1.time < d2.time) return -1;
                //     if (d1.time > d2.time) return 1;
                //   }
                //   if (d1.pStart > d2.pStart) return 1;
                //   return 0;
                // };
                /* istanbul ignore next */
                var compare3 = function (d1, d2) {
                    if (d1.pStart < d2.pStart)
                        return -1;
                    if (d1.pStart == d2.pStart) {
                        if (d1.rstime < d2.rstime)
                            return -1;
                        if (d1.rstime > d2.rstime)
                            return 1;
                    }
                    if (d1.pStart > d2.pStart)
                        return 1;
                    return 0;
                };
                buffer.queue.sort(compare3);
                return q;
            }
            catch (err) {
                logHandler.log(err);
                NXDebug.info(err);
                throw err;
            }
        };
        this.appendFromQX = function (buffer, waitingForBuffer, bufferStartThreshold) {
            var d = null;
            var q = null;
            var data = null;
            var queue;
            var startTime = 0;
            var dataStart = 0;
            var dataEnd = 0;
            var curTime;
            var range;
            var end;
            var now = new Date().getTime();
            var bufferThreshold = bufferStartThreshold || 5;
            var bf;
            try {
                if (buffer.appendStart == false)
                    return;
                if (buffer.queue.length === 0)
                    return;
                if (buffer.waiting)
                    return;
                queue = buffer.queue;
                /* istanbul ignore if */
                if ((buffer.updating !== undefined &&
                    buffer.updating == false &&
                    now - buffer.lastAppendtime > buffer.preDur / 3) ||
                    (buffer.updating === undefined &&
                        now - buffer.lastAppendtime > buffer.preDur / 3)) {
                    if (waitingForBuffer === false) {
                        buffer.startTimeAfterSeek = Number.MAX_VALUE;
                        curTime = _this.playbackStarted
                            ? _this.videoModel.getCurrentTime()
                            : _this.videoModel.getStartTime();
                        range = _this.getBufferRange(buffer, curTime);
                        end = range ? range.end : curTime;
                        while (queue.length > 0) {
                            d = queue[0];
                            dataStart = d.time;
                            dataEnd = d.time + d.dur;
                            if (dataEnd < curTime - d.dur) {
                                NXDebug.log('[' +
                                    buffer.type +
                                    ']discard curTime:' +
                                    curTime +
                                    ', q:end' +
                                    dataEnd);
                                logHandler.log('[' +
                                    buffer.type +
                                    ']discard curTime:' +
                                    curTime +
                                    ', q:end' +
                                    dataEnd);
                                queue.shift();
                            }
                            else if (end + 0.1 < dataStart) {
                                if (dataEnd - curTime > 20) {
                                    return;
                                }
                                else if (d.rstime <= end + 0.1 &&
                                    d.rstime < dataStart &&
                                    d.rstime != d.pStart) {
                                    logHandler.log('[' +
                                        buffer.type +
                                        '] Gap!!' +
                                        'end:' +
                                        end +
                                        ', rstime:' +
                                        d.rstime +
                                        ', dataStart:' +
                                        dataStart);
                                    NXDebug.info('[' +
                                        buffer.type +
                                        '] Gap!!' +
                                        'end:' +
                                        end +
                                        ', rstime:' +
                                        d.rstime +
                                        ', dataStart:' +
                                        dataStart);
                                    _this.eventBus.dispatchEvent({
                                        type: 'checkBufferGap',
                                        data: {
                                            type: buffer.type,
                                            time: d.rstime - d.dur / 2,
                                        },
                                    });
                                    return;
                                }
                                else {
                                    if (end < buffer.updatingRange.end - 0.1 &&
                                        buffer.updatingRange.start - 0.1 < end &&
                                        now - buffer.lastAppendtime > (buffer.preDur * 2) / 3) {
                                        logHandler.log('updating?? end:' +
                                            end +
                                            ', exp:' +
                                            buffer.updatingRange.end +
                                            ', q:' +
                                            dataStart);
                                        NXDebug.log('[' +
                                            buffer.type +
                                            '] updating?? end:' +
                                            end +
                                            ', exp start:' +
                                            buffer.updatingRange.start +
                                            ',end:' +
                                            buffer.updatingRange.end +
                                            ', q:' +
                                            dataStart +
                                            ',st:' +
                                            buffer.startTimeAfterSeek);
                                        if (buffer.laData) {
                                            queue.unshift(buffer.laData);
                                        }
                                        else {
                                            // eslint-disable-line no-empty
                                        }
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                            else {
                                break;
                            }
                        }
                        if (queue.length == 0)
                            return;
                        d = queue.shift();
                        if (buffer.pStart !== d.pStart) {
                            NXDebug.debug('***** period change **** from:' +
                                buffer.pStart +
                                ', to:' +
                                d.pStart);
                            NXDebug.debug('***** startTime :::' + d.time + ' ******');
                            buffer.pStart = d.pStart;
                            buffer.quality = -1;
                        }
                        if (buffer.asetIdx != d.asetIdx) {
                            NXDebug.debug('***** AdaptationSet change **** from:' +
                                buffer.asetIdx +
                                ', to:' +
                                d.asetIdx);
                            NXDebug.debug('***** startTime :::' + d.time + ' ******');
                            buffer.asetIdx = d.asetIdx;
                            buffer.quality = -1;
                        }
                        if (buffer.quality !== d.quality) {
                            data = null;
                            if (buffer.type === 'video') {
                                logHandler.log_V2Q('bf[' + d.quality + '] init,ps=' + d.pStart);
                            }
                            else {
                                logHandler.log_A2Q('bf[' + d.quality + '] init,ps=' + d.pStart);
                            }
                            if (d.offset !== buffer.timestampOffset) {
                                buffer.timestampOffset = d.offset;
                            }
                            data = new Uint8Array(d.data.length +
                                buffer.initQ[d.pStart][d.asetIdx][d.quality].data.length);
                            data.set(buffer.initQ[d.pStart][d.asetIdx][d.quality].data, 0);
                            if (buffer.type === 'video') {
                                logHandler.log_V2Q('bf[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0);
                            }
                            else {
                                logHandler.log_A2Q('bf[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0);
                            }
                            data.set(d.data, buffer.initQ[d.pStart][d.asetIdx][d.quality].data.length);
                            _this._appendBuffer(buffer, data, d.dur, dataStart, dataEnd);
                            buffer.quality = d.quality;
                        }
                        else {
                            if (buffer.type === 'video') {
                                logHandler.log_V2Q('bf[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0);
                            }
                            else {
                                logHandler.log_A2Q('bf[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0);
                            }
                            if (d.offset !== buffer.timestampOffset) {
                                buffer.timestampOffset = d.offset;
                            }
                            _this._appendBuffer(buffer, d.data, d.dur, dataStart, dataEnd);
                        }
                        NXDebug.debug('[' +
                            buffer.type +
                            '] appended t=' +
                            d.time +
                            ', q:' +
                            queue.length);
                        buffer.laData = d;
                        d = void 0;
                    }
                    else {
                        if (!buffer.playbackStarted) {
                            if (!buffer.ready) {
                                for (var i = 0; i < queue.length; i++) {
                                    q = queue[i];
                                    if (q.rstime == buffer.startTimeAfterSeek) {
                                        dataStart = q.time;
                                        startTime = q.rstime;
                                        buffer.tmpData = {
                                            diff: dataStart - startTime,
                                            start: dataStart,
                                            offset: q.offset,
                                        };
                                        buffer.ready = true;
                                        break;
                                    }
                                    else if (q.rstime > buffer.startTimeAfterSeek) {
                                        break;
                                    }
                                }
                                if (!buffer.ready)
                                    return;
                            }
                            var ready = true;
                            for (var i = 0; i < _this.buffers.length; i++) {
                                if (!_this.buffers[i].ready) {
                                    ready = false;
                                }
                            }
                            if (ready) {
                                var minDiff = Number.MAX_VALUE;
                                var modOffset = false;
                                for (var i = 0; i < _this.buffers.length; i++) {
                                    bf = _this.buffers[i];
                                    if (bf.tmpData && bf.tmpData.diff < minDiff) {
                                        minDiff = bf.tmpData.diff;
                                    }
                                }
                                if (minDiff > 1.0) {
                                    modOffset = true;
                                }
                                else if (minDiff < 0) {
                                    for (var i = 0; i < _this.buffers.length; i++) {
                                        if (_this.buffers[i].tmpData &&
                                            _this.buffers[i].tmpData.start +
                                                _this.buffers[i].tmpData.offset <
                                                0) {
                                            logHandler.log('[' +
                                                _this.buffers[i].type +
                                                ', s:' +
                                                _this.buffers[i].tmpData.start +
                                                ', o:' +
                                                _this.buffers[i].tmpData.offset);
                                            modOffset = true;
                                            break;
                                        }
                                    }
                                }
                                if (modOffset == true) {
                                    for (var i = 0; i < _this.buffers.length; i++) {
                                        for (var j = 0; j < _this.buffers[i].queue.length; j++) {
                                            _this.buffers[i].queue[j].offset -= minDiff;
                                            _this.buffers[i].queue[j].time -= minDiff;
                                        }
                                    }
                                }
                                for (var i = 0; i < _this.buffers.length; i++) {
                                    bf = _this.buffers[i];
                                    bf.waiting = false;
                                    bf.ready = false;
                                    bf.playbackStarted = true;
                                    if (modOffset) {
                                        _this.eventBus.dispatchEvent({
                                            type: 'needToModifyOffset',
                                            data: {
                                                type: bf.type,
                                                minDiff: minDiff,
                                            },
                                        });
                                    }
                                }
                            }
                            else {
                                buffer.waiting = true;
                                return;
                            }
                        }
                        var dataArray = [];
                        var dataLength = 0;
                        var dataOffset = 0;
                        var dataDur = 0;
                        var ast = '';
                        var qTime = void 0;
                        var qDur = void 0;
                        var rstime = void 0;
                        var startDiff = 0;
                        curTime = _this.playbackStarted
                            ? _this.videoModel.getCurrentTime()
                            : _this.videoModel.getStartTime();
                        while (queue.length > 0) {
                            d = queue[0];
                            dataStart = d.time;
                            dataEnd = d.time + d.dur;
                            qTime = d.time;
                            qDur = d.dur;
                            rstime = d.rstime;
                            startDiff = 0;
                            if (dataStart + qDur + qDur < curTime &&
                                rstime < buffer.startTimeAfterSeek) {
                                logHandler.log('[' +
                                    buffer.type +
                                    '] packet received before seek -> discard c:' +
                                    curTime +
                                    ', q:' +
                                    qTime +
                                    ', rstime:' +
                                    rstime);
                                NXDebug.info('[' +
                                    buffer.type +
                                    '] packet received before seek -> discard c:' +
                                    curTime +
                                    ', q:' +
                                    qTime +
                                    ', rstime:' +
                                    rstime);
                                queue.shift();
                                if (queue.length > 0) {
                                    continue;
                                }
                                else {
                                    return;
                                }
                            }
                            if (rstime > buffer.startTimeAfterSeek) {
                                return;
                            }
                            if (rstime != buffer.startTimeAfterSeek &&
                                curTime + 0.1 < dataStart) {
                                range = _this.getBufferRange(buffer, curTime);
                                if (range != null && dataStart <= range.end + 0.1) {
                                    bufferThreshold -= dataStart - curTime;
                                    break;
                                }
                                else {
                                    end = range != null ? range.end : curTime;
                                    logHandler.log('[' +
                                        buffer.type +
                                        '] Gap!!! c:' +
                                        curTime +
                                        ', l:' +
                                        end +
                                        'q:' +
                                        qTime +
                                        ', qc:' +
                                        qTime +
                                        ', s' +
                                        _this.videoModel.getStartTime() +
                                        ',st:' +
                                        buffer.startTimeAfterSeek);
                                    NXDebug.info('[' +
                                        buffer.type +
                                        '] Gap!!! c:' +
                                        curTime +
                                        ', l:' +
                                        end +
                                        'q:' +
                                        qTime +
                                        ', qc:' +
                                        qTime +
                                        ', s' +
                                        _this.videoModel.getStartTime() +
                                        ',st:' +
                                        buffer.startTimeAfterSeek);
                                    var checkTime = 0;
                                    if (rstime <= end + 0.1 && rstime < dataStart) {
                                        checkTime = rstime - qDur / 2;
                                    }
                                    else {
                                        checkTime = end;
                                    }
                                    _this.eventBus.dispatchEvent({
                                        type: 'checkBufferGap',
                                        data: {
                                            type: buffer.type,
                                            time: checkTime,
                                        },
                                    });
                                    return;
                                }
                            }
                            else {
                                startDiff = dataStart < curTime ? curTime - dataStart : 0;
                                bufferThreshold += startDiff;
                                break;
                            }
                        }
                        var preE = dataStart;
                        var blen = 0;
                        var qc = 0;
                        for (var i = 0; i < queue.length; i++) {
                            if (i !== 0 && preE + 0.1 < queue[i].time) {
                                //logHandler.log("Gap???: preE:"+preE+", curS:"+buffer.queue[i].time);
                                break;
                            }
                            dataDur += queue[i].dur;
                            preE += queue[i].dur;
                            blen = _this.getBufferLength(buffer, preE);
                            preE += blen;
                            dataDur += blen;
                            qc++;
                            if (bufferThreshold <= dataDur) {
                                break;
                            }
                        }
                        if (dataDur < bufferThreshold - 0.1 &&
                            dataDur < _this.prefetchThreshold[buffer.type] - 0.5) {
                            NXDebug.info('append[' +
                                buffer.type +
                                ']: dataDur:' +
                                dataDur +
                                ', bufferThreshold:' +
                                bufferThreshold +
                                ', ' +
                                _this.prefetchThreshold[buffer.type] +
                                ', qlen:' +
                                queue.length);
                            buffer.underThreshold = true;
                            return;
                        }
                        else {
                            dataDur = 0;
                        }
                        buffer.underThreshold = false;
                        d = buffer.queue[0];
                        startTime = d.rstime;
                        while (queue.length > 0) {
                            d = buffer.queue.shift();
                            if (buffer.pStart !== d.pStart) {
                                if (dataLength === 0) {
                                    NXDebug.debug('***** period change **** from:' +
                                        buffer.pStart +
                                        ', to:' +
                                        d.pStart);
                                    NXDebug.debug('***** startTime :::' + d.time + ' ******');
                                    buffer.pStart = d.pStart;
                                    buffer.quality = -1;
                                }
                                else {
                                    buffer.queue.unshift(d);
                                    break;
                                }
                            }
                            if (buffer.asetIdx !== d.asetIdx) {
                                if (dataLength === 0) {
                                    NXDebug.debug('***** AdaptationSet change **** from:' +
                                        buffer.asetIdx +
                                        ', to:' +
                                        d.asetIdx);
                                    NXDebug.debug('***** startTime :::' + d.time + ' ******');
                                    buffer.asetIdx = d.asetIdx;
                                    buffer.quality = -1;
                                }
                                else {
                                    queue.unshift(d);
                                    break;
                                }
                            }
                            if (buffer.quality !== d.quality) {
                                if (buffer.type === 'video') {
                                    logHandler.log_V2Q('bf[' + d.quality + '] init');
                                }
                                else {
                                    logHandler.log_A2Q('bf[' + d.quality + '] init');
                                }
                                dataLength +=
                                    buffer.initQ[d.pStart][d.asetIdx][d.quality].data.length;
                                dataArray.push(buffer.initQ[d.pStart][d.asetIdx][d.quality].data);
                                buffer.quality = d.quality;
                            }
                            dataOffset = d.offset;
                            dataLength += d.data.length;
                            dataArray.push(d.data);
                            dataDur += d.dur;
                            ast += '*';
                            if (buffer.type === 'video') {
                                logHandler.log_V2Q('bf[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0 +
                                    ast);
                                NXDebug.debug('bfv[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0);
                            }
                            else {
                                logHandler.log_A2Q('bf[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0 +
                                    ast);
                                NXDebug.debug('bfa[' +
                                    d.quality +
                                    '] t=' +
                                    parseInt(String(d.time * 100.0)) / 100.0);
                            }
                            qc--;
                            if (qc == 0 ||
                                startDiff + _this.appendEnableThreshold[buffer.type] < dataDur ||
                                d.time + d.dur > _this.mse.duration) {
                                break;
                            }
                            d = null;
                        }
                        if (dataLength == 0) {
                            return;
                        }
                        dataEnd = dataStart + dataDur;
                        dataDur -= startDiff;
                        //// concatenate
                        data = new Uint8Array(dataLength);
                        var pos = 0;
                        var da = void 0;
                        while (dataArray.length > 0) {
                            da = dataArray.shift();
                            data.set(da, pos);
                            pos += da.length;
                        }
                        if (dataOffset !== buffer.timestampOffset) {
                            buffer.timestampOffset = dataOffset;
                        }
                        buffer.startTimeAfterSeek = Number.MAX_VALUE;
                        _this._appendBuffer(buffer, data, dataDur, dataStart, dataEnd);
                        _this.eventBus.dispatchEvent({
                            type: 'appendedEnoughDataToStart',
                            data: {
                                type: buffer.type,
                            },
                        });
                        data = void 0;
                    }
                }
                else if (now < buffer.lastAppendtime) {
                    logHandler.log('now:' + now + ', last:' + buffer.lastAppendtime);
                    buffer.lastAppendtime = now;
                }
            }
            catch (err) {
                NXDebug.log('append error!! Q');
                logHandler.log('append error!! Q');
                logHandler.log(err.message);
                buffer.queue.unshift(d);
                NXDebug.log('#############################################');
                NXDebug.log(err);
            }
        };
        this.appendFromQF = function (buffer, waitingForBuffer, Threshold) {
            var d = null;
            var q = null;
            var data = null;
            var init = null;
            var len = 0;
            var cur = 0;
            var chunkQ = null;
            var offset = 0;
            var ast = '';
            var appended = false;
            var queue = undefined;
            var curTime;
            var range = null;
            var end;
            var chunkStart = 0;
            var chunkEnd = 0;
            var bufferThreshold = Threshold || 5;
            var bf;
            try {
                if (buffer.appendStart == false)
                    return;
                if (buffer.queue.length === 0)
                    return;
                if (buffer.waiting)
                    return;
                queue = buffer.queue;
                d = queue[0];
                /* istanbul ignore if */
                if (d.appending == true) {
                    if (d.chunks && d.chunks.length > 0) {
                        chunkQ = d.chunks;
                        chunkStart = chunkQ[0].start;
                        chunkEnd =
                            chunkQ[chunkQ.length - 1].start + chunkQ[chunkQ.length - 1].dur;
                        chunkQ.forEach(function (c) {
                            len += c.data.length;
                        });
                        data = new Uint8Array(len);
                        chunkQ.forEach(function (c) {
                            data.set(c.data, cur);
                            cur += c.data.length;
                        });
                        buffer.appendBuffer(data);
                        buffer.updatingRange = {
                            start: chunkStart,
                            end: chunkEnd,
                        };
                        appended = true;
                        data = null;
                        len = 0;
                        cur = 0;
                        d.chunks = [];
                    }
                    if (d.done) {
                        if (buffer.type === 'video') {
                            logHandler.log_V2Q('bf[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ast);
                            NXDebug.debug('bfv[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ',appended:' +
                                appended);
                        }
                        else {
                            logHandler.log_A2Q('bf[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ast);
                            NXDebug.debug('bfa[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ',appended:' +
                                appended);
                        }
                        queue.shift();
                        d = void 0;
                        if (queue.length == 0)
                            return;
                    }
                    if (appended)
                        return;
                }
                /* istanbul ignore next */
                if (waitingForBuffer === false) {
                    buffer.startTimeAfterSeek = Number.MAX_VALUE;
                    curTime = _this.playbackStarted
                        ? _this.videoModel.getCurrentTime()
                        : _this.videoModel.getStartTime();
                    range = _this.getBufferRange(buffer, curTime);
                    end = range ? range.end : curTime;
                    while (queue.length > 0) {
                        chunkStart = 0;
                        chunkEnd = 0;
                        d = queue[0];
                        if (d.chunks && d.done) {
                            if (d.chunks.length == 0) {
                                queue.shift();
                                continue;
                            }
                            else {
                                chunkStart = d.chunks[0].start;
                                chunkEnd =
                                    d.chunks[d.chunks.length - 1].start +
                                        d.chunks[d.chunks.length - 1].dur;
                            }
                        }
                        else {
                            if (d.chunks && d.chunks.length > 0) {
                                chunkStart = d.chunks[0].start;
                                chunkEnd =
                                    d.chunks[d.chunks.length - 1].start +
                                        d.chunks[d.chunks.length - 1].dur;
                            }
                            else {
                                return;
                            }
                        }
                        if (chunkEnd < curTime - d.dur) {
                            NXDebug.log('[' +
                                buffer.type +
                                ']discard curTime:' +
                                curTime +
                                ', q:end' +
                                chunkEnd);
                            logHandler.log('[' +
                                buffer.type +
                                ']discard curTime:' +
                                curTime +
                                ', q:end' +
                                chunkEnd);
                            queue.shift();
                        }
                        else if (end + 0.1 < chunkStart) {
                            if (chunkEnd - curTime > 20) {
                                return;
                            }
                            else if (d.rstime <= end + 0.1 &&
                                d.rstime < chunkStart &&
                                d.rstime != d.pStart) {
                                logHandler.log('[' +
                                    buffer.type +
                                    '] Gap!!' +
                                    ' end:' +
                                    end +
                                    ', rstime:' +
                                    d.rstime +
                                    ', chunkStart:' +
                                    chunkStart +
                                    ',ps:' +
                                    d.pStart);
                                NXDebug.info('[' +
                                    buffer.type +
                                    '] Gap!!' +
                                    ' end:' +
                                    end +
                                    ', rstime:' +
                                    d.rstime +
                                    ', chunkStart:' +
                                    chunkStart);
                                _this.eventBus.dispatchEvent({
                                    type: 'checkBufferGap',
                                    data: {
                                        type: buffer.type,
                                        time: d.rstime - d.dur / 2,
                                    },
                                });
                                return;
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                    if (queue.length == 0)
                        return;
                    d = queue[0];
                    if (buffer.pStart !== d.pStart) {
                        NXDebug.debug('***** period change **** from:' +
                            buffer.pStart +
                            ', to:' +
                            d.pStart);
                        NXDebug.debug('***** startTime :::' + d.time + ' ******');
                        buffer.pStart = d.pStart;
                        buffer.quality = -1;
                    }
                    if (buffer.asetIdx != d.asetIdx) {
                        NXDebug.debug('***** AdaptationSet change **** from:' +
                            buffer.asetIdx +
                            ', to:' +
                            d.asetIdx);
                        NXDebug.debug('***** startTime :::' + d.time + ' ******');
                        buffer.asetIdx = d.asetIdx;
                        buffer.quality = -1;
                    }
                    if (buffer.quality != d.quality) {
                        if (buffer.type === 'video') {
                            logHandler.log_V2Q('bf[' + d.quality + '] init');
                        }
                        else {
                            logHandler.log_A2Q('bf[' + d.quality + '] init');
                        }
                        len += buffer.initQ[d.pStart][d.asetIdx][d.quality].data.length;
                        init = buffer.initQ[d.pStart][d.asetIdx][d.quality].data;
                        buffer.quality = d.quality;
                    }
                    offset = d.offset;
                    if (offset != buffer.timestampOffset) {
                        buffer.timestampOffset = offset;
                    }
                    chunkQ = d.chunks;
                    chunkQ.forEach(function (c) {
                        len += c.data.length;
                    });
                    data = new Uint8Array(len);
                    if (init) {
                        data.set(init, cur);
                        cur += init.length;
                    }
                    chunkQ.forEach(function (c) {
                        data.set(c.data, cur);
                        cur += c.data.length;
                    });
                    buffer.appendBuffer(data);
                    buffer.updatingRange = {
                        start: chunkStart,
                        end: chunkEnd,
                    };
                    //NXDebug.debug("["+buffer.type+"] appended t="+d.time+", q:"+buffer.queue.length);
                    //####/// buffer.laData = d;
                    data = void 0;
                    d.chunks = [];
                    d.appending = true;
                    if (d.done) {
                        if (buffer.type === 'video') {
                            logHandler.log_V2Q('bf[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ast);
                            NXDebug.debug('bfv[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ', ' +
                                parseInt(String(d.rstime * 100.0)) / 100.0);
                        }
                        else {
                            logHandler.log_A2Q('bf[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ast);
                            NXDebug.debug('bfa[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ', ' +
                                parseInt(String(d.rstime * 100.0)) / 100.0);
                        }
                        queue.shift();
                        d = void 0;
                    }
                }
                else {
                    if (!buffer.playbackStarted) {
                        if (!buffer.ready) {
                            for (var i = 0; i < queue.length; i++) {
                                q = queue[i];
                                if (q.rstime == buffer.startTimeAfterSeek) {
                                    if (q.chunks.length == 0)
                                        return;
                                    chunkStart = q.time;
                                    var startTime = q.rstime;
                                    buffer.tmpData = {
                                        diff: chunkStart - startTime,
                                        start: chunkStart,
                                        offset: q.offset,
                                    };
                                    //logHandler.log("diff: "+buffer.tmpData.diff+" , start:"+chunkStart+", offet:"+q.offset);
                                    buffer.ready = true;
                                    break;
                                }
                                else if (q.rstime > buffer.startTimeAfterSeek) {
                                    break;
                                }
                            }
                            if (!buffer.ready)
                                return;
                        }
                        var ready = true;
                        for (var i = 0; i < _this.buffers.length; i++) {
                            if (!_this.buffers[i].ready) {
                                ready = false;
                            }
                        }
                        if (ready) {
                            var minDiff = Number.MAX_VALUE;
                            var modOffset = false;
                            for (var i = 0; i < _this.buffers.length; i++) {
                                bf = _this.buffers[i];
                                if (bf.tmpData.diff < minDiff) {
                                    minDiff = bf.tmpData.diff;
                                }
                            }
                            if (minDiff > 1.0) {
                                modOffset = true;
                            }
                            else if (minDiff < 0) {
                                for (var i = 0; i < _this.buffers.length; i++) {
                                    if (_this.buffers[i].tmpData.start +
                                        _this.buffers[i].tmpData.offset <
                                        0) {
                                        logHandler.log('[' +
                                            _this.buffers[i].type +
                                            ', s:' +
                                            _this.buffers[i].tmpData.start +
                                            ', o:' +
                                            _this.buffers[i].tmpData.offset);
                                        modOffset = true;
                                        break;
                                    }
                                }
                            }
                            if (modOffset == true) {
                                for (var i = 0; i < _this.buffers.length; i++) {
                                    for (var j = 0; j < _this.buffers[i].queue.length; j++) {
                                        _this.buffers[i].queue[j].offset -= minDiff;
                                        if (_this.buffers[i].queue[j].chunks.length > 0) {
                                            _this.buffers[i].queue[j].time -= minDiff;
                                        }
                                        if (_this.buffers[i].queue[j].chunkStartTime > -1)
                                            _this.buffers[i].queue[j].chunkStartTime -= minDiff;
                                        for (var k = 0; k < _this.buffers[i].queue[j].chunks.length; k++) {
                                            _this.buffers[i].queue[j].chunks[k].start -= minDiff;
                                        }
                                    }
                                }
                            }
                            for (var i = 0; i < _this.buffers.length; i++) {
                                bf = _this.buffers[i];
                                bf.waiting = false;
                                bf.ready = false;
                                bf.playbackStarted = true;
                                if (modOffset) {
                                    _this.eventBus.dispatchEvent({
                                        type: 'needToModifyOffset',
                                        data: {
                                            type: bf.type,
                                            minDiff: minDiff,
                                        },
                                    });
                                }
                            }
                        }
                        else {
                            buffer.waiting = true;
                            return;
                        }
                    }
                    var dataArray_1 = [];
                    var dataLength_1 = 0;
                    var dataOffset = 0;
                    var dataDur_1 = 0;
                    var qTime = void 0;
                    var qDur = void 0;
                    var rstime = 0;
                    var startDiff = 0;
                    var chunks = undefined;
                    data = null;
                    ast = '';
                    curTime = _this.playbackStarted
                        ? _this.videoModel.getCurrentTime()
                        : _this.videoModel.getStartTime();
                    chunkStart = 0;
                    chunkEnd = 0;
                    while (queue.length > 0) {
                        d = queue[0];
                        chunks = d.chunks;
                        if (chunks.length > 0) {
                            chunkStart = d.chunks[0].start;
                            chunkEnd =
                                d.chunks[d.chunks.length - 1].start +
                                    d.chunks[d.chunks.length - 1].dur;
                        }
                        else {
                            chunkStart = d.time;
                            chunkEnd = d.time + d.dur;
                        }
                        qTime = d.time;
                        qDur = d.dur;
                        rstime = d.rstime;
                        startDiff = 0;
                        if (chunkStart + qDur + qDur < curTime &&
                            rstime < buffer.startTimeAfterSeek) {
                            logHandler.log('[' +
                                buffer.type +
                                '] packet received before seek -> discard c:' +
                                curTime +
                                ', q:' +
                                qTime +
                                ', rstime:' +
                                rstime);
                            NXDebug.info('[' +
                                buffer.type +
                                '] packet received before seek -> discard c:' +
                                curTime +
                                ', q:' +
                                qTime +
                                ', rstime:' +
                                rstime);
                            queue.shift();
                            if (queue.length > 0) {
                                continue;
                            }
                            else {
                                return;
                            }
                        }
                        if (rstime > buffer.startTimeAfterSeek) {
                            return;
                        }
                        if (chunks.length == 0)
                            return;
                        if (rstime != buffer.startTimeAfterSeek &&
                            curTime + 0.1 < chunkStart) {
                            range = _this.getBufferRange(buffer, curTime);
                            if (range != null && chunkStart <= range.end + 0.1) {
                                bufferThreshold -= chunkStart - curTime;
                                break;
                            }
                            else {
                                end = range != null ? range.end : curTime;
                                logHandler.log('[' +
                                    buffer.type +
                                    '] Gap!!! c:' +
                                    curTime +
                                    ', l:' +
                                    end +
                                    'q:' +
                                    qTime +
                                    ', qc:' +
                                    chunks[0].start +
                                    ', s' +
                                    _this.videoModel.getStartTime());
                                NXDebug.info('[' +
                                    buffer.type +
                                    '] Gap!!! c:' +
                                    curTime +
                                    ', l:' +
                                    end +
                                    'q:' +
                                    qTime +
                                    ', qc:' +
                                    chunks[0].start +
                                    ', s' +
                                    _this.videoModel.getStartTime());
                                var checkTime = 0;
                                if (rstime <= end + 0.1 && rstime < chunkStart) {
                                    checkTime = rstime - qDur / 2;
                                }
                                else {
                                    checkTime = end;
                                }
                                _this.eventBus.dispatchEvent({
                                    type: 'checkBufferGap',
                                    data: {
                                        type: buffer.type,
                                        time: checkTime,
                                    },
                                });
                                return;
                            }
                        }
                        else {
                            startDiff = chunkStart < curTime ? curTime - chunkStart : 0;
                            bufferThreshold += startDiff;
                            break;
                        }
                    }
                    var preE = chunkStart;
                    var blen = 0;
                    var qc = 0;
                    var dur = void 0;
                    for (var i = 0; i < queue.length; i++) {
                        q = queue[i];
                        dur = 0;
                        if (q.chunks.length == 0)
                            break;
                        if (i !== 0 && preE + 0.1 < q.chunks[0].start) {
                            break;
                        }
                        dur =
                            q.chunks[q.chunks.length - 1].dur +
                                (q.chunks[q.chunks.length - 1].start - q.chunks[0].start);
                        dataDur_1 += dur;
                        preE += dur;
                        blen = _this.getBufferLength(buffer, preE);
                        preE += blen;
                        dataDur_1 += blen;
                        qc++;
                        if (bufferThreshold <= dataDur_1) {
                            break;
                        }
                    }
                    if (dataDur_1 < bufferThreshold - 0.1 &&
                        dataDur_1 < _this.prefetchThreshold[buffer.type] - 0.5) {
                        NXDebug.info('append[' +
                            buffer.type +
                            ']: dataDur:' +
                            dataDur_1 +
                            ', bufferThreshold:' +
                            bufferThreshold +
                            ', ' +
                            _this.prefetchThreshold[buffer.type] +
                            ', qlen:' +
                            queue.length +
                            ',chunkStart:' +
                            chunkStart +
                            ', curTime:' +
                            curTime +
                            ', rstime:' +
                            rstime);
                        buffer.underThreshold = true;
                        return;
                    }
                    else {
                        dataDur_1 = 0;
                    }
                    buffer.underThreshold = false;
                    if (chunks && chunks.length == 0)
                        return;
                    while (queue.length > 0) {
                        d = queue[0];
                        if (buffer.pStart !== d.pStart) {
                            if (dataLength_1 === 0) {
                                NXDebug.debug('***** period change **** from:' +
                                    buffer.pStart +
                                    ', to:' +
                                    d.pStart);
                                NXDebug.debug('***** startTime :::' + d.time + ' ******');
                                buffer.pStart = d.pStart;
                                buffer.quality = -1;
                            }
                            else {
                                break;
                            }
                        }
                        if (buffer.asetIdx !== d.asetIdx) {
                            if (dataLength_1 === 0) {
                                NXDebug.debug('***** AdaptationSet change **** from:' +
                                    buffer.asetIdx +
                                    ', to:' +
                                    d.asetIdx);
                                NXDebug.debug('***** startTime :::' + d.time + ' ******');
                                buffer.asetIdx = d.asetIdx;
                                buffer.quality = -1;
                            }
                            else {
                                break;
                            }
                        }
                        if (buffer.quality !== d.quality) {
                            if (buffer.type === 'video') {
                                logHandler.log_V2Q('bf[' + d.quality + '] init');
                            }
                            else {
                                logHandler.log_A2Q('bf[' + d.quality + '] init');
                            }
                            dataLength_1 +=
                                buffer.initQ[d.pStart][d.asetIdx][d.quality].data.length;
                            dataArray_1.push(buffer.initQ[d.pStart][d.asetIdx][d.quality].data);
                            buffer.quality = d.quality;
                        }
                        dataOffset = d.offset;
                        d.chunks.forEach(function (c) {
                            dataLength_1 += c.data.length;
                            dataDur_1 += c.dur;
                            dataArray_1.push(c.data);
                        });
                        ast += '*';
                        if (buffer.type === 'video') {
                            logHandler.log_V2Q('bf[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ast);
                            NXDebug.debug('bfv[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ', ' +
                                parseInt(String(d.rstime * 100.0)) / 100.0);
                        }
                        else {
                            logHandler.log_A2Q('bf[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ast);
                            NXDebug.debug('bfa[' +
                                d.quality +
                                '] t=' +
                                parseInt(String(d.time * 100.0)) / 100.0 +
                                ', ' +
                                parseInt(String(d.rstime * 100.0)) / 100.0);
                        }
                        d.chunks = [];
                        d.appending = true;
                        if (d.done) {
                            queue.shift();
                        }
                        else {
                            break;
                        }
                        qc--;
                        if (qc == 0 ||
                            startDiff + _this.appendEnableThreshold[buffer.type] < dataDur_1 ||
                            d.time + d.dur > _this.mse.duration) {
                            break;
                        }
                        d = null;
                    }
                    if (dataLength_1 == 0) {
                        return;
                    }
                    chunkEnd = chunkStart + dataDur_1;
                    if (startDiff)
                        dataDur_1 -= startDiff;
                    //// concatenate
                    data = new Uint8Array(dataLength_1);
                    var pos = 0;
                    var da = void 0;
                    while (dataArray_1.length > 0) {
                        da = dataArray_1.shift();
                        data.set(da, pos);
                        pos += da.length;
                    }
                    if (dataOffset !== buffer.timestampOffset) {
                        buffer.timestampOffset = dataOffset;
                    }
                    buffer.startTimeAfterSeek = Number.MAX_VALUE;
                    buffer.appendBuffer(data);
                    buffer.updatingRange = {
                        start: chunkStart,
                        end: chunkEnd,
                    };
                    _this.eventBus.dispatchEvent({
                        type: 'appendedEnoughDataToStart',
                        data: {
                            type: buffer.type,
                        },
                    });
                    data = void 0;
                }
            }
            catch (err) {
                NXDebug.log('append error!! Q');
                logHandler.log('append error!! Q');
                logHandler.log(err.message);
                if (queue)
                    queue.unshift(d);
                NXDebug.log('#############################################');
                NXDebug.log(err);
            }
        };
        this.playbackStart = function () {
            _this.playbackStarted = true;
        };
        this.setVideoModel = function (value) {
            _this.videoModel = value;
        };
        this.setAppendStatus = function (value, buffers, val) {
            for (var i = 0; i < buffers.length; i++) {
                buffers[i].quality = val;
                buffers[i].appendStart = value;
                _this.appendFromQ(buffers[i], true);
            }
        };
        this.directAppend = function (buffer, data) {
            if ('appendBuffer' in buffer) {
                buffer.appendBuffer(data);
            }
            else if ('append' in buffer) {
                buffer.append(data);
            }
        };
        this.attachBuffer = function (buffer) {
            if (!buffer)
                return null;
            var b = _this.findBuffer(buffer);
            if (!b) {
                _this.buffers.push(buffer);
            }
            return b;
        };
        this.detachBuffer = function (buffer) {
            var idx = _this.buffers.indexOf(buffer);
            if (idx > -1) {
                _this.buffers.splice(idx, 1);
            }
        };
        this.detachAllBuffers = function () {
            _this.buffers = [];
        };
        this.createSourceBuffer = function (mediaSource, codec) {
            try {
                return {
                    status: 'ok',
                    data: mediaSource.addSourceBuffer(codec),
                };
            }
            catch (ex) {
                return {
                    status: 'error',
                    msg: ex.dscription,
                };
            }
        };
        this.removeSourceBuffer = function (mediaSource, buffer) {
            try {
                mediaSource.removeSourceBuffer(buffer);
            }
            catch (ex) {
                logHandler.log(ex.description);
            }
        };
        this.getBufferRange = function (buffer, time, tolerance) {
            var ranges = null;
            var start = 0;
            var end = 0;
            var firstStart = null;
            var lastEnd = null;
            var gap = 0;
            var toler1 = tolerance || 0.15;
            var toler2 = tolerance || 0.15;
            try {
                ranges = buffer.buffered;
            }
            catch (ex) {
                return null;
            }
            if (ranges != null) {
                for (var i = 0, len = ranges.length; i < len; i += 1) {
                    start = ranges.start(i);
                    end = ranges.end(i);
                    if (firstStart === null) {
                        gap = Math.abs(start - time);
                        if (time >= start && time < end) {
                            // start the range
                            firstStart = start;
                            lastEnd = end;
                            continue;
                        }
                        else if (gap <= toler1) {
                            // start the range even though the buffer does not contain time 0
                            firstStart = start;
                            lastEnd = end;
                            continue;
                        }
                    }
                    else {
                        gap = start - lastEnd;
                        if (gap <= toler2) {
                            // the discontinuity is smaller than the tolerance, combine the ranges
                            lastEnd = end;
                        }
                        else {
                            break;
                        }
                    }
                }
                if (firstStart !== null) {
                    return {
                        start: firstStart,
                        end: lastEnd,
                    };
                }
            }
            return null;
        };
        this.getAllRanges = function (buffer) {
            var ranges = null;
            try {
                ranges = buffer.buffered;
                return ranges;
            }
            catch (ex) {
                return null;
            }
        };
        this.waitForUpdateEnd = function (buffer, callback) {
            if (buffer.updating === false) {
                callback(true);
                return;
            }
            var intervalId;
            var CHECK_INTERVAL = 50;
            /* istanbul ignore next */
            var checkIsUpdateEnded = function () {
                // if undating is still in progress do nothing and wait for the next check again.
                if (buffer.updating)
                    return;
                // updating is completed, now we can stop checking and resolve the promise
                clearInterval(intervalId);
                callback(true);
            };
            /* istanbul ignore next */
            var updateEndHandler = function () {
                if (buffer.updating)
                    return;
                buffer.removeEventListener('updateend', updateEndHandler, false);
                callback(true);
            };
            // use updateend event if possible
            if (typeof buffer.addEventListener === 'function') {
                try {
                    buffer.addEventListener('updateend', updateEndHandler, false);
                }
                catch (err) {
                    // use setInterval to periodically check if updating has been completed
                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);
                }
            }
            else {
                // use setInterval to periodically check if updating has been completed
                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);
            }
        };
        this.dataQduration = function (buffer, _segTmpl) {
            var curTime = _this.playbackStarted
                ? _this.videoModel.getCurrentTime()
                : _this.videoModel.getStartTime();
            var range = _this.getBufferRange(buffer, curTime);
            var endTime = range != null ? range.end : curTime;
            var dur = 0;
            var q;
            if (true) {
                // eslint-disable-line no-constant-condition
                if (buffer.queue)
                    for (var i = 0; i < buffer.queue.length; i++) {
                        q = buffer.queue[i];
                        if (q.type === 'data') {
                            if (q.time < endTime + _this.prefetchThreshold[buffer.type] &&
                                endTime < q.time + q.dur) {
                                dur += q.dur;
                            }
                        }
                    }
            } /* istanbul ignore next */
            else { var i, endPlusQ; }
            return dur;
        };
        // endTime = (buffer: ExSourceBuffer): number => {
        //   let endTime: number = 0;
        //   let len: number = 0;
        //   if (buffer.queue) {
        //     len = buffer.queue.length;
        //     if (len > 0) {
        //       endTime = buffer.queue[len - 1].time + buffer.queue[len - 1].dur;
        //     }
        //   }
        //   return endTime;
        // };
        // dataQlength = (buffer: ExSourceBuffer): number => {
        //   let len: number = 0;
        //   if (buffer.queue)
        //     for (let i = 0; i < buffer.queue.length; i++) {
        //       if (buffer.queue[i].type === 'data') {
        //         len += 1;
        //       }
        //     }
        //   return len;
        // };
        this.setMediaSource = function (value) {
            _this.mse = value;
        };
        this.remove = function (buffer, start, end, _duration, mediaSource, callback) {
            try {
                // make sure that the given time range is correct. Otherwise we will get InvalidAccessError
                if (start >= 0 && end > start && mediaSource.readyState !== 'ended') {
                    buffer.remove(start, end);
                }
                // updating is in progress, we should wait for it to complete before signaling that this operation is done
                _this.waitForUpdateEnd(buffer, function (_f) {
                    // eslint-disable-line no-unused-vars
                    callback(true);
                });
            }
            catch (err) {
                callback(false);
            }
        };
        this.abort = function (mediaSource, buffer) {
            _this.playbackStarted = false;
            try {
                if (mediaSource.readyState === 'open') {
                    buffer.abort();
                }
            }
            catch (ex) {
                logHandler.log(ex.description);
            }
        };
        this.playbackStarted = false;
        this.prefetchThreshold = {
            video: params.BUFFER_PREFETCH_THRESHOLD_V !== undefined
                ? params.BUFFER_PREFETCH_THRESHOLD_V
                : params.BUFFER_PREFETCH_THRESHOLD || 15,
            audio: params.BUFFER_PREFETCH_THRESHOLD_A !== undefined
                ? params.BUFFER_PREFETCH_THRESHOLD_A
                : params.BUFFER_PREFETCH_THRESHOLD || 15,
        };
        this.appendEnableThreshold = {
            video: params.MSE_APPEND_ENABLE_THRESHOLD_V !== undefined
                ? params.MSE_APPEND_ENABLE_THRESHOLD_V
                : params.MSE_APPEND_ENABLE_THRESHOLD || 5,
            audio: params.MSE_APPEND_ENABLE_THRESHOLD_A !== undefined
                ? params.MSE_APPEND_ENABLE_THRESHOLD_A
                : params.MSE_APPEND_ENABLE_THRESHOLD || 5,
        };
        this.eventBus = eventBus;
        this.useFetch = params.USE_FETCH && 'fetch' in window ? true : false;
        this.buffers = [];
        this.append = this.useFetch ? this.appendF : this.appendX;
        this.appendFromQ = this.useFetch ? this.appendFromQF : this.appendFromQX;
    }
    SourceBufferExtensions.prototype.getBufferLength = function (buffer, time, tolerance) {
        var range = this.getBufferRange(buffer, time, this.videoModel.getCurrentTime() > 0 ? tolerance : 0.5);
        if (range === null) {
            return 0;
        }
        else {
            return range.end - time;
        }
    };
    return SourceBufferExtensions;
}());



/***/ }),

/***/ "./ts/dash/streaming/Stream.ts":
/*!*************************************!*\
  !*** ./ts/dash/streaming/Stream.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stream": function() { return /* binding */ Stream; }
/* harmony export */ });
/* harmony import */ var _BufferController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BufferController */ "./ts/dash/streaming/BufferController.ts");
/* harmony import */ var _manifest_DashHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manifest/DashHandler */ "./ts/dash/manifest/DashHandler.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _FragmentController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FragmentController */ "./ts/dash/streaming/FragmentController.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _SourceBufferExtensions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SourceBufferExtensions */ "./ts/dash/streaming/SourceBufferExtensions.ts");
/* harmony import */ var _StreamController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./StreamController */ "./ts/dash/streaming/StreamController.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/* harmony import */ var _protection_ProtectionController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../protection/ProtectionController */ "./ts/dash/protection/ProtectionController.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */










/**
 * Stream
 *
 * @module Stream（Streamモジュール）
 */
/**
 * Stream
 * @constructor
 */
var Stream = /** @class */ (function () {
    function Stream(params, eventBus, manifestModel, metricsModel, abrController, xhrCustom) {
        var _this = this;
        this.updateDataReason = _StreamController__WEBPACK_IMPORTED_MODULE_7__.UpdateDataReason;
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_3__["default"];
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_5__["default"];
        this.play = function (manual) {
            if (!_this.initialized) {
                return;
            }
            _this.videoModel.play(manual);
        };
        this.pause = function (manual) {
            _this.scheduleWhilePaused = false;
            _this.suspend.call(_this);
            _this.videoModel.pause(manual);
            _this.videoModel.setSelfPaused(manual);
        };
        this.seek = function (time) {
            if (!_this.initialized) {
                return;
            }
            _this.NXDebug.debug('Do seek: ' + time);
            if (!_this.videoModel.isDummy()) {
                _this.eventBus.dispatchEvent({
                    type: 'setCurrentTime',
                    data: {},
                });
                _this.videoModel.setCurrentTime(time);
            }
            else {
                _this.videoModel.setStartTime(time);
            }
            _this.startBuffering(time, time, '1');
        };
        this.supportsCodec = function (element, codec) {
            if (!(element instanceof HTMLVideoElement)) {
                throw 'element must be of type HTMLVideoElement.';
            }
            _this.logHandler.log('codec:::' + codec);
            var canPlay = element.canPlayType(codec);
            _this.logHandler.log('canPlay:::' + canPlay);
            return canPlay === 'probably' || canPlay === 'maybe';
        };
        //NSV-a // Media Source
        //NSV-a const setUpMediaSource = function (mediaSourceArg, _callback) {
        //NSV-a     const callback = _callback || (() => {});
        //NSV-a     const self = this;
        //NSV-a
        //NSV-a     const onMediaSourceOpen = (e) => {
        //NSV-a       NXDebug.debug('MediaSource is open!');
        //NSV-a       NXDebug.debug(e);
        //NSV-a
        //NSV-a       mediaSourceArg.removeEventListener('sourceopen', onMediaSourceOpen);
        //NSV-a       mediaSourceArg.removeEventListener(
        //NSV-a         'webkitsourceopen',
        //NSV-a         onMediaSourceOpen
        //NSV-a       );
        //NSV-a       logHandler.log('readyState :' + mediaSourceArg.readyState);
        //NSV-a       callback(mediaSourceArg);
        //NSV-a     };
        //NSV-a
        //NSV-a     mediaSourceArg.addEventListener('sourceopen', onMediaSourceOpen, false);
        //NSV-a     mediaSourceArg.addEventListener(
        //NSV-a       'webkitsourceopen',
        //NSV-a       onMediaSourceOpen,
        //NSV-a       false
        //NSV-a     );
        //NSV-a
        //NSV-a     attachMediaSource.call(self, mediaSourceArg, videoModel);
        //NSV-a
        //NSV-a     setTimeout(() => {
        //NSV-a       NXDebug.log('readyState : ' + mediaSourceArg.readyState);
        //NSV-a     }, 3000);
        //NSV-a   };
        this.tearDownMediaSource = function () {
            if (_this.videoController != null) {
                _this.videoController.reset(_this.errored);
            }
            if (_this.audioController != null) {
                _this.audioController.reset(_this.errored);
            }
            if (_this.textController != null) {
                _this.textController.reset(_this.errored);
            }
            if (_this.mediaSource != null) {
                _this.sourceBufferExt.setAppendStatus(false, [], 0);
                _this.sourceBufferExt.detachAllBuffers();
            }
            _this.initialized = false;
            _this.audioInitData = [];
            _this.videoInitData = [];
            _this.eventTimerList = [];
            _this.audioInitReceived = false;
            _this.videoInitReceived = false;
            _this.lastCheckGapTime = -1;
            if (_this.checkGapTimerId) {
                clearInterval(_this.checkGapTimerId);
                _this.checkGapTimerId = null;
            }
            _this.nextPeriodTopIsAlreadyBuffered = false;
            _this.contentProtections = null;
            _this.videoController = null;
            _this.audioController = null;
            _this.textController = null;
            _this.sourceBufferExt = null;
            _this.videoCodec = null;
            _this.audioCodec = null;
            _this.mediaSource = null;
            _this.manifest = null;
        };
        //NSV-a const setMinTimestampOffset = () => {
        //NSV-a   let asets;
        //NSV-a   let i;
        //NSV-a   let j;
        //NSV-a   let reps;
        //NSV-a
        //NSV-a   if (periodInfo.timestampOffsetFor32bitVE === 0) {
        //NSV-a     asets = periodInfo.adaptationSets;
        //NSV-a     let minTimestampOffset = 0xffffffffffffffff;
        //NSV-a     for (i = 0; i < asets.length; i++) {
        //NSV-a       reps = asets[i].representations;
        //NSV-a       for (j = 0; j < reps.length; j++) {
        //NSV-a         if (minTimestampOffset > reps[j].timestampOffsetFor32bitVE) {
        //NSV-a           minTimestampOffset = reps[j].timestampOffsetFor32bitVE;
        //NSV-a         }
        //NSV-a       }
        //NSV-a     }
        //NSV-a     periodInfo.timestampOffsetFor32bitVE = minTimestampOffset;
        //NSV-a   } else {
        //NSV-a     asets = periodInfo.adaptationSets;
        //NSV-a     for (i = 0; i < asets.length; i++) {
        //NSV-a       reps = asets[i].representations;
        //NSV-a       for (j = 0; j < reps.length; j++) {
        //NSV-a         reps[j].presentationTimeOffset -=
        //NSV-a           periodInfo.timestampOffsetFor32bitVE;
        //NSV-a       }
        //NSV-a     }
        //NSV-a   }
        //NSV-a };
        /* istanbul ignore next */
        this.initializeVideoSource = function (startTime, callback) {
            var self = _this;
            var videoData = _this.periodInfo.getDataForRole('video', _this.DEFAULT_ROLE_FOR_VIDEO);
            var convertCodecType = false;
            var buffer = null;
            if (videoData !== null) {
                _this.videoCodec = videoData.getCodec();
                _this.NXDebug.log('Video codec: ' + _this.videoCodec);
                if (_this.videoCodec.indexOf('hvc') > -1 ||
                    _this.videoCodec.indexOf('hev') > -1) {
                    _this.params.BDAT_INSERT_MODE = false;
                }
                _this.contentProtections = videoData.getContentProtectionData();
                if (!_this.supportsCodec.call(self, _this.videoModel.getElement(), _this.videoCodec)) {
                    var msg = 'Video Codec (' + _this.videoCodec + ') is not supported.';
                    if (_this.videoCodec.indexOf('hev1') > -1) {
                        if (_this.supportsCodec.call(self, _this.videoModel.getElement(), _this.videoCodec.replace('hev1', 'hvc1'))) {
                            _this.videoCodec = _this.videoCodec.replace('hev1', 'hvc1');
                            _this.logHandler.log('Trying to convert hev1 -> hvc1');
                            convertCodecType = true;
                        }
                        else {
                            _this.errHandler.manifestError(_this.eventBus, msg, 'codec', _this.manifest);
                            _this.NXDebug.log(msg);
                            //return false;
                            callback({
                                status: 'fail',
                                msg: msg,
                            });
                        }
                    }
                    else {
                        _this.errHandler.manifestError(_this.eventBus, msg, 'codec', _this.manifest);
                        _this.NXDebug.log(msg);
                        //return false;
                        callback({
                            status: 'fail',
                            msg: msg,
                        });
                    }
                }
                else if (_this.contentProtections != null &&
                    !_this.protectionController.supportsProtection()) {
                    _this.logHandler.log('initializeVideoSource noProtection');
                    _this.errHandler.capabilityError(_this.eventBus, 'mediakeys');
                    _this.contentProtections = null;
                    //return false;
                    callback({
                        status: 'fail',
                        msg: 'initializeVideoSource noProtection ',
                    });
                }
                else {
                    _this.logHandler.log_item('codec_video', 'V-Codec: ' + _this.videoCodec);
                    var result = _this.sourceBufferExt.createSourceBuffer(_this.mediaSource, _this.videoCodec);
                    if (result.status === 'ok') {
                        buffer = result.data;
                        _this.logHandler.log('video buffer was successfully created.' + _this.videoCodec);
                        if (buffer === null) {
                            _this.NXDebug.log('No buffer was created, skipping video stream.');
                            callback({
                                status: 'ok',
                                data: null,
                            });
                        }
                        else {
                            _this.videoController = new _BufferController__WEBPACK_IMPORTED_MODULE_0__.BufferController();
                            buffer.type = 'video';
                            // @ts-ignore
                            if (convertCodecType == true) {
                                buffer.convertCodecType = true;
                            }
                            _this.videoController.initialize(_this.params, 'video', _this.periodInfo, videoData, buffer, _this.videoModel, _this.fragmentController, _this.mediaSource, _this.eventBus, _this.manifestModel, _this.metricsModel, _this.abrController, _this.sourceBufferExt, _this.indexHandler, startTime, function (d) {
                                if (d.status == 'ok') {
                                    _this.NXDebug.log('Video is ready!');
                                    callback({
                                        status: 'ok',
                                        data: d.data,
                                    });
                                }
                                else {
                                    callback({
                                        status: 'fail',
                                        msg: d.msg,
                                    });
                                }
                            });
                        }
                        //return true;
                    }
                    else {
                        _this.logHandler.log('Failed to create video buffer' + _this.videoCodec);
                        if (_this.videoCodec.indexOf('hev1') > -1) {
                            _this.videoCodec = _this.videoCodec.replace('hev1', 'hvc1');
                            _this.logHandler.log('Trying to convert hev1 -> hvc1');
                            convertCodecType = true;
                            result = _this.sourceBufferExt.createSourceBuffer(_this.mediaSource, _this.videoCodec);
                            if (result.status === 'ok') {
                                buffer = result.data;
                                _this.logHandler.log('video buffer was successfully created.' + _this.videoCodec);
                                if (buffer === null) {
                                    _this.NXDebug.log('No buffer was created, skipping video stream.');
                                    callback({
                                        status: 'ok',
                                        data: null,
                                    });
                                }
                                else {
                                    _this.videoController = new _BufferController__WEBPACK_IMPORTED_MODULE_0__.BufferController();
                                    buffer.type = 'video';
                                    if (convertCodecType == true) {
                                        buffer.convertCodecType = true;
                                    }
                                    _this.videoController.initialize(_this.params, 'video', _this.periodInfo, videoData, buffer, _this.videoModel, _this.fragmentController, _this.mediaSource, _this.eventBus, _this.manifestModel, _this.metricsModel, _this.abrController, _this.sourceBufferExt, _this.indexHandler, startTime, function (d) {
                                        if (d.status == 'ok') {
                                            _this.NXDebug.log('Video is ready!');
                                            callback({
                                                status: 'ok',
                                                data: d.data,
                                            });
                                        }
                                        else {
                                            callback({
                                                status: 'fail',
                                                msg: d.msg,
                                            });
                                        }
                                    });
                                }
                                //return true;
                            }
                            else {
                                _this.errHandler.mediaSourceError(_this.eventBus, 'Error creating video source buffer.');
                                //return true;
                                callback({
                                    status: 'ok',
                                    data: null,
                                });
                            }
                        }
                        else {
                            _this.errHandler.mediaSourceError(_this.eventBus, 'Error creating video source buffer.');
                            callback({
                                status: 'ok',
                                data: null,
                            });
                            //return true;
                        }
                    }
                }
            }
            else {
                _this.NXDebug.log('No video data.');
                _this.eventBus.dispatchEvent({
                    type: 'initDataReceived',
                    data: {
                        type: 'video',
                        initData: null,
                    },
                });
                callback({
                    status: 'ok',
                    data: null,
                });
                //return true;
            }
        };
        /* istanbul ignore next */
        this.initializeAudioSource = function (startTime, callback) {
            var self = _this;
            var primaryAudioData = _this.periodInfo.getDataForRole('audio', _this.DEFAULT_ROLE_FOR_AUDIO);
            if (primaryAudioData !== null) {
                _this.audioCodec = primaryAudioData.getCodec();
                _this.NXDebug.log('Audio codec: ' + _this.audioCodec);
                _this.contentProtections = primaryAudioData.getContentProtectionData();
                if (!_this.supportsCodec.call(self, _this.videoModel.getElement(), _this.audioCodec)) {
                    var msg = 'Audio Codec (' + _this.audioCodec + ') is not supported.';
                    _this.errHandler.manifestError(_this.eventBus, msg, 'codec', _this.manifest);
                    _this.NXDebug.log(msg);
                    //return false;
                    callback({
                        status: 'fail',
                        msg: msg,
                    });
                }
                else if (_this.contentProtections != null &&
                    !_this.protectionController.supportsProtection()) {
                    _this.errHandler.capabilityError(_this.eventBus, 'mediakeys');
                    _this.contentProtections = null;
                    //return false;
                    callback({
                        status: 'fail',
                        msg: 'Audio contents protection error',
                    });
                }
                else {
                    _this.logHandler.log_item('codec_audio', 'A-Codec: ' + _this.audioCodec);
                    var result = _this.sourceBufferExt.createSourceBuffer(_this.mediaSource, _this.audioCodec);
                    if (result.status === 'ok') {
                        var buffer = result.data;
                        _this.NXDebug.debug(String(buffer));
                        if (buffer === null) {
                            _this.NXDebug.log('No buffer was created, skipping audio stream.');
                            callback({
                                status: 'ok',
                                data: null,
                            });
                        }
                        else {
                            _this.audioController = new _BufferController__WEBPACK_IMPORTED_MODULE_0__.BufferController();
                            buffer.type = 'audio';
                            _this.audioController.initialize(_this.params, 'audio', _this.periodInfo, primaryAudioData, buffer, _this.videoModel, _this.fragmentController, _this.mediaSource, _this.eventBus, _this.manifestModel, _this.metricsModel, _this.abrController, _this.sourceBufferExt, _this.indexHandler, startTime, function (d) {
                                if (d.status == 'ok') {
                                    callback({
                                        status: 'ok',
                                        data: d.data,
                                    });
                                }
                                else {
                                    callback({
                                        status: 'fail',
                                        msg: d.msg,
                                    });
                                }
                            });
                        }
                        //return true;
                    }
                    else {
                        _this.errHandler.mediaSourceError(_this.eventBus, 'Error creating audio source buffer.');
                        //return true;
                        callback({
                            status: 'ok',
                            data: null,
                        });
                    }
                }
            }
            else {
                _this.NXDebug.log('No audio streams.');
                _this.eventBus.dispatchEvent({
                    type: 'initDataReceived',
                    data: {
                        type: 'audio',
                        initData: null,
                    },
                });
                callback({
                    status: 'ok',
                    data: null,
                });
                //return true;
            }
        };
        this.tempInitializeVideoSource = function (startTime, callback) {
            var videoData = _this.periodInfo.getDataForRole('video', _this.DEFAULT_ROLE_FOR_VIDEO);
            if (videoData !== null) {
                _this.videoCodec = videoData.getCodec();
                _this.NXDebug.log('Video codec: ' + _this.videoCodec);
                if (_this.videoCodec.indexOf('hvc') > -1 ||
                    _this.videoCodec.indexOf('hev') > -1) {
                    _this.params.BDAT_INSERT_MODE = false;
                }
                _this.contentProtections = videoData.getContentProtectionData();
                _this.logHandler.log_item('codec_video', 'V-Codec: ' + _this.videoCodec);
                var buffer = {
                    type: 'video',
                    buffered: {
                        length: 0,
                        start: function (_index) { return 0; },
                        end: function (_index) { return 0; },
                    },
                };
                _this.videoController = new _BufferController__WEBPACK_IMPORTED_MODULE_0__.BufferController();
                _this.videoController.initialize(_this.params, 'video', _this.periodInfo, videoData, buffer, _this.videoModel, _this.fragmentController, _this.mediaSource, _this.eventBus, _this.manifestModel, _this.metricsModel, _this.abrController, _this.sourceBufferExt, _this.indexHandler, startTime, function (d) {
                    if (d.status == 'ok') {
                        _this.NXDebug.log('Video is ready!');
                        callback({
                            status: 'ok',
                            data: d.data,
                        });
                    }
                    else {
                        callback({
                            status: 'fail',
                            msg: d.msg,
                        });
                    }
                });
            }
            else {
                _this.NXDebug.log('No video data.');
                _this.eventBus.dispatchEvent({
                    type: 'initDataReceived',
                    data: {
                        type: 'video',
                        initData: null,
                    },
                });
                callback({
                    status: 'ok',
                    data: null,
                });
            }
        };
        this.tempInitializeAudioSource = function (startTime, callback) {
            var primaryAudioData = _this.periodInfo.getDataForRole('audio', _this.DEFAULT_ROLE_FOR_AUDIO);
            if (primaryAudioData !== null) {
                _this.audioCodec = primaryAudioData.getCodec();
                _this.NXDebug.log('Audio codec: ' + _this.audioCodec);
                _this.contentProtections = primaryAudioData.getContentProtectionData();
                _this.logHandler.log_item('codec_audio', 'A-Codec: ' + _this.audioCodec);
                var buffer = {
                    type: 'audio',
                    buffered: {
                        length: 0,
                        start: function (_index) { return 0; },
                        end: function (_index) { return 0; },
                    },
                };
                _this.audioController = new _BufferController__WEBPACK_IMPORTED_MODULE_0__.BufferController();
                _this.audioController.initialize(_this.params, 'audio', _this.periodInfo, primaryAudioData, buffer, _this.videoModel, _this.fragmentController, _this.mediaSource, _this.eventBus, _this.manifestModel, _this.metricsModel, _this.abrController, _this.sourceBufferExt, _this.indexHandler, startTime, function (d) {
                    if (d.status == 'ok') {
                        callback({
                            status: 'ok',
                            data: d.data,
                        });
                    }
                    else {
                        callback({
                            status: 'fail',
                            msg: d.msg,
                        });
                    }
                });
            }
            else {
                _this.NXDebug.log('No audio streams.');
                _this.eventBus.dispatchEvent({
                    type: 'initDataReceived',
                    data: {
                        type: 'audio',
                        initData: null,
                    },
                });
                callback({
                    status: 'ok',
                    data: null,
                });
            }
        };
        /* istanbul ignore next */
        this.updateSourceBuffer = function () {
            var buffer;
            var result;
            if (_this.videoController != null) {
                var videoData = _this.periodInfo.getDataForRole('video', _this.DEFAULT_ROLE_FOR_VIDEO);
                if (videoData !== null) {
                    _this.videoCodec = videoData.getCodec();
                    _this.NXDebug.log('Video codec: ' + _this.videoCodec);
                    if (_this.videoCodec.indexOf('hvc') > -1 ||
                        _this.videoCodec.indexOf('hev') > -1) {
                        _this.params.BDAT_INSERT_MODE = false;
                    }
                    result = _this.sourceBufferExt.createSourceBuffer(_this.mediaSource, _this.videoCodec);
                    if (result.status === 'ok') {
                        buffer = result.data;
                        _this.logHandler.log('video buffer was successfully created.' + _this.videoCodec);
                        if (buffer === null) {
                            _this.NXDebug.log('No buffer was created, skipping video stream.');
                        }
                        else {
                            _this.videoController.update(buffer, _this.videoModel, _this.mediaSource);
                        }
                    }
                    else {
                        _this.logHandler.log('Failed to create video buffer' + _this.videoCodec);
                        if (_this.videoCodec.indexOf('hev1') > -1) {
                            _this.videoCodec = _this.videoCodec.replace('hev1', 'hvc1');
                            _this.logHandler.log('Trying to convert hev1 -> hvc1');
                            result = _this.sourceBufferExt.createSourceBuffer(_this.mediaSource, _this.videoCodec);
                            if (result.status === 'ok') {
                                buffer = result.data;
                                _this.logHandler.log('video buffer was successfully created.' + _this.videoCodec);
                                if (buffer === null) {
                                    _this.NXDebug.log('No buffer was created, skipping video stream.');
                                }
                                else {
                                    _this.videoController.update(buffer, _this.videoModel, _this.mediaSource, true);
                                }
                            }
                        }
                    }
                }
            }
            if (_this.audioController != null) {
                var primaryAudioData = _this.periodInfo.getDataForRole('audio', _this.DEFAULT_ROLE_FOR_AUDIO);
                if (primaryAudioData !== null) {
                    _this.audioCodec = primaryAudioData.getCodec();
                    _this.NXDebug.log('Audio codec: ' + _this.audioCodec);
                    result = _this.sourceBufferExt.createSourceBuffer(_this.mediaSource, _this.audioCodec);
                    if (result.status === 'ok') {
                        buffer = result.data;
                        _this.NXDebug.debug(String(buffer));
                        if (buffer === null) {
                            _this.NXDebug.log('No buffer was created, skipping audio stream.');
                        }
                        else {
                            _this.audioController.update(buffer, _this.videoModel, _this.mediaSource);
                        }
                    }
                }
            }
        };
        //NSV-a //Check This function should be reviewed about "buffer" as an undefined variable.
        //NSV-a const initializeTextSource = () => {
        //NSV-a     const textData = periodInfo.getPrimaryMediaData('text');
        //NSV-a     let mimeType;
        //NSV-a
        //NSV-a     if (textData !== null) {
        //NSV-a       mimeType = textData.getMimeType();
        //NSV-a       const result = sourceBufferExt.createSourceBuffer(
        //NSV-a         mediaSource,
        //NSV-a         mimeType
        //NSV-a       );
        //NSV-a       if (result.status === 'ok') {
        //NSV-a         if (buffer === null) {
        //NSV-a           NXDebug.log('Source buffer was not created for text track');
        //NSV-a         } else {
        //NSV-a           textController = new DashTVPlayer.TextController();
        //NSV-a           textController.initialize(
        //NSV-a             periodInfo,
        //NSV-a             textData,
        //NSV-a             buffer,
        //NSV-a             videoModel,
        //NSV-a             mediaSource
        //NSV-a           );
        //NSV-a           if (utils.hasProperty(buffer, 'initialize')) {
        //NSV-a             buffer.initialize(mimeType, textController);
        //NSV-a           }
        //NSV-a           return true;
        //NSV-a         }
        //NSV-a       } else {
        //NSV-a         NXDebug.log('Error creating text source buffer:');
        //NSV-a         NXDebug.log(result.msg);
        //NSV-a         errHandler.mediaSourceError(
        //NSV-a           eventBus,
        //NSV-a           'Error creating text source buffer.'
        //NSV-a         );
        //NSV-a         return true;
        //NSV-a       }
        //NSV-a     } else {
        //NSV-a       NXDebug.log('No text tracks.');
        //NSV-a       return true;
        //NSV-a     }
        //NSV-a   };
        this.initializeMediaSource = function (callback) {
            var self = _this;
            if (!_this.manifestModel.getIsDynamic(_this.manifest)) {
                _this.videoModel.setStartTime(_this.initialPresentationStartTime);
            }
            if (_this.protectionController) {
                _this.protectionController.createMediaKeysFromMPD(_this.periodInfo.getDataForRole('video', _this.DEFAULT_ROLE_FOR_VIDEO), _this.periodInfo.getDataForRole('audio', _this.DEFAULT_ROLE_FOR_AUDIO));
            }
            _this.initializeVideoSource(_this.initialPresentationStartTime, function (d) {
                if (d.status == 'ok') {
                    var ist_1 = d.data != null ? d.data : _this.initialPresentationStartTime;
                    _this.initializeAudioSource(ist_1, function (f) {
                        if (f.status == 'ok') {
                            if (!_this.videoController && !_this.audioController) {
                                callback(false);
                            }
                            else {
                                _this.startBuffering.call(self, ist_1, f.data, 'INITIAL');
                                callback(true);
                            }
                        }
                        else {
                            _this.startBuffering.call(self, ist_1, ist_1, 'INITIAL');
                            callback(true);
                        }
                    });
                }
                else {
                    callback(false);
                }
            });
        };
        this.tempInitializeMediaSource = function (callback) {
            var self = _this;
            if (!_this.manifestModel.getIsDynamic(_this.manifest)) {
                _this.videoModel.setStartTime(_this.initialPresentationStartTime);
            }
            _this.tempInitializeVideoSource(_this.initialPresentationStartTime, function (d) {
                if (d.status == 'ok') {
                    var ist_2 = d.data || _this.initialPresentationStartTime;
                    _this.tempInitializeAudioSource(ist_2, function (f) {
                        if (f.status == 'ok') {
                            if (!_this.videoController && !_this.audioController) {
                                callback(false);
                            }
                            else {
                                _this.startBuffering.call(self, ist_2, f.data, 'INITIAL');
                                callback(true);
                            }
                        }
                        else {
                            _this.startBuffering.call(self, ist_2, ist_2, 'INITIAL');
                            callback(true);
                        }
                    });
                }
                else {
                    callback(false);
                }
            });
        };
        this.setDuration = function (update) {
            if (_this.manifest.mpd.type === 'static') {
                try {
                    if (_this.manifest.mpd.mediaPresentationDuration != null &&
                        _this.manifest.mpd.mediaPresentationDuration !== Infinity) {
                        _this.mediaSource.duration =
                            _this.manifest.mpd.mediaPresentationDuration;
                    }
                    else {
                        _this.mediaSource.duration =
                            _this.periodInfoArray[_this.periodInfoArray.length - 1].end;
                    }
                }
                catch (e) {
                    _this.logHandler.log('duration cannot be changed while buffer updating');
                }
                _this.NXDebug.log('Duration successfully set to: ' + _this.mediaSource.duration);
            }
            else {
                if (update)
                    _this.mediaSource.duration = _this.periodInfo.mpd.liveEdge;
            }
        };
        //NSV-a const checkAcrossPeriods = (curTime) => {
        //NSV-a   for (let i = 0; i < periodInfoArray.length; i++) {
        //NSV-a     if (
        //NSV-a       lastUpdateTime < periodInfoArray[i].end - 0.15 &&
        //NSV-a       periodInfoArray[i].end - 0.15 <= curTime
        //NSV-a     ) {
        //NSV-a       eventBus.dispatchEvent({
        //NSV-a         type: 'periodEnded',
        //NSV-a         data: i,
        //NSV-a       });
        //NSV-a       break;
        //NSV-a     }
        //NSV-a   }
        //NSV-a   lastUpdateTime = curTime;
        //NSV-a };
        /* istanbul ignore next */
        this.checkGap = function (nextIdx, nextStart) {
            //const self = this;
            var curTime = _this.videoModel.getCurrentTime();
            var periodStart = nextStart;
            var checkGapEnd = false;
            if (curTime !== _this.lastCheckGapTime) {
                _this.lastCheckGapTime = curTime;
                if (curTime > periodStart - _this.CHECK_GAP_INTERVAL) {
                    _this.eventBus.dispatchEvent({
                        type: 'periodEnded',
                        data: nextIdx - 1,
                    });
                    if (Math.abs(_this.videoModel.getCurrentTime() - curTime) < 0.5) {
                        if (_this.bufferGapBetweenPeriods(curTime, periodStart)) {
                            _this.logHandler.log('### detected the buffer gap. force seeking to start time of period[' +
                                nextIdx +
                                '] ***' +
                                _this.videoModel.getCurrentTime() +
                                ', ' +
                                curTime);
                            _this.NXDebug.debug('### detected the buffer gap. force seeking to start time of period[' +
                                nextIdx +
                                '] ***' +
                                _this.videoModel.getCurrentTime() +
                                ', ' +
                                curTime);
                            _this.seekToNearestStartTime(periodStart);
                        }
                        else if (_this.SKIP_PERIOD_BOUNDARY) {
                            _this.logHandler.log('### SKIP_PERIOD_BOUNDARY switch is on. force seeking to start time of period[' +
                                nextIdx +
                                '] ***');
                            _this.NXDebug.debug('### SKIP_PERIOD_BOUNDARY switch is on. force seeking to start time of period[' +
                                nextIdx +
                                '] ***');
                            _this.seekToNearestStartTime(periodStart);
                        }
                    }
                    checkGapEnd = true;
                }
                else if (curTime > periodStart + _this.EPSILON - 0.5) {
                    if (_this.bufferGapOnlyInVideoBuffer(curTime, periodStart)) {
                        checkGapEnd = true;
                        _this.logHandler.log('### stalled due to the buffer gap. force seeking to start time of period[' +
                            nextIdx +
                            '] ***');
                        _this.NXDebug.debug('### stalled due to the buffer gap. force seeking to start time of period[' +
                            nextIdx +
                            '] ***');
                        _this.eventBus.dispatchEvent({
                            type: 'periodEnded',
                            data: nextIdx - 1,
                        });
                        if (Math.abs(_this.videoModel.getCurrentTime() - curTime) < 0.5) {
                            _this.seekToNearestStartTime(periodStart);
                        }
                        else {
                            // eslint-disable-line no-empty
                        }
                    }
                }
            }
            else if (curTime < periodStart &&
                curTime > periodStart + _this.EPSILON - 0.5) {
                checkGapEnd = true;
                _this.eventBus.dispatchEvent({
                    type: 'periodEnded',
                    data: nextIdx - 1,
                });
                if (Math.abs(_this.videoModel.getCurrentTime() - curTime) < 0.5) {
                    if (_this.bufferGapBetweenPeriods(curTime, periodStart)) {
                        _this.logHandler.log('*** stalled due to the buffer gap. force seeking to start time of period[' +
                            nextIdx +
                            '] ***' +
                            curTime);
                        _this.NXDebug.debug('*** stalled due to the buffer gap. force seeking to start time of period[' +
                            nextIdx +
                            '] ***');
                        _this.seekToNearestStartTime(periodStart);
                    }
                    else {
                        // eslint-disable-line no-empty
                    }
                }
                else {
                    // eslint-disable-line no-empty
                }
            }
            if (!_this.nextPeriodTopIsAlreadyBuffered &&
                periodStart - 4 < curTime &&
                curTime < periodStart - _this.CHECK_GAP_INTERVAL) {
                var prepared = _this.checkNextPeriodTop(periodStart);
                _this.eventBus.dispatchEvent({
                    type: 'PeriodChangeCheck',
                    data: {
                        periodIdx: nextIdx - 1,
                        timeToEnd: periodStart - curTime,
                        prepared: prepared,
                    },
                });
            }
            if (curTime >= periodStart) {
                checkGapEnd = true;
            }
            if (checkGapEnd) {
                clearInterval(_this.checkGapTimerId);
                _this.checkGapTimerId = null;
                _this.lastCheckGapTime = -1;
                _this.nextPeriodTopIsAlreadyBuffered = false;
            }
        };
        this.dispatchCheckGap = function (curTime) {
            var q = null;
            var i = 0;
            for (i = _this.checkGapQue.length - 1; 0 <= i; i--) {
                if (_this.checkGapQue[i].nextStart < curTime) {
                    _this.checkGapQue.splice(i, 1);
                }
                else if (_this.checkGapQue[i].curStart < curTime &&
                    curTime < _this.checkGapQue[i].nextStart &&
                    _this.checkGapQue[i].nextStart - 2 < curTime) {
                    q = _this.checkGapQue.shift();
                    break;
                }
            }
            if (q != null) {
                if (_this.checkGapTimerId)
                    clearInterval(_this.checkGapTimerId);
                _this.checkGapTimerId = setInterval(_this.checkGap.bind(_this, q.nextIdx, q.nextStart), _this.CHECK_GAP_INTERVAL * 1000);
            }
        };
        this.onCanPlayThrough = function () {
            _this.videoModel.unlisten('canplaythrough', _this.canplaythroughListener);
        };
        this.onLoad = function () {
            _this.NXDebug.log('Got loadmetadata event.');
            if (_this.contentProtections === null) {
                _this.setAppendStatus(true, 0);
                _this.setInitialSeekTime.call(_this, function (_val) { });
            }
            _this.eventBus.dispatchEvent({
                type: 'GOT_LOADED_METADATA',
                data: {},
            });
        };
        this.onPlay = function () {
            _this.updateCurrentTime.call(_this);
        };
        this.onPause = function () {
            _this.suspend.call(_this);
            _this.scheduleWhilePaused = true;
            _this.ltimeupdate = NaN;
        };
        this.onStalled = function () { };
        this.onError = function (event) {
            var error = event.srcElement.error;
            var code = error.code;
            var msg = '';
            if (code === -1) {
                // not an error!
                return;
            }
            switch (code) {
                case 1:
                    msg = 'MEDIA_ERR_ABORTED';
                    break;
                case 2:
                    msg = 'MEDIA_ERR_NETWORK';
                    break;
                case 3:
                    msg = 'MEDIA_ERR_DECODE';
                    break;
                case 4:
                    msg = 'MEDIA_ERR_SRC_NOT_SUPPORTED';
                    break;
                case 5:
                    msg = 'MEDIA_ERR_ENCRYPTED';
                    break;
            }
            _this.errored = true;
            _this.NXDebug.log('Video Element Error: ' + msg);
            _this.NXDebug.log(error);
            _this.errHandler.mediaSourceError(_this.eventBus, msg);
            _this.logHandler.log('##### STREAM Video Element Error: ' + msg);
            _this.reset();
        };
        this.setAppendStatus = function (value, quality) {
            var controllers = [
                _this.videoController,
                _this.audioController,
            ];
            var qty = quality || -1;
            controllers.forEach(function (c) {
                if (c != null && c.getBuffer().appendStart !== value) {
                    c.getBuffer().appendStart = value;
                    c.getBuffer().quality = qty;
                    c.appendFromQ();
                }
            });
        };
        this.setInitData = function (vInitData, aInitData) {
            var buffer;
            if (_this.videoController != null && vInitData != null) {
                buffer = _this.videoController.getBuffer();
                if (buffer.updating === undefined) {
                    buffer.append(vInitData);
                }
                else {
                    buffer.appendBuffer(vInitData);
                }
            }
            if (_this.audioController != null && aInitData != null) {
                buffer = _this.audioController.getBuffer();
                if (buffer.updating === undefined) {
                    buffer.append(aInitData);
                }
                else {
                    buffer.appendBuffer(aInitData);
                }
            }
            else {
                /*
                  setAppendStatus(true,0);
                  setInitialSeekTime.call(this,function(){
                  });
                */
            }
        };
        this.setDummy = function () {
            if (_this.videoController != null) {
                _this.videoController.setDummy();
            }
            if (_this.audioController != null) {
                _this.audioController.setDummy();
            }
        };
        //NSV-a const setStalledState = () => {
        //NSV-a   if (videoController != null) {
        //NSV-a     videoController.setStalledState(true);
        //NSV-a   }
        //NSV-a   if (audioController != null) {
        //NSV-a     audioController.setStalledState(true);
        //NSV-a   }
        //NSV-a };
        /* istanbul ignore next */
        this._seeking = function () {
            var self = _this;
            var changePeriod = false;
            var time = _this.videoModel.getCurrentTime();
            _this.ltimeupdate = NaN;
            _this.NXDebug.debug(' ### onSeeking : ' + time);
            _this.logHandler.log(' ### onSeeking : ' + time);
            if (_this.seeking == true) {
                return;
            }
            _this.seeking = true;
            if (_this.lastSeekTime == time) {
                // eslint-disable-line no-empty
            }
            if (_this.checkGapTimerId) {
                clearInterval(_this.checkGapTimerId);
                _this.checkGapTimerId = null;
            }
            if (_this.eventTimerList.length > 0) {
                _this.eventTimerList.forEach(function (e) {
                    clearTimeout(e);
                    e = null;
                });
                _this.eventTimerList = [];
            }
            if (_this.videoModel.onAdjusting()) {
                _this.eventBus.dispatchEvent({
                    type: 'ADJUST_CURRENTTIME_END',
                    data: {
                        ctime: time,
                    },
                });
                //startBuffering.call(self,time,time,'2');
                _this.seeking = false;
                return;
            }
            if (_this.videoController != null) {
                _this.videoController.cancelPendingRequests('video');
                _this.videoController.abortOnGoingRequests();
            }
            if (_this.audioController != null) {
                _this.audioController.cancelPendingRequests('audio');
                _this.audioController.abortOnGoingRequests();
            }
            for (var i = _this.periodInfoArray.length - 1; i >= 0; i--) {
                if (_this.periodInfoArray[i].start <= time) {
                    if (_this.periodInfo.start !== _this.periodInfoArray[i].start) {
                        _this.currentPeriodIdx = i;
                        _this.updateDataInfo(_this.updateDataReason.PERIOD_CHANGE, _this.periodInfoArray[i], time, function (_d) {
                            if (_this.videoController != null) {
                                _this.videoController.getSegmentStartTime(time, function (videoStartTime) {
                                    if (_this.audioController != null) {
                                        _this.audioController.getSegmentStartTime(videoStartTime, function (time) {
                                            //startBuffering.call(self,videoStartTime,videoStartTime,'3');
                                            _this.startBuffering.call(self, videoStartTime, time, '3');
                                        });
                                    }
                                    else {
                                        _this.startBuffering(videoStartTime, videoStartTime, '4');
                                    }
                                });
                            }
                            else {
                                _this.startBuffering.call(self, time, time, '5');
                            }
                        });
                        changePeriod = true;
                    }
                    break;
                }
            }
            if (!changePeriod) {
                if (_this.videoController != null) {
                    _this.videoController.getSegmentStartTime(time, function (videoStartTime) {
                        if (_this.audioController != null) {
                            _this.audioController.getSegmentStartTime(videoStartTime, function (_time) {
                                _this.NXDebug.debug('=====StartBuffering======');
                                _this.startBuffering(videoStartTime, videoStartTime, '6');
                            });
                        }
                        else {
                            _this.startBuffering(videoStartTime, videoStartTime, '7');
                        }
                    });
                }
                else {
                    _this.startBuffering(time, time, '8');
                }
            }
            _this.lastSeekTime = NaN;
        };
        this.onSeeking = function () {
            if (_this.seeking) {
                _this.seekWaiting = true;
            }
            else {
                _this._seeking.call(_this);
            }
        };
        this.onSeekInhibition = function () {
            _this.videoModel.unlisten('seeking', _this.seekingListener);
        };
        this.onReleaseSeekInhibition = function () {
            _this.videoModel.listen('seeking', _this.seekingListener);
        };
        this.onPlaybackStarted = function () {
            _this.sourceBufferExt.playbackStart();
        };
        this.onSeeked = function () {
            _this.videoModel.listen('seeking', _this.seekingListener);
            _this.videoModel.unlisten('seeked', _this.seekedListener);
        };
        //NSV-a const onProgress = function () {
        //NSV-a   updateBuffer.call(this);
        //NSV-a };
        this.onUpdateDataEnd = function (evt) {
            var q = null;
            while (_this.updateQue.length > 0) {
                q = _this.updateQue.shift();
                if (q.reason == _this.updateDataReason.PERIOD_CHANGE &&
                    q.reason == evt.data.reason &&
                    q.time == evt.data.time) {
                    q = null;
                }
                else {
                    break;
                }
            }
            if (q != null) {
                _this.updateDataInfo.call(_this, q.reason, q.period, q.time, q.callback);
            }
        };
        /* istanbul ignore next */
        this.dispatchDashEvent = function () {
            var self = _this;
            var c = _this.videoModel.getCurrentTime();
            var _checkEvent = function (list) {
                var i = 0;
                var length = list.length;
                var dispatchList = [];
                for (i = 0; i < length; i++) {
                    var de = list[i];
                    if (!isNaN(_this.ltimeupdate) &&
                        c <= de.presentationTime &&
                        de.presentationTime < c + (c - _this.ltimeupdate)) {
                        var d = {
                            index: i,
                            de: de,
                            timerId: null,
                            delta: (de.presentationTime - c) * 1000,
                        };
                        dispatchList.push(d);
                        /*
                        this.eventBus.dispatchEvent({
                          type: de.schemeIdUri!,
                          data: {
                            eventList: list,
                            index: i,
                            event: de,
                          },
                        });
                        */
                    }
                }
                dispatchList.forEach(function (d) {
                    d.timerId = setTimeout(function () {
                        self.eventBus.dispatchEvent({
                            type: d.de.schemeIdUri,
                            data: {
                                eventList: list,
                                index: d.index,
                                event: d.de,
                            },
                        });
                        if (self.deletePastDashEvent) {
                            list.splice(list.indexOf(d.de), 1);
                        }
                        self.eventTimerList.splice(self.eventTimerList.indexOf(d.timerId), 1);
                    }, d.delta);
                    self.eventTimerList.push(d.timerId);
                });
            };
            for (var s in _this.periodInfo.inEventList) {
                _checkEvent(_this.periodInfo.inEventList[s]);
            }
            for (var s in _this.periodInfo.outEventList) {
                _checkEvent(_this.periodInfo.outEventList[s]);
            }
            _this.ltimeupdate = c;
        };
        /* istanbul ignore next */
        this.onTimeupdate = function () {
            var self = _this;
            var allRanges;
            var curTime = _this.videoModel.getCurrentTime();
            _this.updateBuffer.call(_this);
            _this.dispatchDashEvent.call(_this);
            _this.dispatchCheckGap.call(_this, curTime);
            if (!isNaN(_this.presentationEndTime) &&
                curTime > _this.presentationEndTime) {
                _this.videoModel.pause();
                return;
            }
            if (curTime > _this.videoModel.getDuration() - 4 &&
                //liveMulti
                _this.mediaSource &&
                _this.mediaSource.readyState === 'open' &&
                !_this.manifestModel.getIsDynamic(_this.manifest)) {
                //liveMulti
                var ranges = _this.videoModel.getBuffered();
                if (ranges.start(ranges.length - 1) <= curTime &&
                    ranges.end(ranges.length - 1) > _this.videoModel.getDuration() - 0.5) {
                    if (_this.videoController != null) {
                        allRanges = _this.sourceBufferExt.getAllRanges(_this.videoController.getBuffer());
                        if (allRanges) {
                            if (allRanges.length > 0) {
                                for (var i = 0, len = allRanges.length; i < len; i += 1) {
                                    _this.NXDebug.debug('[video] Buffered Range[' +
                                        i +
                                        ']: ' +
                                        allRanges.start(i) +
                                        ' - ' +
                                        allRanges.end(i));
                                }
                            }
                        }
                    }
                    if (_this.audioController != null) {
                        allRanges = _this.sourceBufferExt.getAllRanges(_this.audioController.getBuffer());
                        if (allRanges) {
                            if (allRanges.length > 0) {
                                for (var i = 0, len = allRanges.length; i < len; i += 1) {
                                    _this.NXDebug.debug('[audio] Buffered Range[' +
                                        i +
                                        ']: ' +
                                        allRanges.start(i) +
                                        ' - ' +
                                        allRanges.end(i));
                                }
                            }
                        }
                    }
                    _this.logHandler.log('********** onTimeupdate: signalEndOfStream ************');
                    _this.signalEndOfStream.call(_this, _this.mediaSource);
                    if (_this.videoController != null) {
                        _this.videoController.clearTimer();
                    }
                    if (_this.audioController != null) {
                        _this.audioController.clearTimer();
                    }
                }
            }
            var checkPeriodIdx = _this.currentPeriodIdx;
            if (_this.periodChgCheck &&
                !_this.dataIsUpdating &&
                _this.currentPeriodIdx < _this.periodInfoArray.length - 1 &&
                curTime + 7 >= _this.periodInfoArray[_this.currentPeriodIdx].end) {
                _this.periodChgCheck = false;
                var results = [];
                results.push(_this.videoController.getIsStreamCompleted() ||
                    _this.alreadyBufferedAllSegments(_this.videoController, curTime, _this.periodInfoArray[_this.currentPeriodIdx].end - 0.4));
                results.push(_this.audioController.getIsStreamCompleted() ||
                    _this.alreadyBufferedAllSegments(_this.audioController, curTime, _this.periodInfoArray[_this.currentPeriodIdx].end - 0.4));
                if (results[0] &&
                    results[1] &&
                    checkPeriodIdx === _this.currentPeriodIdx) {
                    if (_this.currentPeriodIdx < _this.periodInfoArray.length - 1) {
                        _this.currentPeriodIdx++;
                        _this.logHandler.log('*** appended all segments in this period. start fetching period[' +
                            _this.currentPeriodIdx +
                            '] *** : ' +
                            checkPeriodIdx);
                        _this.updateDataInfo(_this.updateDataReason.PERIOD_CHANGE, _this.periodInfoArray[_this.currentPeriodIdx], _this.periodInfoArray[_this.currentPeriodIdx].start, function (d) {
                            _this.startBuffering.call(self, d.data, d.data, '9');
                            /*
                            if (this.checkGapTimerId) {
                              //clearInterval(this.checkGapTimerId);
                              //this.checkGapTimerId = null;
                            } else {
                              const nextStart =
                                this.periodInfoArray![this.currentPeriodIdx].start;
                              this.checkGapTimerId = setInterval(
                                this.checkGap.bind(this, this.currentPeriodIdx, nextStart),
                                this.CHECK_GAP_INTERVAL * 1000
                              );
                            }
                            */
                        });
                    }
                    else {
                        // eslint-disable-line no-empty
                    }
                }
                else if (checkPeriodIdx !== _this.currentPeriodIdx) {
                    _this.logHandler.log('### currentPeriodIdx: ' +
                        _this.currentPeriodIdx +
                        ', checkPeriodIdx: ' +
                        checkPeriodIdx);
                }
                _this.periodChgCheck = true;
            }
        };
        this.bufferGapBetweenPeriods = function (curTime, targetTime) {
            var vgap = _this.checkBufferGap(_this.videoController, curTime, targetTime);
            var agap = _this.checkBufferGap(_this.audioController, curTime, targetTime);
            if (vgap == true || agap == true) {
                return true;
            }
            else {
                return false;
            }
        };
        this.checkBufferGap = function (bfController, curTime, targetTime) {
            var range;
            if (bfController != null) {
                var toler = bfController.getTolerance();
                range = _this.sourceBufferExt.getBufferRange(bfController.getBuffer(), targetTime - toler, toler);
                if (range != null &&
                    range.start <= curTime &&
                    targetTime + 0.1 <= range.end) {
                    return false;
                }
                else {
                    return true;
                }
            }
            else {
                return false;
            }
        };
        this.alreadyBufferedAllSegments = function (bfController, curTime, endTime) {
            var range;
            if (bfController != null) {
                range = _this.sourceBufferExt.getBufferRange(bfController.getBuffer(), curTime, bfController.getTolerance());
                if (range != null && range.end >= endTime) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        };
        this.bufferGapOnlyInVideoBuffer = function (curTime, endTime) {
            var vrange = null;
            var arange = null;
            if (_this.videoController != null) {
                vrange = _this.sourceBufferExt.getBufferRange(_this.videoController.getBuffer(), curTime, _this.videoController.getTolerance());
                if (vrange != null && vrange.end < endTime) {
                    if (_this.audioController != null) {
                        arange = _this.sourceBufferExt.getBufferRange(_this.audioController.getBuffer(), curTime, _this.audioController.getTolerance());
                        if (arange != null && arange.end >= endTime) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        return true;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        };
        this.checkNextPeriodTop = function (temporalStartTime) {
            var range = _this.sourceBufferExt.getBufferRange(_this.videoController.getBuffer(), temporalStartTime + 1.5, _this.videoController.getTolerance());
            if (range != null) {
                if (_this.audioController != null) {
                    range = _this.sourceBufferExt.getBufferRange(_this.audioController.getBuffer(), temporalStartTime + 1.5, _this.audioController.getTolerance());
                    return range != null ? true : false;
                }
                else {
                    return true;
                }
            }
            return false;
        };
        this.seekToNearestStartTime = function (temporalStartTime) {
            var startTime = 0;
            var range = _this.sourceBufferExt.getBufferRange(_this.videoController.getBuffer(), temporalStartTime + 0.5, _this.videoController.getTolerance());
            if (range != null) {
                if (range.start < temporalStartTime) {
                    startTime = temporalStartTime;
                }
                else {
                    startTime = range.start;
                }
                if (_this.audioController != null) {
                    range = _this.sourceBufferExt.getBufferRange(_this.audioController.getBuffer(), temporalStartTime + 0.5, _this.audioController.getTolerance());
                    if (startTime < range.start) {
                        startTime = range.start;
                    }
                }
                _this.logHandler.log('ST:' + startTime);
                _this.videoModel.silentSeek(startTime);
            }
            else {
                _this.logHandler.log('?????');
                startTime = temporalStartTime;
                _this.videoModel.setCurrentTime(startTime + 0.2);
            }
        };
        //NSV-a const searchNearestStartTime = (temporalStartTime) => {
        //NSV-a   let startTime = 0;
        //NSV-a   let range = null;
        //NSV-a
        //NSV-a   range = sourceBufferExt.getBufferRange(
        //NSV-a     videoController.getBuffer(),
        //NSV-a     temporalStartTime + 0.5,
        //NSV-a     videoController.getTolerance()
        //NSV-a   );
        //NSV-a   if (range != null) {
        //NSV-a     if (range.start < temporalStartTime) {
        //NSV-a       startTime = temporalStartTime + 0.2;
        //NSV-a     } else {
        //NSV-a       startTime = range.start;
        //NSV-a     }
        //NSV-a     if (audioController != null) {
        //NSV-a       range = sourceBufferExt.getBufferRange(
        //NSV-a         audioController.getBuffer(),
        //NSV-a         temporalStartTime + 0.5,
        //NSV-a         audioController.getTolerance()
        //NSV-a       );
        //NSV-a       if (startTime < range.start) {
        //NSV-a         startTime = range.start;
        //NSV-a       }
        //NSV-a     }
        //NSV-a     logHandler.log('ST:' + startTime);
        //NSV-a   } else {
        //NSV-a     logHandler.log('?????');
        //NSV-a     startTime = temporalStartTime;
        //NSV-a   }
        //NSV-a
        //NSV-a   return startTime;
        //NSV-a };
        /* istanbul ignore next */
        this.onRatechange = function () {
            /*
              if (videoController) {
                  videoController.updateStalledState();
              }
              if (audioController) {
                  audioController.updateStalledState();
              }
            */
        };
        this.updateBuffer = function () {
            if (_this.videoController) {
                _this.videoController.updateBufferState();
            }
            if (_this.audioController) {
                _this.audioController.updateBufferState();
            }
        };
        this.startBuffering = function (vtime, atime, msg) {
            if (_this.videoController) {
                if (vtime === undefined) {
                    _this.videoController.start('33333');
                }
                else {
                    if (!_this.seekWaiting) {
                        _this.videoController.seek(vtime, '{' + msg + '} [video] seek');
                    }
                    else {
                        // eslint-disable-line no-empty
                    }
                }
            }
            if (_this.audioController) {
                if (atime === undefined) {
                    _this.audioController.start('44444');
                }
                else {
                    if (!_this.seekWaiting) {
                        _this.audioController.seek(atime, '{' + msg + '}[audio] seek');
                    }
                }
            }
            _this.seeking = false;
            if (_this.seekWaiting) {
                _this.seekWaiting = false;
                _this._seeking.call(_this);
            }
        };
        this.stopBuffering = function () {
            if (_this.videoController) {
                _this.videoController.stop();
            }
            if (_this.audioController) {
                _this.audioController.stop();
            }
        };
        this.suspend = function () {
            if (!_this.scheduleWhilePaused ||
                _this.manifestModel.getIsDynamic(_this.manifest)) {
                _this.stopBuffering.call(_this);
            }
        };
        this.updateCurrentTime = function () {
            if (_this.videoModel.isPaused())
                return;
            if (_this.dataIsUpdating)
                return;
            _this.startBuffering();
        };
        /* istanbul ignore next */
        this.doLoad = function (manifestResult) {
            var self = _this;
            var initialize = function () {
                _this.eventBus.removeEventListener('MEDIASOURCE_IS_SET', initialize);
                _this.setDuration.call(self);
                _this.initializeMediaSource.call(self, function (result) {
                    if (result) {
                        _this.NXDebug.log('Playback initialized!');
                        _this.initialized = true;
                        _this.NXDebug.log('element loaded!');
                        _this.eventBus.dispatchEvent({
                            type: 'PLAYBACK_INITIALIZED',
                            data: {},
                        });
                    }
                });
            };
            _this.manifest = manifestResult;
            _this.videoModel.setAutoPlay(_this.autoPlay);
            if (_this.mediaSource != null) {
                initialize();
            }
            else {
                _this.eventBus.addEventListener('MEDIASOURCE_IS_SET', initialize);
            }
        };
        /* istanbul ignore next */
        this.tempLoad = function (manifestResult) {
            var self = _this;
            var initialize = function () {
                _this.tempInitializeMediaSource.call(self, function (result) {
                    if (result) {
                        _this.NXDebug.log('Playback initialized!');
                        _this.initialized = true;
                        _this.NXDebug.log('element loaded!');
                        _this.eventBus.dispatchEvent({
                            type: 'PLAYBACK_INITIALIZED',
                            data: {},
                        });
                    }
                });
            };
            _this.manifest = manifestResult;
            _this.videoModel.setAutoPlay(_this.autoPlay);
            initialize();
        };
        this.currentTimeChanged = function () {
            _this.NXDebug.log('Current time has changed, block programmatic seek.');
            _this.videoModel.unlisten('seeking', _this.seekingListener);
            _this.videoModel.listen('seeked', _this.seekedListener);
        };
        this.bufferingCompleted = function (_evt) {
            // if there is at least one buffer controller that has not completed buffering yet do nothing
            if ((_this.videoController && !_this.videoController.isBufferingCompleted) ||
                (_this.audioController && !_this.audioController.isBufferingCompleted)) {
                return;
            }
            // buffering has been complted, now we can signal end of stream
            if (_this.mediaSource) {
                _this.logHandler.log(' *** bufferingCompleted ***');
            }
        };
        this.segmentLoadingFailed = function () {
            _this.stopBuffering.call(_this);
        };
        /* istanbul ignore next */
        this.processProtection = function (type, initDataArray, idx) {
            var self = _this;
            var buffer = null;
            var listener;
            var processProtectionHandler = function () {
                _this.eventBus.removeEventListener('ON_KEY_ADDED', listener);
                if (idx === 1) {
                    if (type === 'video' && _this.audioInitData.length !== 0) {
                        _this.processProtection.call(self, 'audio', _this.audioInitData, 0);
                    }
                    else {
                        _this.NXDebug.debug('process protection end!!!');
                        _this.setAppendStatus(true, 0);
                        _this.setInitialSeekTime.call(_this, function (_val) {
                            //   setAppendStatus(true, 0);
                        });
                    }
                }
                else {
                    buffer =
                        type === 'video'
                            ? _this.videoController.getBuffer()
                            : _this.audioController.getBuffer();
                    if (buffer.updating === undefined) {
                        buffer.append(initDataArray[idx].data);
                    }
                    else {
                        buffer.appendBuffer(initDataArray[idx].data);
                    }
                    _this.drmKeyProcessing = true;
                    _this.drmKeyProcessingTimerId = setTimeout(function () {
                        if (_this.drmKeyProcessing) {
                            _this.drmKeyProcessing = false;
                            _this.eventBus.dispatchEvent({
                                type: 'ON_KEY_ADDED',
                                data: {},
                            });
                        }
                        _this.drmKeyProcessingTimerId = null;
                    }, 1000);
                    _this.processProtection.call(self, type, initDataArray, idx + 1);
                }
            };
            if (_this.drmKeyProcessing) {
                listener = processProtectionHandler.bind(self);
                _this.eventBus.addEventListener('ON_KEY_ADDED', listener);
            }
            else {
                processProtectionHandler();
            }
        };
        this.setInitialSeekTime = function (callback) {
            if (_this.videoModel.getCurrentTime() === 0) {
                var initialSeekTime = _this.videoModel.getStartTime();
                var target = initialSeekTime;
                _this.NXDebug.log('Starting playback at offset: ' +
                    initialSeekTime +
                    ', adjusted:' +
                    target);
                _this.logHandler.log('Starting playback at offset: ' +
                    initialSeekTime +
                    ', adjusted:' +
                    target);
                if (target > 0.5) {
                    _this.videoModel.silentSeek(target, function () {
                        callback(true);
                    });
                }
                else {
                    callback(true);
                }
            }
        };
        /* istanbul ignore next */
        this.streamIsCompleted = function (e) {
            var self = _this;
            _this.NXDebug.debug('[' + e.data.type + '] Stream is completed.----');
            var completed = false;
            var curTime = _this.videoModel.getCurrentTime();
            if (e.data.type === 'video') {
                if (_this.audioController) {
                    if (_this.audioController.getIsStreamCompleted() ||
                        _this.alreadyBufferedAllSegments(_this.audioController, curTime, e.data.pEnd - 0.2)) {
                        completed = true;
                    }
                }
                else {
                    completed = true;
                }
            }
            else {
                if (_this.videoController) {
                    if (_this.videoController.getIsStreamCompleted() ||
                        _this.alreadyBufferedAllSegments(_this.videoController, curTime, e.data.pEnd - 0.2)) {
                        completed = true;
                    }
                }
                else {
                    completed = true;
                }
            }
            if (completed) {
                for (var ii = 0; ii < _this.periodInfoArray.length; ii++) {
                    if (_this.periodInfoArray[ii].start == e.data.pStart) {
                        if (ii < _this.periodInfoArray.length) {
                            _this.currentPeriodIdx = ii + 1;
                        }
                        else {
                            _this.currentPeriodIdx = ii;
                        }
                        break;
                    }
                }
                if (e.data.pStart < _this.periodInfoArray[0].start) {
                    _this.currentPeriodIdx = 0;
                }
                if (_this.periodInfoArray.length > _this.currentPeriodIdx) {
                    if (_this.periodInfoArray[_this.currentPeriodIdx].start ==
                        _this.periodInfo.start)
                        return;
                    for (var i = 0; i < _this.updateQue.length; i++) {
                        if (_this.updateQue[i].reason == _this.updateDataReason.PERIOD_CHANGE &&
                            _this.updateQue[i].time ==
                                _this.periodInfoArray[_this.currentPeriodIdx].start)
                            return;
                    }
                    _this.logHandler.log('*** -appended all segments in this period. start fetching period[' +
                        _this.currentPeriodIdx +
                        ']  p:' +
                        e.data.pStart +
                        ', n:' +
                        _this.periodInfoArray[_this.currentPeriodIdx].start +
                        ' ***');
                    _this.NXDebug.info('*** -appended all segments in this period. start fetching period[' +
                        _this.currentPeriodIdx +
                        '] p:' +
                        e.data.pStart +
                        ', n:' +
                        _this.periodInfoArray[_this.currentPeriodIdx].start +
                        ' ***');
                    var nextStart_1 = _this.periodInfoArray[_this.currentPeriodIdx].start;
                    _this.updateDataInfo(_this.updateDataReason.PERIOD_CHANGE, _this.periodInfoArray[_this.currentPeriodIdx], _this.periodInfoArray[_this.currentPeriodIdx].start, function (d) {
                        _this.startBuffering.call(self, d.data, d.data, '10');
                        _this.checkGapQue.push({
                            curStart: e.data.pStart,
                            nextIdx: _this.currentPeriodIdx,
                            nextStart: nextStart_1,
                        });
                    });
                }
                else if (_this.mediaSource && _this.mediaSource.readyState === 'open') {
                    // eslint-disable-line no-empty
                }
            }
            else {
                // eslint-disable-line no-empty
            }
        };
        /* istanbul ignore next */
        this.initDataReceived = function (e) {
            if (_this.videoModel.getCurrentTime() !== 0) {
                return;
            }
            if (e.data.type === 'video') {
                _this.videoInitReceived = true;
                _this.videoInitData = e.data.initData;
            }
            else if (e.data.type === 'audio') {
                _this.audioInitReceived = true;
                _this.audioInitData = e.data.initData;
            }
            if (_this.videoInitReceived && _this.audioInitReceived) {
                var setup_1 = function () {
                    _this.eventBus.removeEventListener('MEDIASOURCE_UPDATED', setup_1);
                    _this.setDummy();
                    var vInitData = _this.videoInitData != null ? _this.videoInitData[0].data : null;
                    var aInitData = _this.audioInitData != null ? _this.audioInitData[0].data : null;
                    if (_this.contentProtections === null) {
                        _this.setInitData(vInitData, aInitData);
                    }
                    else if (_this.protectionController.supportsMediaKeys() ||
                        _this.protectionController.supportsEME01b()) {
                        var _onKeyAdded_1 = function () {
                            _this.eventBus.removeEventListener('ON_KEY_ADDED', _onKeyAdded_1);
                            _this.setAppendStatus(true, 0);
                            _this.setInitialSeekTime.call(_this, function (_val) { });
                        };
                        _this.setInitData(vInitData, aInitData);
                        if (!_this.drmInitialized) {
                            _this.eventBus.addEventListener('ON_KEY_ADDED', _onKeyAdded_1);
                        }
                        else {
                            _this.setAppendStatus(true, 0);
                            _this.setInitialSeekTime.call(_this, function () { });
                        }
                    }
                    else {
                        _this.setInitData(vInitData, aInitData);
                    }
                };
                if (!_this.videoModel.isDummy()) {
                    setup_1();
                }
                else {
                    _this.eventBus.addEventListener('MEDIASOURCE_UPDATED', setup_1);
                }
            }
        };
        this.bufferStateChange = function (e) {
            var state;
            if (e.data.type == 'video') {
                if (_this.audioController != null)
                    state = Math.min(e.data.state, _this.audioController.getBufferState());
            }
            else {
                if (_this.videoController != null)
                    state = Math.min(e.data.state, _this.videoController.getBufferState());
            }
            if (_this.bufferState != state) {
                _this.bufferState = state;
                _this.eventBus.dispatchEvent({
                    type: 'BUFFER_STATE_CHANGE',
                    data: _this.bufferState,
                });
            }
        };
        this.clearInitTimer = function () {
            if (_this.drmKeyProcessingTimerId) {
                clearTimeout(_this.drmKeyProcessingTimerId);
                _this.drmKeyProcessingTimerId = null;
            }
        };
        this.onKeyAdded = function () {
            _this.drmKeyProcessing = false;
            _this.eventBus.dispatchEvent({
                type: 'ON_KEY_ADDED',
                data: {},
            });
            _this.NXDebug.debug('onKeyAdded!!!!!');
            _this.drmInitialized = true;
        };
        this.clearPreparedRequests = function () {
            if (_this.videoController != null) {
                _this.videoController.cancelPendingRequests('video');
                _this.videoController.clearAllSegments();
            }
            if (_this.audioController != null) {
                _this.audioController.cancelPendingRequests('audio');
                _this.audioController.clearAllSegments();
            }
        };
        this.getCurrentAdaptationIdxFor = function (type) {
            if (type === 'video' && _this.videoController) {
                var videoData = _this.videoController.getData();
                return videoData.index;
            }
            else if (type === 'audio' && _this.audioController) {
                var audioData = _this.audioController.getData();
                return audioData.index;
            }
            else {
                return -1;
            }
        };
        this.setAdaptationIdxFor = function (type, idx) {
            if (type === 'video' && _this.videoController) {
                _this.videoController.updateData(_this.updateDataReason.ADAPTATION_CHANGE, _this.periodInfo.getDataForIndex(idx), _this.periodInfo /*, pending */, 0);
            }
            else if (type === 'audio' && _this.audioController) {
                _this.audioController.updateData(_this.updateDataReason.ADAPTATION_CHANGE, _this.periodInfo.getDataForIndex(idx), _this.periodInfo /*, pending */, 0);
            }
        };
        this.setAdaptationRoleFor = function (type, value) {
            var roles = _this.periodInfo.getRolesFor(type);
            var idx = -1;
            for (var i = 0; i < roles.length; i++) {
                if (roles[i].role == value) {
                    idx = roles[i].index;
                    break;
                }
            }
            if (type === 'video' && _this.videoController && idx != -1) {
                _this.videoController.updateData(_this.updateDataReason.ADAPTATION_CHANGE, _this.periodInfo.getDataForIndex(idx), _this.periodInfo /*, pending */, 0);
            }
            else if (type === 'audio' && _this.audioController && idx != -1) {
                _this.audioController.updateData(_this.updateDataReason.ADAPTATION_CHANGE, _this.periodInfo.getDataForIndex(idx), _this.periodInfo /*, pending */, 0);
            }
        };
        /* istanbul ignore next*/
        this.updateDataInfo = function (reason, updatedPeriodInfo, time, callback) {
            var videoData;
            var audioData;
            var tmpData;
            var isClientServerTimeSyncCompletedForTC = false;
            var clientServerTimeShift = 0;
            var timestampOffsetFor32bitVE = 0;
            var inEventList = [];
            var liveEdgeFromRequest = 0;
            var dispatchUpdateDataEnd = function (reason, time) {
                _this.dataIsUpdating = false;
                _this.eventBus.dispatchEvent({
                    type: 'UPDATE_DATA_END',
                    data: {
                        reason: reason,
                        time: time,
                    },
                });
            };
            _this.dataIsUpdating = true;
            _this.manifest = _this.manifestModel.getValue();
            if (_this.manifestModel.getIsDynamic(_this.manifest) == false) {
                _this.periodInfo = null;
            }
            if (_this.periodInfo) {
                isClientServerTimeSyncCompletedForTC =
                    _this.periodInfo.isClientServerTimeSyncCompletedForTC;
                clientServerTimeShift = _this.periodInfo.clientServerTimeShift;
                timestampOffsetFor32bitVE = _this.periodInfo.timestampOffsetFor32bitVE;
                inEventList = _this.periodInfo.inEventList;
                liveEdgeFromRequest = _this.periodInfo.liveEdgeFromRequest;
                if (reason == _this.updateDataReason.MPD_UPDATE) {
                    updatedPeriodInfo.mpd.liveEdge = _this.periodInfo.mpd.liveEdge;
                    updatedPeriodInfo.mpd.liveEdgeS = _this.periodInfo.mpd.liveEdgeS;
                    updatedPeriodInfo.mpd.liveEdgeE = _this.periodInfo.mpd.liveEdgeE;
                    updatedPeriodInfo.mpd.liveEdgeC = _this.periodInfo.mpd.liveEdgeC;
                }
                _this.periodInfo = updatedPeriodInfo;
                _this.periodInfo.isClientServerTimeSyncCompletedForTC =
                    isClientServerTimeSyncCompletedForTC;
                _this.periodInfo.clientServerTimeShift = clientServerTimeShift;
                _this.periodInfo.timestampOffsetFor32bitVE = timestampOffsetFor32bitVE;
                _this.periodInfo.inEventList = inEventList;
                _this.periodInfo.liveEdgeFromRequest = liveEdgeFromRequest;
            }
            else {
                _this.periodInfo = updatedPeriodInfo;
            }
            _this.currentPeriodIdx = _this.periodInfo.index;
            _this.NXDebug.log('Manifest updated... set new data on buffers.' + time);
            var updateController = function (bfController, type, adaptation, callback) {
                callback = callback || (function (_d) { });
                if (_this.manifestModel.getIsDynamic(_this.manifest)) {
                    adaptation = bfController.getData();
                    if (adaptation != null &&
                        adaptation.period.start == _this.periodInfo.start) {
                        if (adaptation != null && (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(adaptation, 'id')) {
                            tmpData = _this.periodInfo.getDataForId(adaptation.id);
                        }
                        else {
                            tmpData = _this.periodInfo.getDataForIndex(adaptation.index);
                        }
                    }
                    else {
                        tmpData = _this.periodInfo.getPrimaryMediaData(type);
                    }
                }
                else {
                    tmpData = _this.periodInfo.getPrimaryMediaData(type);
                }
                if (!tmpData) {
                    callback({
                        status: 'fail',
                        msg: 'no ' + type + ' AdaptationSets??',
                    });
                    return;
                }
                if (type == 'video') {
                    _this.protectionController.createMediaKeysFromMPD(tmpData, null);
                }
                else {
                    _this.protectionController.createMediaKeysFromMPD(null, tmpData);
                }
                bfController.updateData(reason, tmpData, _this.periodInfo, time, function (f) {
                    callback(f);
                });
            };
            if (_this.videoController != null && _this.audioController != null) {
                updateController(_this.videoController, 'video', videoData, function (_f) {
                    updateController(_this.audioController, 'audio', audioData, function (f) {
                        callback(f);
                        dispatchUpdateDataEnd(reason, time);
                    });
                });
            }
            else if (_this.videoController != null) {
                updateController(_this.videoController, 'video', videoData, function (f) {
                    callback(f);
                    dispatchUpdateDataEnd(reason, time);
                });
            }
            else if (_this.audioController != null) {
                updateController(_this.audioController, 'audio', audioData, function (f) {
                    callback(f);
                    dispatchUpdateDataEnd(reason, time);
                });
            }
            else {
                callback({
                    status: 'ok',
                    data: time,
                });
                dispatchUpdateDataEnd(reason, time);
            }
        };
        this.signalEndOfStream = function (source) {
            source.endOfStream();
        };
        this.setup = function () {
            _this.eventBus.addEventListener('setCurrentTime', _this.currentTimeChanged.bind(_this));
            _this.eventBus.addEventListener('bufferingCompleted', _this.bufferingCompleted.bind(_this));
            _this.eventBus.addEventListener('segmentLoadingFailed', _this.segmentLoadingFailed.bind(_this));
            _this.eventBus.addEventListener('initDataReceived', _this.initDataReceived.bind(_this));
            _this.eventBus.addEventListener('streamIsCompleted', _this.streamIsCompleted.bind(_this));
            _this.eventBus.addEventListener('bufferStateChangeInt', _this.bufferStateChange.bind(_this));
            _this.eventBus.addEventListener('seekInhibition', _this.onSeekInhibition.bind(_this));
            _this.eventBus.addEventListener('releaseSeekInhibition', _this.onReleaseSeekInhibition.bind(_this));
            _this.eventBus.addEventListener('playbackStarted', _this.onPlaybackStarted.bind(_this));
            _this.eventBus.addEventListener('UPDATE_DATA_END', _this.onUpdateDataEnd.bind(_this));
            _this.fragmentController = new _FragmentController__WEBPACK_IMPORTED_MODULE_4__.FragmentController(_this.params, _this.eventBus, _this.metricsModel, (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(_this.xhrCustom, 'seg') ? _this.xhrCustom['seg'] : {});
            _this.playListener = _this.onPlay.bind(_this);
            _this.pauseListener = _this.onPause.bind(_this);
            _this.stalledListener = _this.onStalled.bind(_this);
            _this.errorListener = _this.onError.bind(_this);
            _this.seekingListener = _this.onSeeking.bind(_this);
            _this.seekedListener = _this.onSeeked.bind(_this);
            _this.ratechangeListener = _this.onRatechange.bind(_this);
            _this.timeupdateListener = _this.onTimeupdate.bind(_this);
            _this.loadedListener = _this.onLoad.bind(_this);
            _this.canplaythroughListener = _this.onCanPlayThrough.bind(_this);
        };
        this.load = function (manifest, periodInfoValue, periodInfoArrayValue) {
            _this.periodInfo = periodInfoValue;
            _this.periodInfoArray = periodInfoArrayValue;
            _this.currentPeriodIdx = _this.periodInfo.index;
            if (!_this.videoModel.isDummy()) {
                _this.doLoad.call(_this, manifest);
            }
            else {
                _this.tempLoad.call(_this, manifest);
            }
        };
        this.updatePlaybackCondition = function (manifest, _periodInfoValue, periodInfoArrayValue) {
            _this.periodInfoArray = periodInfoArrayValue;
            _this.manifest = manifest;
            if (_this.manifest.mpd.type === 'static') {
                try {
                    if (_this.manifest.mpd.mediaPresentationDuration != null &&
                        _this.manifest.mpd.mediaPresentationDuration !== Infinity) {
                        if (_this.mediaSource.duration <
                            _this.manifest.mpd.mediaPresentationDuration) {
                            _this.mediaSource.duration =
                                _this.manifest.mpd.mediaPresentationDuration;
                        }
                    }
                    else {
                        _this.mediaSource.duration =
                            _this.periodInfoArray[_this.periodInfoArray.length - 1].end;
                    }
                }
                catch (e) {
                    _this.logHandler.log('duration cannot be changed while buffer updating');
                }
                _this.NXDebug.log('Duration successfully set to: ' + _this.mediaSource.duration);
            }
        };
        this.setVideoModel = function (value) {
            _this.videoModel = value;
            _this.videoModel.listen('play', _this.playListener);
            _this.videoModel.listen('pause', _this.pauseListener);
            _this.videoModel.listen('stalled', _this.stalledListener);
            _this.videoModel.listen('error', _this.errorListener);
            _this.videoModel.listen('seeking', _this.seekingListener);
            _this.videoModel.listen('timeupdate', _this.timeupdateListener);
            //videoModel.listen("progress", progressListener);
            _this.videoModel.listen('ratechange', _this.ratechangeListener);
            _this.videoModel.listen('loadedmetadata', _this.loadedListener);
            _this.videoModel.listen('canplaythrough', _this.canplaythroughListener);
            _this.sourceBufferExt.setVideoModel(value);
        };
        this.initProtection = function () {
            if (!_this.videoModel.isDummy()) {
                _this.protectionController = new _protection_ProtectionController__WEBPACK_IMPORTED_MODULE_9__.ProtectionController(_this.params, _this.eventBus, (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(_this.xhrCustom, 'drm') ? _this.xhrCustom['drm'] : {});
                _this.protectionController.init(_this);
            }
        };
        this.getVideoModel = function () {
            return _this.videoModel;
        };
        this.getManifestModel = function () {
            return _this.manifestModel;
        };
        this.setAutoPlay = function (value) {
            _this.autoPlay = value;
        };
        this.getAutoPlay = function () {
            return _this.autoPlay;
        };
        this.reset = function () {
            _this.pause.call(_this, true);
            _this.videoModel.unlisten('play', _this.playListener);
            _this.videoModel.unlisten('pause', _this.pauseListener);
            _this.videoModel.unlisten('stalled', _this.stalledListener);
            _this.videoModel.unlisten('error', _this.errorListener);
            _this.videoModel.unlisten('seeking', _this.seekingListener);
            _this.videoModel.unlisten('timeupdate', _this.timeupdateListener);
            //videoModel.unlisten("progress", progressListener);
            _this.videoModel.unlisten('loadedmetadata', _this.loadedListener);
            _this.videoModel.unlisten('canplaythrough', _this.canplaythroughListener);
            _this.videoModel.reset();
            _this.fragmentController.reset();
            _this.fragmentController = null;
            _this.tearDownMediaSource.call(_this);
            _this.protectionController.reset();
            _this.drmKeyProcessing = false;
            _this.xhrCustom = {};
            _this.dataIsUpdating = false;
            _this.updateQue = [];
            _this.checkGapQue = [];
            _this.bufferState = 0;
        };
        this.setPresentationStartTime = function (value) {
            _this.initialPresentationStartTime = value;
        };
        this.setPresentationEndTime = function (value) {
            _this.presentationEndTime = value;
        };
        this.setMediaSource = function (value) {
            if (value != null) {
                _this.mediaSource = value;
                _this.sourceBufferExt.setMediaSource(value);
                _this.eventBus.dispatchEvent({
                    type: 'MEDIASOURCE_IS_SET',
                    data: value,
                });
            }
        };
        this.updateMediaSource = function () {
            var update = function () {
                _this.eventBus.removeEventListener('MEDIASOURCE_IS_SET', update);
                _this.setDuration(true);
                _this.updateSourceBuffer();
                _this.eventBus.dispatchEvent({
                    type: 'MEDIASOURCE_UPDATED',
                    data: {},
                });
            };
            _this.eventBus.addEventListener('MEDIASOURCE_IS_SET', update);
        };
        this.getBufferState = function () {
            return _this.bufferState;
        };
        this.getBufferFor = function (type) {
            if (type == 'video' && _this.videoController != null) {
                return _this.videoController.getBuffer();
            }
            else if (type == 'audio' && _this.audioController != null) {
                return _this.audioController.getBuffer();
            }
            else {
                return null;
            }
        };
        // getFetchingPeriodIdx = ():number => {
        //   return this.currentPeriodIdx;
        // };
        this.end = function () {
            _this.pause.call(_this, true);
            if (_this.mediaSource && _this.mediaSource.readyState === 'open') {
                _this.logHandler.log('********** stop: signalEndOfStream ************');
                _this.signalEndOfStream.call(_this, _this.mediaSource);
            }
        };
        this.updateData = function (reason, period, time, callback) {
            var self = _this;
            var uq;
            if (_this.dataIsUpdating) {
                if (_this.updateQue.length > 0) {
                    for (var i = _this.updateQue.length - 1; i >= 0; i--) {
                        uq = _this.updateQue[i];
                        if (uq.reason == _this.updateDataReason.PERIOD_CHANGE) {
                            _this.updateQue.pop();
                        }
                    }
                }
                _this.updateQue.push({
                    reason: reason,
                    period: period,
                    time: time,
                    callback: callback,
                });
            }
            else {
                _this.updateDataInfo.call(self, reason, period, time, callback);
            }
        };
        this.manifest = null;
        this.mediaSource = null;
        this.videoCodec = null;
        this.audioCodec = null;
        this.contentProtections = null;
        this.videoController = null;
        this.audioController = null;
        this.textController = null;
        this.autoPlay = true;
        this.periodChgCheck = true;
        this.initialized = false;
        this.errored = false;
        this.xhrCustom = xhrCustom || {};
        this.audioInitData = [];
        this.videoInitData = [];
        this.eventTimerList = [];
        this.audioInitReceived = false;
        this.videoInitReceived = false;
        this.drmInitialized = false;
        this.drmKeyProcessing = false;
        this.drmKeyProcessingTimerId = null;
        this.lastCheckGapTime = -1;
        //NSV-a lastUpdateTime = -1,
        this.checkGapTimerId = null;
        this.nextPeriodTopIsAlreadyBuffered = false;
        this.CHECK_GAP_INTERVAL = 0.2;
        this.updateDataReason = _StreamController__WEBPACK_IMPORTED_MODULE_7__.UpdateDataReason;
        this.dataIsUpdating = false;
        this.updateQue = [];
        this.checkGapQue = [];
        this.periodInfo = null;
        this.periodInfoArray = null;
        this.currentPeriodIdx = 0;
        this.initialPresentationStartTime = 0;
        this.presentationEndTime = NaN;
        this.ltimeupdate = 0;
        this.lastSeekTime = NaN;
        this.seeking = false;
        this.seekWaiting = false;
        this.scheduleWhilePaused = true;
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.sourceBufferExt = new _SourceBufferExtensions__WEBPACK_IMPORTED_MODULE_6__.SourceBufferExtensions(params, eventBus);
        this.indexHandler = new _manifest_DashHandler__WEBPACK_IMPORTED_MODULE_1__.DashHandler(params, eventBus, (0,_core_Utils__WEBPACK_IMPORTED_MODULE_8__.hasProperty)(xhrCustom, 'seg') ? xhrCustom['seg'] : {});
        this.videoModel = null;
        this.fragmentController = null;
        this.bufferState = 0;
        this.protectionController = null;
        this.EPSILON = -0.1;
        this.SKIP_PERIOD_BOUNDARY = params.SKIP_PERIOD_BOUNDARY || false;
        this.DEFAULT_ROLE_FOR_VIDEO = params.DEFAULT_ROLE_FOR_VIDEO || 'main';
        this.DEFAULT_ROLE_FOR_AUDIO = params.DEFAULT_ROLE_FOR_AUDIO || 'main';
        this.deletePastDashEvent = params.DELETE_PAST_DASHEVENT || false;
        this.eventBus = eventBus;
        this.manifestModel = manifestModel;
        this.params = params;
        this.metricsModel = metricsModel;
        this.abrController = abrController;
    }
    // getDuration() {
    //   return periodInfo.duration;
    // }
    // getStartTime() {
    //   return periodInfo.start;
    // }
    // getPeriodIndex() {
    //   return periodInfo.index;
    // }
    // getId() {
    //   return periodInfo.id;
    // }
    Stream.prototype.getPeriodInfo = function () {
        return this.periodInfo;
    };
    return Stream;
}());



/***/ }),

/***/ "./ts/dash/streaming/StreamController.ts":
/*!***********************************************!*\
  !*** ./ts/dash/streaming/StreamController.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamController": function() { return /* binding */ StreamController; },
/* harmony export */   "UpdateDataReason": function() { return /* binding */ UpdateDataReason; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/ErrorHandler */ "./ts/dash/core/ErrorHandler.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _manifest_ManifestModel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manifest/ManifestModel */ "./ts/dash/manifest/ManifestModel.ts");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stream */ "./ts/dash/streaming/Stream.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */





/**
 * StreamController
 *
 * @module StreamController（StreamControllerモジュール）
 */
/*
 * StreamController aggregates all streams defined as Period sections in the manifest file
 * and implements corresponding logic to switch between them.
 */
var UpdateDataReason = {
    INITIAL_UPDATE: 'initialize',
    PERIOD_CHANGE: 'period_change',
    ADAPTATION_CHANGE: 'adaptation_change',
    MPD_UPDATE: 'mpd_update',
};
/**
 * StreamController
 * @constructor
 */
var StreamController = /** @class */ (function () {
    function StreamController(params, _eventBus, metricsModel, abrController, _xhrCustom) {
        var _this = this;
        this.logHandler = _core_LogHandler__WEBPACK_IMPORTED_MODULE_2__["default"];
        this.errHandler = _core_ErrorHandler__WEBPACK_IMPORTED_MODULE_1__["default"];
        this.updateDataReason = UpdateDataReason;
        this.play = function (manual) {
            _this.activeStream.play(manual);
        };
        this.pause = function (manual) {
            _this.activeStream.pause(manual);
        };
        this.seek = function (time) {
            _this.activeStream.seek(time);
        };
        this.attachVideoEvents = function (videoModel) {
            videoModel.listen('pause', _this.pauseListener);
            videoModel.listen('play', _this.playListener);
        };
        this.detachVideoEvents = function (videoModel) {
            videoModel.unlisten('pause', _this.pauseListener);
            videoModel.unlisten('play', _this.playListener);
        };
        this.onPause = function () {
            if (!_this.videoModel.getSelfPaused()) {
                _this.manifestModel.manifestUpdateStop();
            }
        };
        this.onPlay = function () {
            _this.manifestModel.manifestUpdateStart();
        };
        this.composeStreams = function (_callback) {
            var self = _this;
            var manifest = _this.manifestModel.getValue();
            var callback = _callback || (function () { });
            var period;
            var t;
            if (!manifest) {
                callback({
                    status: 'ok',
                    data: false,
                });
                return;
            }
            var periods = manifest.mpd.periods;
            if (periods.length === 0) {
                callback({
                    status: 'error',
                    msg: 'There are no regular periods',
                });
                return;
            }
            var tt = _this.videoModel.getCurrentTime();
            if (_this.activeStream != null) {
                var cPeriod = _this.activeStream.getPeriodInfo();
                var ct = _this.videoModel.getCurrentTime();
                t = ct > cPeriod.start ? ct : cPeriod.start;
                tt = t;
                for (var ii = periods.length - 1; ii >= 0; ii--) {
                    if (periods[ii].start <= t) {
                        period = periods[ii];
                        break;
                    }
                }
                _this.activeStream.updatePlaybackCondition(manifest, period, periods);
            }
            /* istanbul ignore next */
            if (!_this.activeStream) {
                //liveMulti
                if (isNaN(_this.initialPresentationStartTime)) {
                    if (manifest.mpd.type == 'dynamic') {
                        if (_this.params.START_FROM_MPDTOP_FORLIVE == true) {
                            period = periods[0];
                        }
                        else {
                            var lperiod = periods[periods.length - 1];
                            if (lperiod.end == Infinity) {
                                period = lperiod;
                            }
                            else {
                                t = lperiod.end - manifest.mpd.suggestedPresentationDelay;
                                if (t < periods[0].start) {
                                    period = periods[0];
                                }
                                else {
                                    for (var ii = periods.length - 1; ii >= 0; ii--) {
                                        if (periods[ii].start <= t) {
                                            period = periods[ii];
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        _this.initialPresentationStartTime = 0;
                        period = periods[0];
                    }
                }
                else {
                    if (_this.initialPresentationStartTime < periods[0].start) {
                        _this.logHandler.log('Playback stat time is out of range.');
                        _this.initialPresentationStartTime = periods[0].start;
                        period = periods[0];
                    }
                    else {
                        for (var ii = periods.length - 1; ii >= 0; ii--) {
                            if (periods[ii].start <= _this.initialPresentationStartTime) {
                                period = periods[ii];
                                break;
                            }
                        }
                    }
                }
                //liveMulti
                if (!period) {
                    callback({
                        status: 'error',
                        msg: 'Playback stat time is out of range.',
                    });
                    return;
                }
                _this.activeStream = new _Stream__WEBPACK_IMPORTED_MODULE_4__.Stream(_this.params, _this.eventBus, _this.manifestModel, _this.metricsModel, _this.abrController, _this.xhrCustom);
                _this.activeStream.setup();
                _this.activeStream.setVideoModel(_this.videoModel);
                _this.activeStream.initProtection();
                _this.activeStream.setPresentationStartTime(_this.initialPresentationStartTime);
                _this.activeStream.setPresentationEndTime(_this.initialPresentationEndTime);
                _this.activeStream.setAutoPlay(_this.autoPlay);
                _this.activeStream.setMediaSource(_this.mediaSource);
                _this.activeStream.load(manifest, period, periods);
                _this.attachVideoEvents.call(self, _this.activeStream.getVideoModel());
                callback({
                    status: 'ok',
                    data: true,
                });
            }
            else {
                _this.activeStream.updateData(_this.updateDataReason.MPD_UPDATE, period, tt, function (f) {
                    //callback({status:"ok", data:true});
                    callback(f);
                });
            }
        };
        this.createMediaSource = function () {
            var hasWebKit = 'WebKitMediaSource' in window;
            var hasMediaSource = 'MediaSource' in window;
            if (hasMediaSource) {
                return new MediaSource();
            }
            else if (hasWebKit) {
                // @ts-ignore
                return new WebKitMediaSource();
            }
            return null;
        };
        this.attachMediaSource = function (source, videoModel) {
            videoModel.setSource(window.URL.createObjectURL(source));
        };
        this.detachMediaSource = function (videoModel) {
            // it seems that any value passed to the setSource is cast to a sting when setting element.src,
            // so we cannot use null or undefined to reset the element. Use empty string instead.
            videoModel.setSource(null);
            // @ts-ignore
            if (videoModel.getElement().setMediaKeys) {
                // @ts-ignore
                videoModel.getElement().setMediaKeys(null);
            }
        };
        this._setUpMediaSource = function (mediaSourceArg, _callback) {
            var callback = _callback || (function () { });
            var self = _this;
            var onMediaSourceOpen = function (e) {
                _this.NXDebug.debug('MediaSource is open!');
                _this.NXDebug.debug(String(e));
                mediaSourceArg.removeEventListener('sourceopen', onMediaSourceOpen);
                mediaSourceArg.removeEventListener('webkitsourceopen', onMediaSourceOpen);
                _this.logHandler.log('readyState :' + mediaSourceArg.readyState);
                callback(mediaSourceArg);
            };
            mediaSourceArg.addEventListener('sourceopen', onMediaSourceOpen, false);
            mediaSourceArg.addEventListener('webkitsourceopen', onMediaSourceOpen, false);
            _this.attachMediaSource.call(self, mediaSourceArg, _this.videoModel);
        };
        this.manifestHasUpdated = function () {
            var self = _this;
            _this.composeStreams.call(self, function (d) {
                if (d.status === 'ok') {
                    _this.NXDebug.debug('composeStreams ok');
                    _this.manifestModel.onManifestRefreshEnd.call(self);
                }
                else {
                    _this.NXDebug.debug('composeStreams fail');
                    if (_this.getIsDynamic()) {
                        _this.manifestModel.onManifestRefreshEnd.call(self);
                        _this.manifestModel.manifestUpdateStartPoll.call(self);
                    }
                    else {
                        _this.logHandler.log('ERROR:' + d.msg);
                        _this.errHandler.manifestError(_this.eventBus, d.msg, 'nostreamscomposed', _this.manifestModel.getValue());
                        self.reset();
                    }
                }
            });
        };
        this.getManifestModel = function () {
            return _this.activeStream.getManifestModel();
        };
        this.setAutoPlay = function (value) {
            _this.autoPlay = value;
        };
        // getAutoPlay = (): boolean => {
        //   return this.autoPlay;
        // };
        this.getIsDynamic = function () {
            var manifest = _this.manifestModel.getValue();
            if (manifest) {
                return manifest.mpd.type === 'dynamic';
            }
            else {
                return false;
            }
        };
        this.getPeriodInfo = function () {
            var manifest = _this.manifestModel.getValue();
            var periods = [];
            if (manifest) {
                periods = manifest.mpd.periods;
            }
            return periods;
        };
        this.getPeriodIdxForTime = function (time) {
            var periods = _this.manifestModel.getValue().mpd.periods;
            for (var i = 0; i < periods.length; i++) {
                if (time < periods[i].end) {
                    return i;
                }
            }
            return periods.length - 1;
        };
        this.getPeriodInfoForIdx = function (idx) {
            var periods = _this.manifestModel.getValue().mpd.periods;
            if (idx >= 0 && idx < periods.length) {
                return periods[idx];
            }
            else {
                return null;
            }
        };
        this.getBaseURLIdxFor = function (idx) {
            var periods = _this.manifestModel.getValue().mpd.periods;
            if (idx >= 0 && idx < periods.length) {
                return periods[idx].selectedBaseURLIdx;
            }
            else {
                return null;
            }
        };
        this.getMaxBaseURLIdxFor = function (idx) {
            var periods = _this.manifestModel.getValue().mpd.periods;
            if (idx >= 0 && idx < periods.length) {
                return periods[idx].BaseURL.length - 1;
            }
            else {
                return null;
            }
        };
        this.setBaseURLIdxFor = function (periodIdx, idx) {
            var periods = _this.manifestModel.getValue().mpd.periods;
            if (periodIdx >= 0 && periodIdx < periods.length) {
                if (idx >= 0 && idx < periods[periodIdx].BaseURL.length) {
                    periods[periodIdx].selectedBaseURLIdx = idx;
                    if (_this.activeStream != null) {
                        var cPeriod = _this.activeStream.getPeriodInfo();
                        if (cPeriod.index == periodIdx) {
                            _this.activeStream.clearPreparedRequests();
                        }
                    }
                }
            }
        };
        this.getCurrentAdaptationIdxFor = function (type) {
            return _this.activeStream.getCurrentAdaptationIdxFor(type);
        };
        this.setAdaptationIdxFor = function (type, idx) {
            _this.activeStream.setAdaptationIdxFor(type, idx);
        };
        this.setAdaptationRoleFor = function (type, value) {
            _this.activeStream.setAdaptationRoleFor(type, value);
        };
        this.setCueingPeriodIdx = function (value) {
            if (!_this.activeStream)
                return;
            var periods = _this.manifestModel.getValue().mpd.periods;
            if (value < periods.length) {
                _this.videoModel.setCurrentTime(periods[value].start + 0.2);
            }
        };
        this.getVideoModel = function () {
            return _this.videoModel;
        };
        this.getCurrentManifestData = function () {
            return _this.manifestModel.getValue();
        };
        this.getBufferState = function () {
            if (_this.activeStream != null) {
                return _this.activeStream.getBufferState();
            }
            else {
                return 0;
            }
        };
        this.getBufferFor = function (type) {
            if (_this.activeStream != null) {
                return _this.activeStream.getBufferFor(type);
            }
            else {
                return null;
            }
        };
        this.getMediaSourceReadyState = function () {
            if (_this.mediaSource != null) {
                return _this.mediaSource.readyState;
            }
            else {
                return 'null';
            }
        };
        this.setVideoModel = function (value) {
            _this.videoModel = value;
            if (_this.params.SKIP_GAP_AT_HOB == true) {
                _this.videoModel.setSkipGapAtHOB(true);
            }
        };
        this.setUpMediaSource = function (value) {
            if (value != null) {
                var self_1 = _this;
                var mse = _this.createMediaSource.call(self_1);
                _this._setUpMediaSource.call(self_1, mse, function (mediaSourceResult) {
                    _this.mediaSource = mediaSourceResult;
                    if (_this.activeStream != null) {
                        _this.activeStream.setMediaSource(_this.mediaSource);
                    }
                });
            }
        };
        this.load = function (url) {
            var self = _this;
            if (url.type === 'url') {
                var loadManifestListener_1 = function (evt) {
                    if (evt.data.success) {
                        _this.manifestModel.setValue(evt.data.result);
                        _this.NXDebug.log('Manifest has loaded.');
                    }
                    else {
                        self.reset();
                    }
                    _this.eventBus.removeEventListener('LOAD_MANIFEST_END', loadManifestListener_1);
                };
                _this.eventBus.addEventListener('LOAD_MANIFEST_END', loadManifestListener_1);
                _this.manifestModel.loadManifest(url.source);
            }
            else if (url.type === 'xml') {
                _this.manifestModel.setManifestFromExt(url.baseUrl, url.source);
            }
            else if (url.type === 'data') {
                _this.manifestModel.setValue(url.source);
            }
        };
        this.updateVideoModel = function (vm) {
            _this.setVideoModel(vm);
            _this.setUpMediaSource(vm.getElement());
            _this.attachVideoEvents(vm);
            if (_this.activeStream != null) {
                _this.activeStream.setVideoModel(vm);
                _this.activeStream.initProtection();
                _this.activeStream.updateMediaSource();
            }
        };
        this.setManifestFromExt = function (url, data) {
            _this.manifestModel.setManifestFromExt(url, data);
        };
        this.setBandwidthLimit = function (min, max) {
            _this.manifestModel.setBandwidthLimit(min, max);
        };
        this.reset = function () {
            if (_this.activeStream != null) {
                _this.detachVideoEvents.call(_this, _this.activeStream.getVideoModel());
                _this.activeStream.reset();
            }
            if (_this.mediaSource != null) {
                _this.detachMediaSource.call(self, _this.videoModel);
            }
            _this.manifestModel.manifestUpdateStop();
            _this.manifestModel.setValue(null);
            _this.eventBus.clearAllEventListener();
            _this.activeStream = null;
            _this.xhrCustom = {};
        };
        this.end = function () {
            if (_this.activeStream) {
                _this.activeStream.end();
            }
            if (_this.mediaSource) {
                _this.detachMediaSource.call(_this, _this.videoModel);
            }
        };
        // setXhrCustom = (value: XHRCustom): void => {
        //   this.xhrCustom = value;
        // };
        this.setPresentationStartTime = function (value) {
            _this.initialPresentationStartTime = value;
        };
        this.setPresentationEndTime = function (value) {
            _this.initialPresentationEndTime = value;
        };
        this.activeStream = null;
        this.autoPlay = true;
        this.pauseListener = this.onPause.bind(this);
        this.playListener = this.onPlay.bind(this);
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.params = params;
        this.eventBus = _eventBus;
        this.metricsModel = metricsModel;
        this.abrController = abrController;
        this.xhrCustom = _xhrCustom;
        this.mediaSource = null;
        this.initialPresentationStartTime = NaN;
        this.initialPresentationEndTime = NaN;
        this.manifestModel = new _manifest_ManifestModel__WEBPACK_IMPORTED_MODULE_3__.ManifestModel(this.params, this.eventBus, this.xhrCustom);
        this.eventBus.addEventListener('manifestUpdated', this.manifestHasUpdated.bind(this));
    }
    return StreamController;
}());



/***/ }),

/***/ "./ts/dash/streaming/VideoModel.ts":
/*!*****************************************!*\
  !*** ./ts/dash/streaming/VideoModel.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DummyVideoModel": function() { return /* binding */ DummyVideoModel; }
/* harmony export */ });
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the names of the copyright holders nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * VideoModel
 *
 * @module VideoModel（VideoModelモジュール）
 */
/**
 * VideoModel
 * @constructor
 */
var VideoModel = /** @class */ (function () {
    function VideoModel(value, eventBus) {
        var _this = this;
        this.autoPlay = true;
        this.selfPaused = false;
        //NSV-a  let manualPause = true;
        this.startTime = NaN;
        this.startOffset = 0;
        this.stalledStreams = [];
        this.sourceBuffers = {
            video: undefined,
            audio: undefined,
        };
        this.epsilonVal = {
            video: 0,
            audio: 0,
        };
        //NSV-a  let seekedListener;
        //NSV-a  let seekedListener2;
        this.canplaythroughListener = function () { };
        this.adjusting = false;
        this.needsMoreData = true;
        this.skipGapAtHOB = false;
        this.playbackStarted = false;
        this.playCheckTimerId = null;
        this.isStalled = function () { return _this.stalledStreams.length > 0; };
        /* istanbul ignore next */
        this.playCheck = function (cur) {
            var self = _this;
            var timeupdateListener;
            var internalPause = false;
            var onTimeupdate = function (cur) {
                if (cur != _this.element.currentTime) {
                    _this.element.removeEventListener('timeupdate', timeupdateListener);
                    if (_this.playCheckTimerId != null) {
                        clearTimeout(_this.playCheckTimerId);
                    }
                }
            };
            var checkState = function (readyState) {
                _this.playCheckTimerId = null;
                if (!_this.element.paused || internalPause) {
                    if (cur == _this.element.currentTime) {
                        if (_this.element.readyState < 3) {
                            var b = _this.element.buffered;
                            for (var i = 0; i < b.length; i++) {
                                if (b.start(i) <= cur && cur < b.end(i)) {
                                    if (b.end(i) - cur > 10) {
                                        _this.element.removeEventListener('timeupdate', timeupdateListener);
                                        self.silentSeek(cur + 0.01);
                                    }
                                    else {
                                        _this.playCheckTimerId = setTimeout(checkState.bind(self, _this.element.readyState), 2000);
                                    }
                                }
                            }
                        }
                        else {
                            if (readyState > 2) {
                                _this.element.removeEventListener('timeupdate', timeupdateListener);
                                if (_this.element.paused) {
                                    _this.playCheckTimerId = setTimeout(checkState.bind(self, _this.element.readyState), 2000);
                                    _this.play.call(self);
                                }
                                else {
                                    self.silentSeek(cur + 0.1);
                                }
                            }
                            else {
                                _this.playCheckTimerId = setTimeout(checkState.bind(self, _this.element.readyState), 1000);
                                _this.element.pause();
                                internalPause = true;
                            }
                        }
                    }
                    else {
                        _this.element.removeEventListener('timeupdate', timeupdateListener);
                    }
                }
            };
            if (_this.playCheckTimerId != null) {
                clearTimeout(_this.playCheckTimerId);
            }
            timeupdateListener = onTimeupdate.bind(self, cur);
            _this.element.addEventListener('timeupdate', timeupdateListener);
            //@ts-ignore
            _this.playCheckTimerId = setTimeout(checkState.bind(self), 2000);
        };
        this.addStalledStream = function (type) {
            if (type === null) {
                return;
            }
            var evt = document.createEvent('HTMLEvents');
            evt.initEvent('buffering', true, false);
            evt.visibility = true;
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('*** addStalledStream trigger: ' +
                type +
                ', paused: ' +
                _this.element.paused);
            _this.element.dispatchEvent(evt);
            if (!_this.element.paused) {
                _this.selfPaused = true;
                _this.element.pause();
            }
            if (_this.stalledStreams.indexOf(type) !== -1) {
                return;
            }
            _this.stalledStreams.push(type);
        };
        this.play = function (manual) {
            if (manual) {
                //NSV-a      manualPause = false;
            }
            else {
            }
            if (_this.element.paused) {
                var promise_1;
                var _play = function () {
                    promise_1 = _this.element.play();
                    if (promise_1 !== undefined) {
                        promise_1
                            .then(function () {
                            _this.eventBus.dispatchEvent({
                                type: 'PLAY_PROMISE',
                                data: { element: _this.element },
                            });
                        })
                            .catch(function () {
                            _this.eventBus.dispatchEvent({
                                type: 'PLAY_PROMISE_ERROR',
                                data: { element: _this.element },
                            });
                        });
                    }
                    else {
                    }
                };
                _play();
            }
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('*** PLAY');
            (0,_core_Debug__WEBPACK_IMPORTED_MODULE_1__._log)('*** PLAY');
        };
        this.removeStalledStream = function (type) {
            var self = _this;
            if (type === null) {
                return;
            }
            var evt = document.createEvent('HTMLEvents');
            evt.initEvent('buffering', true, false);
            evt.visibility = false;
            var index = _this.stalledStreams.indexOf(type);
            if (index !== -1) {
                _this.stalledStreams.splice(index, 1);
            }
            if (!_this.isStalled()) {
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('*** removeStalledStream paused: ' +
                    _this.element.paused +
                    ', selfPaused: ' +
                    _this.selfPaused +
                    ',readyState:' +
                    _this.element.readyState);
                _this.element.dispatchEvent(evt);
                _this.adjustCurrentTime.call(_this, function () {
                    _this.playCheck.call(self, _this.element.currentTime);
                    if (_this.element.paused && _this.selfPaused) {
                        _this.selfPaused = false;
                        _this.play.call(self);
                        if (!_this.playbackStarted) {
                            _this.playbackStarted = true;
                            _this.eventBus.dispatchEvent({
                                type: 'playbackStarted',
                                data: {},
                            });
                        }
                    }
                    else {
                    }
                });
            }
        };
        this.pause = function (manual) {
            if (manual) {
                //NSV-a      manualPause = true;
            }
            else {
            }
            _this.element.pause();
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('*** PAUSE');
            (0,_core_Debug__WEBPACK_IMPORTED_MODULE_1__._log)('*** PAUSE');
        };
        this.stallStream = function (type, isStalled) {
            if (isStalled) {
                _this.addStalledStream(type);
            }
            else {
                _this.removeStalledStream.call(_this, type);
            }
        };
        //NSV-a  const onSeeked = () => {
        //NSV-a    LogHandler.log('currentTime:' + this.element.currentTime);
        //NSV-a    this.element.removeEventListener('seeked', seekedListener, false);
        //NSV-a    eventBus.dispatchEvent({
        //NSV-a      type: 'releaseSeekInhibition',
        //NSV-a      data: {},
        //NSV-a    });
        //NSV-a
        //NSV-a    adjusting = false;
        //NSV-a    eventBus.dispatchEvent({
        //NSV-a      type: 'ADJUST_CURRENTTIME_END',
        //NSV-a      data: {
        //NSV-a        ctime: this.element.currentTime,
        //NSV-a      },
        //NSV-a    });
        //NSV-a  };
        //NSV-a
        //NSV-a  const onSilentSeeked = () => {
        //NSV-a    LogHandler.log('currentTime[s]:' + this.element.currentTime);
        //NSV-a
        //NSV-a    this.element.removeEventListener('seeked', seekedListener2, false);
        //NSV-a    eventBus.dispatchEvent({
        //NSV-a      type: 'releaseSeekInhibition',
        //NSV-a      data: {},
        //NSV-a    });
        //NSV-a
        //NSV-a    adjusting = false;
        //NSV-a    eventBus.dispatchEvent({
        //NSV-a      type: 'ADJUST_CURRENTTIME_END',
        //NSV-a      data: {
        //NSV-a        ctime: this.element.currentTime,
        //NSV-a      },
        //NSV-a    });
        //NSV-a  };
        this.adjustCurrentTime = function (_callback) {
            var self = _this;
            var callback = _callback || (function () { });
            //const ranges = this.element.buffered;
            var vRanges;
            var aRanges;
            var ctime = _this.element.currentTime;
            var ttime = ctime;
            var target = ctime;
            var eps = _this.skipGapAtHOB || _this.playbackStarted ? 0 : 0.5;
            var i;
            vRanges = _this.sourceBuffers['video']
                ? _this.sourceBuffers['video'].buffered
                : null;
            aRanges = _this.sourceBuffers['audio']
                ? _this.sourceBuffers['audio'].buffered
                : null;
            if (vRanges === null || _this.element.readyState == 0) {
                callback(ctime);
            }
            else {
                for (i = 0; i < vRanges.length; i++) {
                    if (vRanges.start(i) - 1.0 < ctime && ctime < vRanges.start(i)) {
                        ttime = vRanges.start(i);
                        break;
                    }
                    else if (vRanges.start(i) <= ctime && ctime < vRanges.end(i)) {
                        //ttime = ctime;
                        break;
                    }
                }
                if (aRanges) {
                    for (i = 0; i < aRanges.length; i++) {
                        if (aRanges.start(i) - 1.0 < ttime && ttime < aRanges.start(i)) {
                            target = aRanges.start(i);
                            break;
                        }
                        else if (aRanges.start(i) <= ttime && ttime < aRanges.end(i)) {
                            target = ttime;
                            break;
                        }
                    }
                }
                else {
                    target = ttime;
                }
                if ((ctime == 0 && ctime + eps < target) ||
                    (ctime != 0 && ctime < target)) {
                    (0,_core_Debug__WEBPACK_IMPORTED_MODULE_1__._debug)('adjusted start time !!! ' + ctime + '=>' + target);
                    _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('adjusted start time !!! ' + ctime + '=>' + target);
                    self.silentSeek(target, function (dtime) {
                        if (dtime < target) {
                            self.silentSeek(target + 0.1, function (ddtime) {
                                callback(ddtime);
                            });
                        }
                        else {
                            callback(dtime);
                        }
                    });
                }
                else {
                    callback(ctime);
                }
            }
        };
        this.silentSeek = function (time, _callback) {
            var self = _this;
            var callback = _callback || (function () { });
            var silentSeekEndListener = function (evt) {
                _this.eventBus.removeEventListener('ADJUST_CURRENTTIME_END', silentSeekEndListener, false);
                _this.adjusting = false;
                callback(evt.data.ctime);
            };
            var silentSeekListener = function () {
                _this.eventBus.removeEventListener('ADJUST_CURRENTTIME_END', silentSeekListener, false);
                _this.adjusting = true;
                _this.eventBus.addEventListener('ADJUST_CURRENTTIME_END', silentSeekEndListener, false);
                self.setCurrentTime(time);
                //LogHandler.log("silent seek to:"+time);
            };
            if (_this.adjusting) {
                _this.eventBus.addEventListener('ADJUST_CURRENTTIME_END', silentSeekListener, false);
            }
            else {
                silentSeekListener();
            }
        };
        this.onCanplaythrough = function () {
            _this.unlisten('canplaythrough', _this.canplaythroughListener);
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('CanplayThrough!!!!!!!!!');
            _this.needsMoreData = false;
            (0,_core_Debug__WEBPACK_IMPORTED_MODULE_1__._info)('CanplayThrough!!!!!!!!!');
        };
        this.checkCanplaythrough = function () {
            _this.canplaythroughListener = _this.onCanplaythrough.bind(_this);
            _this.listen('canplaythrough', _this.canplaythroughListener);
        };
        this.isPaused = function () {
            return _this.element.paused;
        };
        this.getPlaybackRate = function () {
            return _this.element.playbackRate;
        };
        // setPlaybackRate = (value: number): void => {
        //   this.element.playbackRate = value;
        // };
        this.getCurrentTime = function () {
            return _this.element.currentTime;
        };
        this.setCurrentTime = function (currentTime) {
            // if (this.element.currentTime == currentTime) return;
            _this.element.currentTime = currentTime;
        };
        this.getDuration = function () {
            return _this.element.duration;
        };
        // setDuration = (_duration: number): void => {
        //   this.element.duration = duration;
        // };
        this.getCanPlayType = function (codec) {
            return _this.element.canPlayType(codec);
        };
        this.getReadyState = function () {
            return _this.element.readyState;
        };
        this.getBuffered = function () {
            return _this.element.buffered;
        };
        this.listen = function (type, callback) {
            _this.element.addEventListener(type, callback, false);
        };
        this.unlisten = function (type, callback) {
            _this.element.removeEventListener(type, callback, false);
        };
        this.getElement = function () {
            return _this.element;
        };
        // setElement = (value: NXHTMLVideoElement): void => {
        //   this.element = value;
        // };
        this.setSource = function (source) {
            //@ts-ignore
            _this.element.src = source;
        };
        // getPlaybackQuality = () => {
        //   const hasWebKit = 'webkitDroppedFrameCount' in this.element;
        //   const hasQuality = 'getVideoPlaybackQuality' in this.element;
        //   let result;
        //   if (hasQuality) {
        //     return this.element.getVideoPlaybackQuality();
        //   } else if (hasWebKit) {
        //     return {
        //       droppedVideoFrames: (this.element as WebkitHTMLVideoElement)
        //         .webkitDroppedFrameCount,
        //       creationTime: new Date(),
        //     };
        //   }
        //   return result;
        // };
        this.setAutoPlay = function (value) {
            _this.autoPlay = value;
            if (_this.autoPlay) {
                //NSV-a        manualPause = false;
                _this.selfPaused = true;
            }
            if (!_this.autoPlay && !_this.playbackStarted) {
                var listener_1 = function () { };
                var onPlay = function () {
                    _this.element.removeEventListener('play', listener_1);
                    if (!_this.playbackStarted) {
                        _this.playbackStarted = true;
                        _this.eventBus.dispatchEvent({
                            type: 'playbackStarted',
                            data: {},
                        });
                    }
                };
                listener_1 = onPlay.bind(_this);
                _this.element.addEventListener('play', listener_1);
            }
        };
        this.setStartTime = function (value) {
            _this.startTime = value;
        };
        this.getStartTime = function () {
            return _this.startTime;
        };
        this.setStartOffset = function (value) {
            _this.startOffset = value;
        };
        // getStartOffset = (): number => {
        //   return this.startOffset;
        // };
        // setPlaybackState = (value: boolean): void => {
        //   this.playbackStarted = value;
        // };
        this.getPlaybackState = function () {
            return _this.playbackStarted;
        };
        this.reset = function () {
            _this.startTime = NaN;
            _this.startOffset = 0;
            //NSV-a      manualPause = true;
            _this.selfPaused = false;
            _this.stalledStreams = [];
            _this.playbackStarted = false;
            _this.sourceBuffers = {
                video: undefined,
                audio: undefined,
            };
            _this.unlisten('canplaythrough', _this.canplaythroughListener);
            _this.canplaythroughListener = function () { };
            _this.needsMoreData = true;
        };
        this.setSelfPaused = function (value) {
            _this.selfPaused = value;
        };
        this.getSelfPaused = function () {
            return _this.selfPaused;
        };
        this.getNeedsMoreData = function () {
            return _this.needsMoreData || _this.element.readyState < 4;
        };
        // needsMoreDataState = (): boolean => {
        //   if (this.element.readyState < 4) {
        //     return true;
        //   } else {
        //     return false;
        //   }
        // };
        this.setSourceBuffer = function (type, val) {
            _this.sourceBuffers[type] = val;
        };
        this.setEpsilonFor = function (type, val) {
            _this.epsilonVal[type] = val;
        };
        this.setSkipGapAtHOB = function (value) {
            _this.skipGapAtHOB = value;
        };
        this.onAdjusting = function () {
            return _this.adjusting;
        };
        this.isDummy = function () {
            return false;
        };
        this.setCurrentStatus = function (status) {
            _this.autoPlay = status.autoPlay;
            _this.selfPaused = status.selfPaused;
            //NSV-a      manualPause = status.manualPause;
            _this.startTime = status.startTime;
            _this.startOffset = status.startOffset;
            _this.stalledStreams = status.stalledStreams;
            _this.epsilonVal = status.epsilonVal;
            _this.adjusting = status.adjusting;
            _this.playbackStarted = status.playbackStarted;
        };
        this.element = value;
        this.eventBus = eventBus;
    }
    return VideoModel;
}());
var DummyVideoModel = /** @class */ (function () {
    function DummyVideoModel(value, eventBus) {
        var _this = this;
        this.autoPlay = true;
        this.selfPaused = false;
        this.manualPause = true;
        this.startTime = NaN;
        this.startOffset = 0;
        this.stalledStreams = [];
        this.sourceBuffers = {
            video: undefined,
            audio: undefined,
        };
        this.epsilonVal = {
            video: 0,
            audio: 0,
        };
        this.canplaythroughListener = function () { };
        this.adjusting = false;
        //NSV-a  const skipGapAtHOB = false;
        this.playbackStarted = false;
        this.addStalledStream = function (type) {
            if (type === null) {
                return;
            }
            _core_LogHandler__WEBPACK_IMPORTED_MODULE_0__["default"].log('*** addStalledStream trigger: ' + type + ', paused: true');
            if (_this.stalledStreams.indexOf(type) !== -1) {
                return;
            }
            _this.stalledStreams.push(type);
        };
        this.removeStalledStream = function () { };
        this.play = function (manual) {
            if (manual) {
                _this.manualPause = false;
            }
            else {
            }
        };
        this.pause = function (manual) {
            if (manual) {
                _this.manualPause = true;
            }
            else {
            }
        };
        this.stallStream = function (type, isStalled) {
            if (isStalled) {
                _this.addStalledStream(type);
            }
            else {
                _this.removeStalledStream.call(_this);
            }
        };
        //NSV-a  const onSeeked = () => {};
        //NSV-a  const onSilentSeeked = () => {};
        this.adjustCurrentTime = function (_callback) { };
        this.silentSeek = function (_time, _callback) { };
        //NSV-a  const onCanplaythrough = (evt) => {};
        this.checkCanplaythrough = function () { };
        this.isPaused = function () {
            return true;
        };
        this.getPlaybackRate = function () {
            return 1;
        };
        // setPlaybackRate = (): void => {};
        this.getCurrentTime = function () {
            return 0;
        };
        this.setCurrentTime = function () { };
        this.getDuration = function () {
            return Infinity;
        };
        // setDuration = (): void => {};
        this.getCanPlayType = function () {
            return 'probably';
        };
        this.getReadyState = function () {
            return 1;
        };
        this.getBuffered = function () {
            return {
                length: 0,
                start: function (_index) { return 0; },
                end: function (_index) { return 0; },
            };
        };
        this.listen = function () { };
        this.unlisten = function () { };
        this.getElement = function () {
            return null;
        };
        // setElement = (): void => {};
        this.setSource = function () { };
        this.setAutoPlay = function (value) {
            _this.autoPlay = value;
            if (_this.autoPlay) {
                _this.manualPause = false;
                _this.selfPaused = true;
            }
        };
        this.setStartTime = function (value) {
            _this.startTime = value;
        };
        this.getStartTime = function () {
            return _this.startTime;
        };
        this.setStartOffset = function (value) {
            _this.startOffset = value;
        };
        // getStartOffset = (): number => {
        //   return this.startOffset;
        // };
        // setPlaybackState = (value: boolean): void => {
        //   this.playbackStarted = value;
        // };
        this.getPlaybackState = function () {
            return _this.playbackStarted;
        };
        this.reset = function () {
            _this.startTime = NaN;
            _this.startOffset = 0;
            _this.manualPause = true;
            _this.selfPaused = false;
            _this.stalledStreams = [];
            _this.playbackStarted = false;
            _this.sourceBuffers = {
                video: undefined,
                audio: undefined,
            };
            _this.unlisten();
            _this.canplaythroughListener = function () { };
        };
        this.setSelfPaused = function (value) {
            _this.selfPaused = value;
        };
        this.getSelfPaused = function () {
            return _this.selfPaused;
        };
        this.getNeedsMoreData = function () {
            return true;
        };
        // needsMoreDataState = (): boolean => {
        //   return true;
        // };
        this.setSourceBuffer = function (type, val) {
            _this.sourceBuffers[type] = val;
        };
        this.setEpsilonFor = function (type, val) {
            _this.epsilonVal[type] = val;
        };
        this.setSkipGapAtHOB = function () {
            //NSV-a      skipGapAtHOB = value;
        };
        this.onAdjusting = function () {
            return _this.adjusting;
        };
        this.getCurrentStatus = function () {
            var status = {
                autoPlay: _this.autoPlay,
                selfPaused: _this.selfPaused,
                manualPause: _this.manualPause,
                startTime: _this.startTime,
                startOffset: _this.startOffset,
                stalledStreams: _this.stalledStreams,
                epsilonVal: _this.epsilonVal,
                adjusting: _this.adjusting,
                playbackStarted: _this.playbackStarted,
            };
            return status;
        };
        this.isDummy = function () {
            return true;
        };
        this.value = value;
        this.eventBus = eventBus;
    }
    return DummyVideoModel;
}());

/* harmony default export */ __webpack_exports__["default"] = (VideoModel);


/***/ }),

/***/ "./ts/dash/ttml/TTMLParser.ts":
/*!************************************!*\
  !*** ./ts/dash/ttml/TTMLParser.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TTMLParser": function() { return /* binding */ TTMLParser; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * <br/>
 * TTML字幕提示モジュール<br/>
 *
 * @module TTMLParser（字幕解析モジュール）
 */
/**
 * TTMLパーサー
 * @constructor
 */
var TTMLParser = /** @class */ (function () {
    function TTMLParser() {
        var _this = this;
        /**
         * @namespace NS 各名前空間の定数定義
         * @property {string} XHTML XHTML 名前空間
         * @property {string} TTML TTML 名前空間
         * @property {string} SMPTE smpte-TT名前空間
         * @property {string} ARIB ARIB-TTの名前空間
         * @type {{XHTML: string, TTML: string, SMPTE: string, ARIB: string, getTagName: Function}}
         */
        this.NS = {
            XHTML: 'http://www.w3.org/1999/xhtml',
            TTML: 'http://www.w3.org/ns/ttml',
            SMPTE: 'http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt',
            ARIB: 'http://www.arib.or.jp/ns/arib-tt',
            /**
             * 指定したElementの名前空間に応じたタグ名を返す
             * @param {{}} _e DOMObject
             * @returns {string} タグ名称
             */
            getTagName: function (_e) {
                var tag = _e.localName;
                switch (_e.namespaceURI) {
                    case this.XHTML:
                        return tag;
                    case this.TTML:
                        return 'tt:' + tag;
                    case this.SMPTE:
                        return 'smpte:' + tag;
                    case this.ARIB:
                        return 'arib-tt:' + tag;
                    default:
                        return '';
                }
            },
        };
        /**
         * _eに属するDOMObjectをtagNameから取得する
         * @param {{}} _e 親のDOMObj
         * @param {string} tagName タグ名
         * @returns {Array} Elementの配列
         */
        this.getObjFromTagName = function (_e, tagName) {
            return _e[0].getElementsByTagName(tagName);
        };
        /**
         * TTMLを解析して字幕、FontFace、KeyFramesを返す
         * @param {string|xml} ttml TTML字幕の文字列(or xml)
         * @param {string} baseURL ttmlを取得したurl
         * @returns {{captions: Array, fontfaces: Array, keyframes: Array}}
         */
        this.parse = function (xml, _baseURL, parse_range) {
            _this.baseURL = _baseURL;
            if (typeof xml === 'string') {
                xml = _this.parseXML(xml);
            }
            _this._root = xml.getElementsByTagName('tt');
            _this.arr_captions = [];
            if (_this._root.length > 0) {
                _this._head = _this.getObjFromTagName(_this._root, 'head');
                _this._styling =
                    _this._head.length == 0
                        ? []
                        : _this.getObjFromTagName(_this._head, 'styling');
                _this._styles =
                    _this._styling.length == 0
                        ? []
                        : _this.getObjFromTagName(_this._styling, 'style');
                _this._layout =
                    _this._head.length == 0
                        ? []
                        : _this.getObjFromTagName(_this._head, 'layout');
                _this._regions =
                    _this._layout.length == 0
                        ? []
                        : _this.getObjFromTagName(_this._layout, 'region');
                _this._arib_keyframes =
                    _this._head.length == 0
                        ? []
                        : _this.getObjFromTagName(_this._head, 'keyframes');
                _this._arib_fontfaces =
                    _this._head.length == 0
                        ? []
                        : _this.getObjFromTagName(_this._head, 'font-face');
                _this._body = _this.getObjFromTagName(_this._root, 'body');
                try {
                    // styling, region, keyframes, font-faceのパース
                    _this.parseStyle();
                    if (_this.isUndefined(parse_range)) {
                        parse_range = {
                            begin_time: 0,
                            end_time: 36000000,
                        };
                    }
                    // 最大値は10時間までとする
                    _this.listupCaptions(_this._body[0], {
                        begin_time: 0,
                        end_time: 36000000,
                    }, parse_range);
                }
                catch (err) {
                    var err_msg = '**ERR** ' + err.message;
                    _this.NXDebug.debug(err_msg);
                }
            }
            return {
                captions: _this.arr_captions,
                fontfaces: _this.arr_fontfaces,
                keyframes: _this.arr_keyframes,
            };
        };
        /**
         * styling, region, keyframes, font-faceのパース
         */
        this.parseStyle = function () {
            var _e;
            var ret;
            var id;
            var i;
            var s;
            var _e_children;
            var _e1;
            // 初期化
            _this.arr_regions = [];
            _this.arr_styles = [];
            // style
            for (i = 0; i < _this._styles.length; i++) {
                _e = _this._styles[i];
                if (_e.nodeType != 3) {
                    ret = _this.transAttrFromElement(_e);
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'id')) {
                        id = ret.htmlAttrs.id;
                        // styleの参照があれば付加
                        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'style_ref')) {
                            ret.htmlCss['style_ref'] = ret.htmlAttrs['style_ref'];
                        }
                        _this.arr_styles[id] = ret.htmlCss;
                    }
                    else {
                        _this.NXDebug.log('ERROR : style.id(xml:id) attribute is not found !!! ');
                    }
                }
            }
            // region
            for (var j = 0; j < _this._regions.length; j++) {
                _e = _this._regions[j];
                if (_e.nodeType != 3) {
                    ret = _this.transAttrFromElement(_e);
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'id')) {
                        id = ret.htmlAttrs.id;
                        var begin = null;
                        var end = null;
                        // styleの参照があれば付加
                        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'style_ref')) {
                            ret.htmlCss['style_ref'] = ret.htmlAttrs['style_ref'];
                        }
                        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'begin')) {
                            begin = ret.htmlAttrs['begin'];
                        }
                        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'end')) {
                            end = ret.htmlAttrs['end'];
                        }
                        _this.arr_regions.push({
                            id: ret.htmlAttrs.id,
                            begin: begin,
                            end: end,
                            styles: ret.htmlCss,
                        });
                    }
                    else {
                        _this.NXDebug.error('ERROR : region.id(xml:id) attribute is not found !!!');
                    }
                }
            }
            // arib-tt:keyframesをパース
            _this.arr_keyframes = [];
            for (var k = 0; k < _this._arib_keyframes.length; k++) {
                _e = _this._arib_keyframes[k];
                if (_e.nodeType != 3) {
                    ret = _this.transAttrFromElement(_e);
                    var animationName = '';
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'animationName')) {
                        animationName = ret.htmlAttrs.animationName;
                        var arr_position = [];
                        _e_children = _e.childNodes;
                        for (i = 0; i < _e_children.length; i++) {
                            _e1 = _e_children[i];
                            if (_e1.nodeType != 3) {
                                ret = _this.transAttrFromElement(_e1);
                                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'keyframeposition')) {
                                    var position = ret.htmlAttrs['keyframeposition'];
                                    var styles = '';
                                    for (s in ret.htmlCss) {
                                        if (styles != '')
                                            styles += ';';
                                        styles += s + ':' + ret.htmlCss[s];
                                    }
                                    if (styles != '')
                                        styles += ';';
                                    arr_position.push({
                                        position: position,
                                        styles: '{' + styles + '}',
                                    });
                                }
                                else {
                                    _this.NXDebug.error('ERROR : arib-tt:keyframe.position is not found ');
                                }
                            }
                        }
                        _this.arr_keyframes.push({
                            name: animationName,
                            positions: arr_position,
                        });
                    }
                }
            }
            // arib-tt:fontfaceをパース
            _this.arr_fontfaces = [];
            for (var l = 0; l < _this._arib_fontfaces.length; l++) {
                _e = _this._arib_fontfaces[l];
                if (_e.nodeType != 3) {
                    ret = _this.transAttrFromElement(_e);
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, 'id')) {
                        var temp_arr_styles = {};
                        id = ret.htmlAttrs.id;
                        for (s in ret.htmlAttrs) {
                            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, s)) {
                                if (s == 'font-family') {
                                    temp_arr_styles[s] = "'" + ret.htmlAttrs[s] + "'";
                                }
                                else {
                                    temp_arr_styles[s] = ret.htmlAttrs[s];
                                }
                            }
                        }
                        _e_children = _e.childNodes;
                        for (i = 0; i < _e_children.length; i++) {
                            _e1 = _e_children[i];
                            if (_e1.nodeType != 3) {
                                ret = _this.transAttrFromElement(_e1);
                                for (s in ret.htmlAttrs) {
                                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, s)) {
                                        temp_arr_styles[s] = ret.htmlAttrs[s];
                                    }
                                }
                            }
                        }
                        _this.arr_fontfaces.push(temp_arr_styles);
                    }
                }
            }
            _this.arr_styleSheets = [];
            for (i = 0; i < _this.arr_regions.length; i++) {
                var region = _this.arr_regions[i];
                _this.arr_styleSheets.push({
                    id: region.id,
                    begin: region.begin,
                    end: region.end,
                    styles: _this.applyStyleToRegion(region.styles),
                });
            }
            for (var i_1 in _this.arr_styles) {
                var style = _this.arr_styles[i_1];
                _this.arr_styleSheets.push({
                    id: i_1,
                    begin: null,
                    end: null,
                    styles: _this.applyStyleToRegion(style),
                });
            }
        };
        /**
         * 指定したElement(_e)要素以下から字幕データを抽出しttmlListへ追加する(再起処理として使用)
         * @param {{}} _e 対象Element（DOMObject）
         * @param parent_range 親のElementのbegin～end(子要素のbegin,endはこの範囲内となるため下位要素へ渡す)
         * @private
         */
        this.listupCaptions = function (_e, parent_range, parse_range) {
            var begin_time = parent_range.begin_time;
            var end_time = parent_range.end_time;
            var attr_begin = _e.getAttribute('begin');
            var attr_end = _e.getAttribute('end');
            var id = _e.getAttribute('xml:id');
            if (attr_begin == null && attr_end == null) {
                // eslint-disable-line no-empty
            }
            else {
                // msに変換
                var begin = _this.parseTime(attr_begin) + begin_time;
                var end = _this.parseTime(attr_end);
                if (parse_range) {
                    // パースする対象なので提示時間のみで判断する
                    if (parse_range.begin_time <= begin && begin < parse_range.end_time) {
                        // eslint-disable-line no-empty
                    }
                    else {
                        return;
                    }
                }
                //
                if (_e.getAttribute('parsed') == 'true') {
                    return;
                }
                // 変換
                var _trans_e = _this.transElement(_e);
                _e.setAttribute('parsed', 'true');
                _this.arr_captions.push({
                    begin_time: begin,
                    end_time: end,
                    id: id,
                    caption: _trans_e,
                });
                begin_time = begin;
                end_time = end;
            }
            var _e_children = _e.childNodes;
            for (var i = 0; i < _e_children.length; i++) {
                if (_e_children[i].nodeName != '#text') {
                    _this.listupCaptions(_e_children[i], {
                        begin_time: begin_time,
                        end_time: end_time,
                    }, parse_range);
                }
            }
        };
        /**
         * regionに対するstyle適用（style自身も再帰的に適用する）
         * @param {Array} arr regionの配列
         * @returns {Array} styleが適用されたregionの配列
         * @private
         */
        this.applyStyleToRegion = function (arr) {
            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(arr, 'style_ref')) {
                var style_id = arr.style_ref;
                delete arr['style_ref'];
                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(_this.arr_styles, style_id)) {
                    var style = _this.arr_styles[style_id];
                    for (var v in style) {
                        if (!(0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(arr, v))
                            arr[v] = style[v];
                    }
                    arr = _this.applyStyleToRegion(arr);
                }
                else {
                    _this.NXDebug.error('ERROR : style id is not found in region/style!!! id=' + style_id);
                }
            }
            return arr;
        };
        /**
         * 指定したelementにデフォルトのStyleを適用する
         * @param {{}} _e デフォルトStyleを適用するelement
         */
        this.applyDefaultStyleToElement = function (_e) {
            _e.style['position'] = 'absolute';
            _e.style['margin'] = '0px';
            _e.style['padding'] = '0px';
            _e.style['whiteSpace'] = 'nowrap';
            _e.style['offset'] = '0px';
            _e.style['border'] = '0px';
            _e.style['overflow'] = 'hidden';
            return _e;
        };
        /**
         * Styleシートの定義をElementへ反映
         * @param {{}} _e 対象のelement
         */
        this.applyRegionStyleToElement = function (_e) {
            // regionの適用
            var region = _e.getAttribute('region');
            if (!_this.isUndefined(region)) {
                _this.applyStyleSheet(_e, region);
            }
            // 現状、styling以外（p,div,span）に対するstyleは運用外だが処理はしておく
            var style = _e.getAttribute('style');
            if (!_this.isUndefined(style)) {
                _this.applyStyleSheet(_e, style);
            }
        };
        /**
         * arr_stylesheetsからidのStyleを_eに適用する
         * @param {{}} _e 対象のelement
         * @param {string} id styleのid
         * @private
         */
        this.applyStyleSheet = function (_e, id) {
            var e_begin = _e.getAttribute('begin');
            var e_end = _e.getAttribute('end');
            var parent_range = {
                begin: e_begin,
                end: e_end,
            };
            var child_range;
            var stylesheet;
            for (var i = 0; i < _this.arr_styleSheets.length; i++) {
                if (id == _this.arr_styleSheets[i].id) {
                    stylesheet = _this.arr_styleSheets[i];
                    child_range = {
                        begin: stylesheet.begin,
                        end: stylesheet.end,
                    };
                    if (_this.checkRange(parent_range, child_range)) {
                        for (var key in stylesheet.styles) {
                            _e.style[key] = stylesheet.styles[key];
                        }
                    }
                }
            }
        };
        /**
         * parent.begin～parent.endがchild.begin～child.endの範囲内かをチェックする
         * @param {{}} parent begin(datetime), end(datetime)を持つObject
         * @param {{}} child begin(datetime), end(datetime)を持つObject
         * @returns {boolean}
         */
        this.checkRange = function (parent, child) {
            if (_this.isUndefined(parent.begin) && _this.isUndefined(parent.end))
                return true;
            if (_this.isUndefined(child.begin) && _this.isUndefined(child.end))
                return true;
            if (!_this.isUndefined(parent.begin) && !_this.isUndefined(child.begin)) {
                if (parent.begin > child.begin) {
                    return false;
                }
            }
            if (!_this.isUndefined(parent.end) && !_this.isUndefined(child.end)) {
                if (parent.end < child.end) {
                    return false;
                }
            }
            return true;
        };
        /* istanbul ignore next */
        /**
         * TTMLのelementをHTMLに変換する(再起的に処理される）
         * @param {{}} _e 対象となる最初のElement(DOMObject)
         * @returns {{}} 変換後のElement(DOMObject)
         * @private
         */
        this.transElement = function (_e) {
            // Tag名変換
            var htmlTagName = _e.localName;
            var _trans = document.createElement(htmlTagName);
            var i;
            var attr;
            // デフォルトスタイルの適用
            _trans = _this.applyDefaultStyleToElement(_trans);
            _trans.style['position'] = 'absolute';
            _trans.style['margin'] = '0px';
            _trans.style['padding'] = '0px';
            _trans.style['whiteSpace'] = 'nowrap';
            _trans.style['offset'] = '0px';
            _trans.style['border'] = '0px';
            _trans.style['overflow'] = 'hidden';
            // stylesheet(styling)の適用
            var v_region = _e.getAttribute('region');
            var v_style = _e.getAttribute('style');
            if (v_region != null && typeof v_region != 'undefined') {
                _trans.setAttribute('region', v_region);
            }
            if (v_style != null && typeof v_style != 'undefined') {
                _trans.setAttribute('style', v_style);
            }
            _this.applyRegionStyleToElement(_trans);
            // attributeをリストアップ（名前だけではない特別な変換を要するものはここで変換）
            var htmlAttrs = {};
            var arr_processed_attr = [];
            for (i = 0; i < _e.attributes.length; i++) {
                attr = _e.attributes[i];
                switch (attr.name) {
                    case 'tts:fontSize':
                        var value = attr.value;
                        var size = value.split(/\s/);
                        if (size.length == 2) {
                            _trans.style[attr.name] = size[1];
                            var ratio = +size[0].replace('px', '') / +size[1].replace('px', '');
                            if (ratio != 1) {
                                _trans.style['transform'] = 'scaleX(' + ratio + ')';
                                _trans.style['transform-origin'] = 'left top';
                                _trans.style['-webkit-transform'] = 'scaleX(' + ratio + ')';
                                _trans.style['-webkit-transform-origin'] = 'left top';
                                _trans.style['-moz-transform'] = 'scaleX(' + ratio + ')';
                                _trans.style['-moz-transform-origin'] = 'left top';
                                _trans.style['-o-transform'] = 'scaleX(' + ratio + ')';
                                _trans.style['-o-transform-origin'] = 'left top';
                                _trans.style['-ms-transform'] = 'scaleX(' + ratio + ')';
                                _trans.style['-ms-transform-origin'] = 'left top';
                                // letter-spacingがあればtransformに影響しないように値を調整
                                var temp_value = _e.getAttribute('arib-tt:letter-spacing');
                                if (typeof temp_value !== 'undefined') {
                                    var ls = +temp_value.replace('px', '') / ratio;
                                    _trans.style['letter-spacing'] = ls + 'px';
                                    arr_processed_attr.push('letter-spacing');
                                }
                            }
                        }
                        else {
                            _trans.style['font-size'] = value;
                        }
                        break;
                    case 'smpte:backgroundImage':
                        var img_obj = document.createElement('img');
                        img_obj.setAttribute('src', _this.baseURL + attr.value);
                        _trans.appendChild(img_obj);
                        break;
                    default:
                        htmlAttrs[attr.localName] = attr.value;
                        break;
                }
            }
            // 上で処理済みのattributeはこの先で処理しない
            for (i = 0; i < arr_processed_attr.length; i++) {
                delete htmlAttrs[arr_processed_attr[i]];
            }
            // タグの指定によるものはここで変換
            var ttmlTagName = _this.NS.getTagName(_e);
            switch (ttmlTagName) {
                // arib-tt:audio
                case 'arib-tt:audio':
                    //autoplayは提示時にセットhtmlAttrs["autoplay"] = "autoplay";
                    if (_e.getAttribute('loop') == 'false') {
                        delete htmlAttrs['loop'];
                    }
                    break;
            }
            // 属性変換
            for (var attr_1 in htmlAttrs) {
                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(htmlAttrs, attr_1)) {
                    var ret = _this.transAttr(attr_1, htmlAttrs[attr_1]);
                    for (var attr2 in ret.htmlAttrs) {
                        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlAttrs, attr2)) {
                            _trans.setAttribute(attr2, ret.htmlAttrs[attr2]);
                        }
                    }
                    for (var css in ret.htmlCss) {
                        if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(ret.htmlCss, css)) {
                            _trans.style[css] = ret.htmlCss[css];
                        }
                    }
                }
            }
            // 下階層へ再起処理
            var _e_children = _e.childNodes;
            for (i = 0; i < _e_children.length; i++) {
                // Text
                if (_e_children[i].nodeType == 3) {
                    // eslint-disable-line no-empty
                }
                else {
                    var t_ele = _this.transElement(_e_children[i]);
                    _trans.appendChild(t_ele);
                }
            }
            var _e_childnodes = _e.childNodes;
            for (i = 0; i < _e_childnodes.length; i++) {
                // Text
                if (_e_childnodes[i].nodeType == 3) {
                    var tmp_data = _e_childnodes[i].data.replace(/[\s\n\t]+/gm, '');
                    if (tmp_data != '') {
                        _trans.appendChild(document.createTextNode(_e_childnodes[i].data));
                    }
                }
                else {
                    // eslint-disable-line no-empty
                }
            }
            return _trans;
        };
        /**
         * textをxmlパース
         * @param {string} val 対象のテキスト
         * @returns {HTMLDocument}
         */
        this.parseXML = function (val) {
            var parser = new DOMParser();
            return parser.parseFromString(val, 'application/xml');
        };
        /**
         * TTMLの時刻(begin,end)の記述"hh:mm:ss.nnn"をmsに変換
         * @param {string} value 提示時刻
         * @returns {number} 提示時間(ms)
         */
        this.parseTime = function (value) {
            var temp1 = value.split('.');
            var ms = 0;
            if (temp1.length >= 2)
                ms = parseInt(temp1[1], 10);
            var h = 0;
            var m = 0;
            var s = 0;
            if (temp1.length >= 1) {
                var temp2 = temp1[0].split(':');
                if (temp2.length >= 3) {
                    h = parseInt(temp2[0], 10);
                    m = parseInt(temp2[1], 10);
                    s = parseInt(temp2[2], 10);
                    return 1000 * (h * 60 * 60 + m * 60 + s) + ms;
                }
            }
            return 0;
        };
        /**
         * 指定したElementの属性を変換する
         * @param {{}} _e 対象のelement
         * @private
         */
        this.transAttrFromElement = function (_e) {
            var arr_attrs = {};
            var _e_attributes = _e.attributes;
            var i;
            for (i = 0; i < _e_attributes.length; i++) {
                arr_attrs[_e_attributes[i].localName] = _e_attributes[i].value;
            }
            var arr_html_attr = {};
            var arr_html_css = {};
            switch (_e.tagName) {
                case 'arib-tt:src':
                    if (typeof arr_attrs['url'] != 'undefined') {
                        var arib_tt_url = 'url(' + "'" + _this.baseURL + arr_attrs['url'] + "'" + ') ';
                        if (typeof arr_attrs['format'] != 'undefined') {
                            arib_tt_url += 'format(' + "'" + arr_attrs['format'] + "'" + ')';
                        }
                        arr_html_attr['src'] = arib_tt_url;
                    }
                    // このタグの属性は上記で処理済みのためすべて削除
                    arr_attrs = {};
                    break;
            }
            // 属性変換
            for (var attr in arr_attrs) {
                if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_1__.hasProperty)(arr_attrs, attr)) {
                    var ret = _this.transAttr(attr, arr_attrs[attr]);
                    for (var i_2 in ret.htmlAttrs)
                        arr_html_attr[i_2] = ret.htmlAttrs[i_2];
                    for (var i_3 in ret.htmlCss)
                        arr_html_css[i_3] = ret.htmlCss[i_3];
                }
            }
            return {
                htmlAttrs: arr_html_attr,
                htmlCss: arr_html_css,
            };
        };
        /**
         * TTML XMLの属性から HTMLの属性とcssへ変換<br/>
         * htmlAttrsに属性のKey=Value連想配列、htmlCssにCssのKey=Value連想配列が返る
         * @param {string} name 変換元(TTML)属性名
         * @param {string} value 変換元(TTML)属性の値
         * @returns {{arr_html_attr: Array, arr_html_css: Array}} arr_html_attr:属性の配列, arr_html_css:CSSの配列
         * @private
         */
        this.transAttr = function (name, value) {
            var arr_html_css = {};
            var arr_html_attr = {};
            var arr_color;
            var idx;
            switch (name) {
                case 'animation':
                    arr_html_css['WebkitAnimation'] = value;
                    arr_html_css['white-space'] = 'nowrap';
                    break;
                case 'animationName':
                    arr_html_attr['animationName'] = value;
                    break;
                case 'position':
                    // attributeにpositionを入れられないのでrenameする
                    arr_html_attr['keyframeposition'] = value;
                    break;
                case 'style':
                    arr_html_attr['style_ref'] = value;
                    break;
                case 'region':
                    arr_html_attr['class'] = value; // inlineで使用しない場合用に入れておく
                    arr_html_attr['region'] = value;
                    break;
                case 'id':
                    arr_html_attr[name] = value;
                    break;
                case 'extent':
                    var dim = value.split(/\s/);
                    arr_html_css['width'] = dim[0];
                    arr_html_css['height'] = dim[1];
                    break;
                case 'origin':
                    var pos = value.split(/\s/);
                    arr_html_css['position'] = 'absolute';
                    arr_html_css['left'] = pos[0];
                    arr_html_css['top'] = pos[1];
                    break;
                case 'color':
                case 'backgroundColor':
                    if (value.indexOf('#') == 0) {
                        if (name == 'backgroundColor')
                            name = 'background-color';
                        arr_color = [];
                        idx = 0;
                        while (idx * 2 + 1 <= value.length - 1) {
                            arr_color[idx] = value.substr(idx * 2 + 1, 2);
                            idx += 1;
                        }
                        if (arr_color.length == 4) {
                            arr_html_css[name] =
                                'rgba(' +
                                    parseInt(arr_color[0], 16) +
                                    ',' +
                                    parseInt(arr_color[1], 16) +
                                    ',' +
                                    parseInt(arr_color[2], 16) +
                                    ',' +
                                    (parseInt(arr_color[3], 16) + 1) / 256 +
                                    ')';
                        }
                        else {
                            arr_html_css[name] =
                                'rgb(' +
                                    parseInt(arr_color[0], 16) +
                                    ',' +
                                    parseInt(arr_color[1], 16) +
                                    ',' +
                                    parseInt(arr_color[2], 16) +
                                    ')';
                        }
                    }
                    else {
                        _this.NXDebug.debug('ERROR: color,backgroundColor format is only #nnnnnn[nn] ... value=' +
                            value);
                    }
                    break;
                case 'src':
                    arr_html_attr['src'] = _this.baseURL + value;
                    break;
                case 'border':
                    var arr_border = value.split(' ');
                    var bcolor = void 0;
                    if (arr_border && arr_border.length == 3) {
                        arr_color = [];
                        idx = 0;
                        var cc = arr_border[2];
                        while (idx * 2 + 1 <= cc.length - 1) {
                            arr_color[idx] = cc.substr(idx * 2 + 1, 2);
                            idx += 1;
                        }
                        if (arr_color.length == 4) {
                            bcolor =
                                'rgba(' +
                                    parseInt(arr_color[0], 16) +
                                    ',' +
                                    parseInt(arr_color[1], 16) +
                                    ',' +
                                    parseInt(arr_color[2], 16) +
                                    ',' +
                                    (parseInt(arr_color[3], 16) + 1) / 256 +
                                    ')';
                        }
                        else {
                            bcolor =
                                'rgb(' +
                                    parseInt(arr_color[0], 16) +
                                    ',' +
                                    parseInt(arr_color[1], 16) +
                                    ',' +
                                    parseInt(arr_color[2], 16) +
                                    ')';
                        }
                        arr_html_css[name] =
                            arr_border[0] + ' ' + arr_border[1] + ' ' + bcolor;
                    }
                    else {
                        arr_html_css[name] = value;
                    }
                    break;
                case 'border-left':
                case 'border-right':
                case 'border-top':
                case 'border-bottom':
                    arr_html_css[name] = value;
                    break;
                case 'textOutline':
                    var arr_outline = value.split(' ');
                    if (arr_outline && arr_outline.length == 3) {
                        var blur_1 = parseInt(arr_outline[2]) + parseInt(arr_outline[1]);
                        //arr_html_css['-webkit-text-stroke-color'] = arr_outline[0];
                        arr_color = [];
                        idx = 0;
                        var valueColor = arr_outline[0];
                        while (idx * 2 + 1 <= valueColor.length - 1) {
                            arr_color[idx] = valueColor.substr(idx * 2 + 1, 2);
                            idx += 1;
                        }
                        if (arr_color.length == 4) {
                            arr_html_css['-webkit-text-stroke-color'] =
                                'rgba(' +
                                    parseInt(arr_color[0], 16) +
                                    ',' +
                                    parseInt(arr_color[1], 16) +
                                    ',' +
                                    parseInt(arr_color[2], 16) +
                                    ',' +
                                    (parseInt(arr_color[3], 16) + 1) / 256 +
                                    ')';
                        }
                        else {
                            arr_html_css['-webkit-text-stroke-color'] =
                                'rgb(' +
                                    parseInt(arr_color[0], 16) +
                                    ',' +
                                    parseInt(arr_color[1], 16) +
                                    ',' +
                                    parseInt(arr_color[2], 16) +
                                    ')';
                        }
                        arr_html_css['-webkit-text-stroke-width'] = arr_outline[1];
                        arr_html_css['-webkit-text-shadow'] =
                            -1 * blur_1 +
                                'px ' +
                                -1 * blur_1 +
                                'px ' +
                                arr_outline[0] +
                                ',' +
                                blur_1 +
                                'px ' +
                                -1 * blur_1 +
                                'px ' +
                                arr_outline[0] +
                                ',' +
                                -1 * blur_1 +
                                'px ' +
                                blur_1 +
                                'px ' +
                                arr_outline[0] +
                                ',' +
                                blur_1 +
                                'px ' +
                                blur_1 +
                                'px ' +
                                arr_outline[0];
                    }
                    else {
                        _this.NXDebug.debug('ERROR: textOutline format is unavailable ... value = ' + value);
                    }
                    break;
                case 'opacity':
                    arr_html_css['opacity'] = value;
                    break;
                case 'fontSize':
                    var size = value.split(/\s/);
                    if (size.length > 1) {
                        arr_html_css['font-size'] = size[1];
                    }
                    else {
                        arr_html_css['font-size'] = value;
                    }
                    break;
                case 'fontFamily':
                    arr_html_css['font-family'] = '"' + value + '"';
                    break;
                case 'fontStyle':
                case 'fontWeight':
                case 'lineHeight':
                case 'textDecoration':
                case 'letter-spacing':
                    arr_html_css[name] = value;
                    break;
                default:
                    arr_html_attr[name] = value;
                    break;
            }
            return {
                htmlAttrs: arr_html_attr,
                htmlCss: arr_html_css,
            };
        };
        /**
         * undefined or null 判定をする
         * @param {{}} val undefined判定をする値
         * @returns {boolean}
         */
        this.isUndefined = function (val) {
            return typeof val === 'undefined' || val == null;
        };
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._root = [];
        this._body = [];
        this._head = [];
        this._styling = [];
        this._layout = [];
        this._styles = [];
        this._regions = [];
        this._arib_keyframes = [];
        this._arib_fontfaces = [];
        this.arr_styles = [];
        this.arr_regions = [];
        this.arr_styleSheets = [];
        this.arr_keyframes = [];
        this.arr_fontfaces = [];
        this.arr_captions = [];
        this.baseURL = '';
    }
    return TTMLParser;
}());



/***/ }),

/***/ "./ts/dash/ttml/TTMLRenderer.ts":
/*!**************************************!*\
  !*** ./ts/dash/ttml/TTMLRenderer.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TTMLCaptionImpl": function() { return /* binding */ TTMLCaptionImpl; },
/* harmony export */   "TTMLCaptionList": function() { return /* binding */ TTMLCaptionList; },
/* harmony export */   "TTMLCue": function() { return /* binding */ TTMLCue; },
/* harmony export */   "TTMLRenderer": function() { return /* binding */ TTMLRenderer; },
/* harmony export */   "TTMLSubtitleElement": function() { return /* binding */ TTMLSubtitleElement; },
/* harmony export */   "ttml_renderer": function() { return /* binding */ ttml_renderer; }
/* harmony export */ });
/* harmony import */ var _core_Debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Debug */ "./ts/dash/core/Debug.ts");
/* harmony import */ var _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/LogHandler */ "./ts/dash/core/LogHandler.ts");
/* harmony import */ var _core_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Utils */ "./ts/dash/core/Utils.ts");
/* harmony import */ var _TTMLParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TTMLParser */ "./ts/dash/ttml/TTMLParser.ts");
/*
 * The copyright in this software is being made available under the BSD License, included below.
 *
 * Copyright (c) 2022, NHK(Japan Broadcasting Corporation).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * - Neither the name of the NHK nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */




/**
 * <br/>
 * TTML字幕提示モジュール<br/>
 *
 * @module javascript TTMLRenderer（字幕提示モジュール）
 */
// parse
var BUFFERING_TIME = 20000; // 20s（先20秒分の字幕までパースする）
// parser実行間隔
var PARSE_INTERVAL = BUFFERING_TIME - 3000;
/**
 * undefined or null 判定をする
 * @param {{}} val undefined判定をする値
 * @returns {boolean}
 */
function isUndefined(val) {
    return typeof val === 'undefined' || val == null;
}
/**
 *
 * @param ttml
 * @constructor
 */
var TTMLCue = /** @class */ (function () {
    function TTMLCue(ttml) {
        this.ttml = ttml;
        this.parsed_end_time = 0;
    }
    return TTMLCue;
}());

/**
 * TTML字幕クラス
 * @param {{}} caption id,begin_time,end_time,caption(HTML)
 * @constructor
 */
var TTMLCaptionImpl = /** @class */ (function () {
    function TTMLCaptionImpl(caption) {
        this.id = caption.id;
        this.begin_time = caption.begin_time;
        this.end_time = caption.end_time;
        this.caption = caption.caption;
    }
    return TTMLCaptionImpl;
}());

/**
 * TTML字幕リストクラス
 * @constructor
 */
var TTMLCaptionList = /** @class */ (function () {
    function TTMLCaptionList() {
        var _this = this;
        /**
         * 字幕データを追加する
         * @param {TTMLCaption} ttmlCaption TTMLCaptionオブジェクト
         */
        this.add = function (ttmlCaption) {
            _this.arr_caption.push(ttmlCaption); //new TTMLCaption(ttmlCaption));
        };
        /**
         * 字幕データの蓄積数
         * @returns {Number}
         */
        this.getLength = function () { return _this.arr_caption.length; };
        /**
         * 蓄積された字幕から指定したindexの字幕を取得
         * @param {number} idx 取得する字幕のindex
         * @returns {TTMLCaption}
         */
        this.get = function (idx) { return _this.arr_caption[idx]; };
        /**
         * 指定した字幕Object(TTMLCaption)のindexを取得する<br>
         * TTMLCaptionパラメーター値のマッチングではなく、Objectのマッチングなので注意
         * @param {TTMLCaption} obj 検索対象のobject
         * @returns {number}
         */
        this.search = function (obj) {
            for (var i = 0; i < _this.arr_caption.length; i++) {
                if (_this.arr_caption[i] == obj)
                    return i;
            }
            return -1;
        };
        /**
         * 指定したObject(TTMLCaption)を削除する<br>
         * TTMLCaptionパラメーター値のマッチングではなく、Objectのマッチングなので注意
         * @param {TTMLCaption} obj 削除対象のオブジェクト
         * @returns {number}
         */
        this.remove = function (obj) {
            for (var i = 0; i < _this.arr_caption.length; i++) {
                if (_this.arr_caption[i] == obj) {
                    _this.arr_caption.splice(i, 1);
                    return i;
                }
            }
            return -1;
        };
        /**
         * 指定した時間を対象とする提示対象の字幕リストを取得する
         * @param {number} time 提示時間
         * @returns {Array}
         */
        this.getActiveTTMLCaptionList = function (time) {
            var activeList = new TTMLCaptionList();
            for (var _i = 0, _a = _this.arr_caption; _i < _a.length; _i++) {
                var cap = _a[_i];
                // begin,endがないものは対象外
                if (isUndefined(cap.begin_time) && isUndefined(cap.end_time))
                    continue;
                if (cap.begin_time <= time && time < cap.end_time) {
                    activeList.add(cap);
                }
            }
            return activeList;
        };
        this.arr_caption = [];
    }
    return TTMLCaptionList;
}());

/**
 * TTML字幕エレメントクラス（日本語、英語などの単位）
 * @param _eVideo VideoElement
 * @param _id 字幕Elementのid
 * @param _subtitle_attr 字幕の属性（src:ファイルURL, srclang:字幕の言語）
 * @constructor
 */
var TTMLSubtitleElement = /** @class */ (function () {
    function TTMLSubtitleElement(parentClass, _eVideo, _id, _subtitle_attr) {
        var _this = this;
        /**
         * 字幕エレメントのidを取得する
         * @returns {string}
         */
        this.getID = function () { return _this.id; };
        /**
         * パース待ちTTMLをCueに追加
         *
         * @param ttml
         */
        this.addTTMLCue = function (ttml) {
            //	arr_ttml_cue.push(new TTMLCue(ttml));
            _this.arr_ttml_cue.shift();
            _this.arr_ttml_cue.push(new TTMLCue(ttml));
        };
        /**
         * endTimeまでをパース
         * @param {number} startTime(ms)
         */
        this.parseCue = function (startTime) {
            var parse_count = 0;
            var endTime = startTime + BUFFERING_TIME;
            var parse_range = {
                begin_time: startTime,
                end_time: endTime,
            };
            var cue;
            for (var i = 0; i < _this.arr_ttml_cue.length; i++) {
                cue = _this.arr_ttml_cue[i];
                // 解析開始～終了（Seekも考慮するため前回パース最終時刻は使用しない）
                parse_range.begin_time = startTime; //cue.parsed_end_time;
                parse_range.end_time = endTime;
                // parse
                var result = _this.parentClass.ttmlParser.parse(cue.ttml, _this.getBaseUrl(), parse_range);
                var ttmlList = new TTMLCaptionList();
                for (var _i = 0, _a = result.captions; _i < _a.length; _i++) {
                    var caption = _a[_i];
                    var ttmlCaption = new TTMLCaptionImpl(caption);
                    ttmlList.add(ttmlCaption);
                }
                parse_count = result.captions.length;
                _this.addTTMLCaptionList(ttmlList);
                // KeyFrameとFontFaceは初回だけ
                if (!_this.kfCreateFlg) {
                    if (result.captions.length > 0) {
                        var caption_id = result.captions[0].id;
                        _this.kfCreateFlg = true;
                        _this.parentClass.createKeyFrame(result.keyframes, _this.getID(), caption_id);
                        _this.parentClass.createFontFace(result.fontfaces, _this.getID(), caption_id);
                    }
                }
            }
            if (parse_count > 0) {
                // 今回のパース結果
                cue.parsed_end_time = endTime;
            }
        };
        /**
         * 字幕エレメントのsrc(TTML取得先URL)を取得する
         * @returns {string}
         */
        this.getSrc = function () { return _this.src; };
        /**
         * 字幕エレメントのbaseURL（TTML取得先BaseURL）を取得する
         */
        this.getBaseUrl = function () {
            var arr_src = _this.src.split('/');
            if (arr_src && arr_src.length > 1) {
                var result = '';
                for (var i = 0; i < arr_src.length - 1; i++) {
                    result += arr_src[i] + '/';
                }
                return result;
            }
            return '/';
        };
        /**
         * 字幕エレメントの言語を取得する
         * @returns {string}
         */
        this.getSrclang = function () { return _this.srclang; };
        /**
         * セットしたcaptionのリストをインスタンス内のcaptionListに追加する
         * @param {Array} ttmlCaptionList 字幕リストに追加する字幕の配列
         */
        this.addTTMLCaptionList = function (ttmlCaptionList) {
            for (var i = 0; i < ttmlCaptionList.getLength(); i++) {
                var tcap = ttmlCaptionList.get(i);
                var newCaption = true;
                for (var ii = 0; ii < _this.ttml_caption_list.getLength(); ii++) {
                    var cap = _this.ttml_caption_list.get(ii);
                    if (cap.id == tcap.id) {
                        newCaption = false;
                        break;
                    }
                }
                if (newCaption) {
                    _this.ttml_caption_list.add(tcap);
                }
            }
        };
        /**
         * パース済み字幕リストから指定時間の字幕を提示
         * @param {number} time 提示時間
         */
        this.presentationTTML = function (time) {
            var activeList = _this.ttml_caption_list.getActiveTTMLCaptionList(time);
            var presentList = new TTMLCaptionList();
            var removeList = new TTMLCaptionList();
            var search_idx;
            var i;
            for (i = 0; i < activeList.getLength(); i++) {
                search_idx = -1;
                // すでに提示中の場合は提示対象とはしない
                if (_this.currentActiveList) {
                    search_idx = _this.currentActiveList.search(activeList.get(i));
                }
                if (search_idx == -1)
                    presentList.add(activeList.get(i));
            }
            // 削除対象
            if (_this.currentActiveList) {
                for (i = 0; i < _this.currentActiveList.getLength(); i++) {
                    if (activeList.search(_this.currentActiveList.get(i)) == -1) {
                        removeList.add(_this.currentActiveList.get(i));
                    }
                }
            }
            // 提示時に子要素を削除
            for (i = 0; i < removeList.getLength(); i++) {
                var remove_id = removeList.get(i).id;
                var remove_node = document.getElementById(remove_id);
                if (remove_node) {
                    _this._overlay.removeChild(remove_node);
                }
            }
            if (presentList.getLength() > 0) {
                var ttmlCaption = void 0;
                var htmlCaption = void 0;
                for (i = 0; i < presentList.getLength(); i++) {
                    ttmlCaption = presentList.get(i);
                    htmlCaption = ttmlCaption.caption.cloneNode(true);
                    if (document.getElementById(ttmlCaption.id) != null)
                        continue;
                    if (htmlCaption.localName == 'div') {
                        if (htmlCaption.hasAttribute('style')) {
                            var htmlStyleCaption = htmlCaption;
                            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(htmlStyleCaption.style, 'width')) {
                                htmlStyleCaption.style.width = _this._overlay.style.width;
                            }
                            if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(htmlStyleCaption.style, 'height')) {
                                htmlStyleCaption.style.height = _this._overlay.style.height;
                            }
                        }
                    }
                    _this._overlay.appendChild(htmlCaption);
                }
            }
            // audioタグがあれば再生する。
            var audio_list = _this._overlay.getElementsByTagName('audio');
            for (i = 0; i < audio_list.length; i++) {
                if (audio_list[i].getAttribute('autoplay') != 'autoplay') {
                    audio_list[i].setAttribute('autoplay', 'autoplay');
                }
            }
            _this.currentActiveList = activeList;
            return presentList.getLength();
        };
        this.parentClass = parentClass;
        this.id = _id;
        this.src = isUndefined(_subtitle_attr['src'])
            ? null
            : _subtitle_attr['src'];
        this.srclang = isUndefined(_subtitle_attr['srclang'])
            ? null
            : _subtitle_attr['srclang'];
        this.arr_ttml_cue = [];
        this.ttml_caption_list = new TTMLCaptionList();
        this.currentActiveList = null;
        this.kfCreateFlg = false;
        this._overlay = document.createElement('div');
        this._overlay.id = _id;
        this._overlay.setAttribute('class', 'subtitle_element');
        this._overlay.style.position = 'absolute';
        this._overlay.style.left = '0px';
        this._overlay.style.top = '0px';
        this._overlay.style.width = _eVideo.width + 'px';
        this._overlay.style.height = _eVideo.height + 'px';
        this._overlay.style.padding = '0px';
        this._overlay.style.overflow = 'hidden';
        _eVideo.parentNode.insertBefore(this._overlay, _eVideo.nextSibling);
    }
    return TTMLSubtitleElement;
}());

/**
 * TTML提示管理クラス
 * @constructor
 */
var TTMLRenderer = /** @class */ (function () {
    function TTMLRenderer() {
        var _this = this;
        /**
         * 字幕表示/非表示切り替え
         * @param {boolean} value
         */
        this.setSubtitleVisible = function (value) {
            for (var i = 0; i < _this.getSubtitleElementCount(); i++) {
                if (i != _this.select_subtitle_index)
                    continue;
                var subtitle = _this.getSubtitleElement(i);
                var _subtitle = document.getElementById(subtitle.getID());
                if (value) {
                    _subtitle.style.display = 'block';
                }
                else {
                    _subtitle.style.display = 'none';
                }
            }
        };
        /**
         * 字幕の表示状態を取得
         * @returns {boolean}
         */
        this.getSubtitleVisible = function () {
            for (var i = 0; i < _this.getSubtitleElementCount(); i++) {
                var subtitle = _this.getSubtitleElement(i);
                var _subtitle = document.getElementById(subtitle.getID());
                if (_subtitle.style.display != 'none') {
                    return true;
                }
            }
            return false;
        };
        /**
         * 字幕切り替え index=0～SubtitleElementCount()-1
         * @param index
         */
        this.selectSubtitle = function (index) {
            _this.setSubtitleVisible(false);
            for (var i = 0; i < _this.getSubtitleElementCount(); i++) {
                if (index == i) {
                    _this.select_subtitle_index = index;
                    var subtitle = _this.getSubtitleElement(i);
                    var _subtitle = document.getElementById(subtitle.getID());
                    _subtitle.style.display = 'block';
                    break;
                }
            }
        };
        /**
         * パース後イベント
         * @param {Function} event
         */
        this.addParsedEvent = function (event) {
            _this.parsedEvent.push(event);
        };
        /**
         * idから字幕レイヤーを取得
         * @param {string} id 字幕Elementのid
         * @returns {TTMLSubtitleElement} TTML字幕レイヤーオブジェクト
         * @private
         */
        //  private getSubtitleElementById = (
        this.getSubtitleElementById = function (id) {
            for (var i = 0; i < _this.arr_subtitle_element.length; i++) {
                if (_this.arr_subtitle_element[i].getID() == id) {
                    return _this.arr_subtitle_element[i];
                }
            }
            return null;
        };
        /**
         * 静的なttml読み込み
         * @param {string} id TrackElementのid
         * @param {string} ttml_url 静的TTMLのURL
         */
        this.retrieveStaticSubtitle = function (id, ttml_url) {
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                if (xhr.status == 200 || xhr.status == 206) {
                    _this.addTTMLText(id, xhr.response);
                    _this.NXDebug.log('ttml-retrieve-success: ' + ttml_url);
                }
            };
            xhr.onerror = function () {
                _this.NXDebug.log('ttml-retrieve-failure: ' +
                    xhr.status +
                    ' ' +
                    xhr.statusText +
                    ' url:' +
                    ttml_url);
            };
            xhr.onabort = function () { };
            xhr.open('GET', ttml_url, false);
            xhr.send();
        };
        /**
         *
         * @param periods
         * @param videoElement
         */
        this.parseTTMLFromMPD = function (periods, videoElement) {
            var i;
            if (typeof periods === 'undefined') {
                _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__["default"].log('error periods is undefined!!');
            }
            _this.videoElement = videoElement;
            for (i = 0; i < periods.length; i++) {
                for (var _i = 0, _a = periods[i].adaptationSets; _i < _a.length; _i++) {
                    var as = _a[_i];
                    if (as.mimeType && as.mimeType == 'application/ttml+xml') {
                        if (as.Role == 'undefined') {
                            _core_LogHandler__WEBPACK_IMPORTED_MODULE_1__["default"].log('-->error adaptationSets.Role is undefined!! ');
                            break;
                        }
                        else {
                            if (as.Role == 'subtitle') {
                                for (var k = 0; k < as.representations.length; k++) {
                                    var baseURL = as.representations[k].BaseURL[0].url;
                                    var id = 'ttml_' +
                                        (as.representations[k].id || as.representations[k].index); //as.attrs.lang;
                                    if (!_this.getSubtitleElementById(id)) {
                                        _this.addSubtitleElement(videoElement, id, {
                                            src: baseURL,
                                            srclang: as.attrs.lang,
                                        });
                                    }
                                    _this.retrieveStaticSubtitle(id, baseURL);
                                }
                            }
                            else {
                                _this.NXDebug.log('adaptationSets.Role != subtitle >> ' + as.Role);
                                break;
                            }
                        }
                    }
                }
            }
            var subtitleCount = _this.getSubtitleElementCount();
            // 字幕は初期表示しない（すべて非表示）
            if (subtitleCount > 0) {
                _this.select_subtitle_index = 0;
                for (i = 0; i < subtitleCount; i++) {
                    var subtitle = _this.getSubtitleElement(i);
                    document.getElementById(subtitle.getID()).style.display = 'none';
                }
            }
            else {
                _this.select_subtitle_index = -1;
            }
            // ParsedイベントCall
            _this.callParsedEvent();
        };
        /*
         * Parsed後イベントのCall
         */
        this.callParsedEvent = function () {
            for (var i = 0; i < _this.parsedEvent.length; i++) {
                _this.parsedEvent[i]();
            }
        };
        /**
         * レンダラーに追加された字幕エレメント数を返す
         * @returns {Number}
         */
        this.getSubtitleElementCount = function () { return _this.arr_subtitle_element.length; };
        /**
         * indexから字幕エレメントを取得
         * @param {number} index 0～getSubtitleCountまでの字幕数
         * @returns {TTMLSubtitleElement}
         */
        this.getSubtitleElement = function (index) {
            return _this.arr_subtitle_element[index];
        };
        /**
         * 字幕Seek後に呼ばれる
         * @private
         */
        this.videoSeeked = function () {
            _this.parseTTMLElements();
        };
        /**
         * 字幕エレメントをvideoに追加する
         * @param {element} eVideo VideoのElement
         * @param {string} id 字幕のid(HTMLのDOM中で一意に指定)
         * @param {{}} subtitle_attr kind,src,srclang,label
         */
        this.addSubtitleElement = function (eVideo, id, subtitle_attr) {
            if (_this.seekedListener == null) {
                _this.seekedListener = _this.videoSeeked.bind(_this);
                _this.videoElement.addEventListener('seeked', _this.seekedListener);
            }
            var subtitle = new TTMLSubtitleElement(_this, eVideo, id, subtitle_attr);
            _this.arr_subtitle_element.push(subtitle);
            if (isUndefined(_this.presentationTimer))
                _this.presentationTimer = setInterval(_this.presentationTTMLElements, _this.setting.presentation_interval);
            if (isUndefined(_this.parseTimer))
                _this.parseTimer = setInterval(_this.parseTTMLElements, PARSE_INTERVAL);
        };
        /**
         * TTML提示用エレメントに字幕（XML）を追加
         * @param {string} id 字幕を追加する対象となるエレメントのid
         * @param {XML} ttml_xml 字幕DOM(xml)
         */
        this.addTTMLText = function (id, ttml_xml) {
            var subtitle_element = _this.getSubtitleElementById(id);
            if (isUndefined(subtitle_element)) {
                return;
            }
            // パース用Cueに蓄積
            subtitle_element.addTTMLCue(ttml_xml);
            // 初回パース(このあとのparseはtimerから呼ばれる）
            _this.parseTTMLElements();
        };
        /**
         * keyframesの配列からstyleを生成
         * @param {Array} keyframes keyframeのパラメーター配列
         * @param {string} subtitle_id 字幕Element(親)のID
         * @param {number} caption_id 字幕(そのもの)のID（提示字幕単位）
         * @private
         */
        this.createKeyFrame = function (keyframes, subtitle_id, caption_id) {
            if (_this._head == null) {
                _this._head = document.getElementsByTagName('head')[0];
            }
            if (keyframes.length > 0) {
                var tmp_style = _this._head.getElementsByTagName('style');
                if (tmp_style.length > 0) {
                    if ((0,_core_Utils__WEBPACK_IMPORTED_MODULE_2__.hasProperty)(tmp_style, 'getElementById')) {
                        var tmp_style_one = tmp_style.getElementById('temp_keyframes_' + subtitle_id + '_' + caption_id);
                        if (tmp_style_one) {
                            _this._head.removeChild(tmp_style_one);
                        }
                    }
                }
                var style_txt = '';
                for (var _i = 0, keyframes_1 = keyframes; _i < keyframes_1.length; _i++) {
                    var keyframe = keyframes_1[_i];
                    style_txt += '@-webkit-keyframes ' + keyframe.name + '{';
                    for (var j = 0; j < keyframe.positions.length; j++) {
                        style_txt +=
                            keyframe.positions[j].position + keyframe.positions[j].styles;
                        style_txt += '\n';
                    }
                    style_txt += '}\n';
                }
                var _style = document.createElement('style');
                _style.type = 'text/css';
                _style.id = 'temp_keyframes_' + subtitle_id + '_' + caption_id;
                _style.innerHTML = style_txt;
                _this._head.appendChild(_style);
            }
        };
        /**
         * 指定したfontfaceの配列から、font-faceのstyleを生成する
         * @param {Array} fontfaces 配列(font-faceパラメーターのKey->valueの配列)
         * @param {string} subtitle_id 字幕の提示するElementのID
         * @param {number} caption_id 字幕ID(提示単位)
         * @private
         */
        this.createFontFace = function (fontfaces, subtitle_id, caption_id) {
            var style_txt = '';
            if (_this._head == null) {
                _this._head = document.getElementsByTagName('head')[0];
            }
            if (fontfaces.length > 0) {
                for (var i = 0; i < fontfaces.length; i++) {
                    style_txt = '@font-face {';
                    for (var s in fontfaces[i]) {
                        if (s == 'id')
                            continue;
                        style_txt += s + ':' + fontfaces[i][s] + ';';
                    }
                    style_txt += '}';
                    var _style = document.createElement('style');
                    _style.type = 'text/css';
                    _style.id =
                        'temp_fontfaces_' +
                            subtitle_id +
                            '_' +
                            caption_id +
                            '_' +
                            fontfaces[i]['id'];
                    _style.innerHTML = style_txt;
                    _this._head.appendChild(_style);
                }
            }
        };
        /**
         * 提示時間の元になる時間を取得する（videoと同期するかどうか）
         * @return {number} 提示時刻
         */
        this.getCurrentTime = function () {
            // 受信時間
            if (_this.setting.presentation_timing == 0) {
                return new Date().getTime();
            }
            else {
                if (_this.videoElement) {
                    return _this.videoElement.currentTime * 1000;
                }
                else {
                    _this.NXDebug.error('videoElement is null...');
                    return 0;
                }
            }
        };
        /**
         * 全字幕エレメントごとの字幕を提示
         */
        this.presentationTTMLElements = function () {
            if (_this.arr_subtitle_element.length > 0) {
                var currentTime = _this.getCurrentTime();
                for (var i in _this.arr_subtitle_element) {
                    _this.arr_subtitle_element[i].presentationTTML(currentTime);
                }
            }
        };
        /**
         * 全字幕エレメントの字幕を解析する
         */
        this.parseTTMLElements = function () {
            if (_this.arr_subtitle_element.length > 0) {
                var currentTime = _this.getCurrentTime();
                for (var i = 0; i < _this.arr_subtitle_element.length; i++) {
                    _this.arr_subtitle_element[i].parseCue(currentTime);
                }
            }
        };
        /**
         * DashTVPlayer
         * @param dashTvPlayer
         */
        this.setDashTVPlayer = function (dashTvPlayer) {
            // 生成されたTrackから字幕をParserへ通す
            dashTvPlayer.addEventListener('manifestUpdated', function () {
                var periods = dashTvPlayer.getPeriodInfo();
                _this.parseTTMLFromMPD(periods, dashTvPlayer.getVideoModel().getElement());
            }, false);
        };
        /**
         * setting指定
         * @property {number} presentation_timing 提示タイミング(0:提示環境の時間を参照, 1:videoのcurrentTimeを参照）
         * @property {number} presentation_interval ttml提示間隔(ms) 提示精度をこの値で調整
         * @param {{ttml_show_timing, TTML_SHOW_INTERVAL}} _setting
         */
        this.setSetting = function (_setting) {
            _this.setting = _setting;
        };
        this.NXDebug = new _core_Debug__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._head = null;
        this.setting = {
            presentation_timing: 1,
            presentation_interval: 500,
        };
        this.presentationTimer = null;
        this.parseTimer = null;
        this.arr_subtitle_element = [];
        this.parsedEvent = [];
        this.ttmlParser = new _TTMLParser__WEBPACK_IMPORTED_MODULE_3__.TTMLParser();
        this.videoElement = null;
        this.seekedListener = null;
        this.select_subtitle_index = -1;
    }
    return TTMLRenderer;
}());

var ttml_renderer = new TTMLRenderer();


/***/ })

 	});
/************************************************************************/
 	// The module cache
 	var __webpack_module_cache__ = {};
 	
 	// The require function
 	function __webpack_require__(moduleId) {
 		// Check if module is in cache
 		var cachedModule = __webpack_module_cache__[moduleId];
 		if (cachedModule !== undefined) {
 			if (cachedModule.error !== undefined) throw cachedModule.error;
 			return cachedModule.exports;
 		}
 		// Create a new module (and put it into the cache)
 		var module = __webpack_module_cache__[moduleId] = {
 			// no module.id needed
 			// no module.loaded needed
 			exports: {}
 		};
 	
 		// Execute the module function
 		try {
 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
 			module = execOptions.module;
 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
 		} catch(e) {
 			module.error = e;
 			throw e;
 		}
 	
 		// Return the exports of the module
 		return module.exports;
 	}
 	
 	// expose the modules object (__webpack_modules__)
 	__webpack_require__.m = __webpack_modules__;
 	
 	// expose the module cache
 	__webpack_require__.c = __webpack_module_cache__;
 	
 	// expose the module execution interceptor
 	__webpack_require__.i = [];
 	
/************************************************************************/
 	/* webpack/runtime/define property getters */
 	!function() {
 		// define getter functions for harmony exports
 		__webpack_require__.d = function(exports, definition) {
 			for(var key in definition) {
 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
 				}
 			}
 		};
 	}();
 	
 	/* webpack/runtime/get javascript update chunk filename */
 	!function() {
 		// This function allow to reference all chunks
 		__webpack_require__.hu = function(chunkId) {
 			// return url for filenames based on template
 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
 		};
 	}();
 	
 	/* webpack/runtime/get update manifest filename */
 	!function() {
 		__webpack_require__.hmrF = function() { return "main." + __webpack_require__.h() + ".hot-update.json"; };
 	}();
 	
 	/* webpack/runtime/getFullHash */
 	!function() {
 		__webpack_require__.h = function() { return "0062640caed5de708f68"; }
 	}();
 	
 	/* webpack/runtime/global */
 	!function() {
 		__webpack_require__.g = (function() {
 			if (typeof globalThis === 'object') return globalThis;
 			try {
 				return this || new Function('return this')();
 			} catch (e) {
 				if (typeof window === 'object') return window;
 			}
 		})();
 	}();
 	
 	/* webpack/runtime/hasOwnProperty shorthand */
 	!function() {
 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
 	}();
 	
 	/* webpack/runtime/load script */
 	!function() {
 		var inProgress = {};
 		// data-webpack is not used as build has no uniqueName
 		// loadScript function to load a script via script tag
 		__webpack_require__.l = function(url, done, key, chunkId) {
 			if(inProgress[url]) { inProgress[url].push(done); return; }
 			var script, needAttach;
 			if(key !== undefined) {
 				var scripts = document.getElementsByTagName("script");
 				for(var i = 0; i < scripts.length; i++) {
 					var s = scripts[i];
 					if(s.getAttribute("src") == url) { script = s; break; }
 				}
 			}
 			if(!script) {
 				needAttach = true;
 				script = document.createElement('script');
 		
 				script.charset = 'utf-8';
 				script.timeout = 120;
 				if (__webpack_require__.nc) {
 					script.setAttribute("nonce", __webpack_require__.nc);
 				}
 		
 				script.src = url;
 			}
 			inProgress[url] = [done];
 			var onScriptComplete = function(prev, event) {
 				// avoid mem leaks in IE.
 				script.onerror = script.onload = null;
 				clearTimeout(timeout);
 				var doneFns = inProgress[url];
 				delete inProgress[url];
 				script.parentNode && script.parentNode.removeChild(script);
 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
 				if(prev) return prev(event);
 			}
 			;
 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
 			script.onerror = onScriptComplete.bind(null, script.onerror);
 			script.onload = onScriptComplete.bind(null, script.onload);
 			needAttach && document.head.appendChild(script);
 		};
 	}();
 	
 	/* webpack/runtime/make namespace object */
 	!function() {
 		// define __esModule on exports
 		__webpack_require__.r = function(exports) {
 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
 			}
 			Object.defineProperty(exports, '__esModule', { value: true });
 		};
 	}();
 	
 	/* webpack/runtime/hot module replacement */
 	!function() {
 		var currentModuleData = {};
 		var installedModules = __webpack_require__.c;
 		
 		// module and require creation
 		var currentChildModule;
 		var currentParents = [];
 		
 		// status
 		var registeredStatusHandlers = [];
 		var currentStatus = "idle";
 		
 		// while downloading
 		var blockingPromises;
 		
 		// The update info
 		var currentUpdateApplyHandlers;
 		var queuedInvalidatedModules;
 		
 		// eslint-disable-next-line no-unused-vars
 		__webpack_require__.hmrD = currentModuleData;
 		
 		__webpack_require__.i.push(function (options) {
 			var module = options.module;
 			var require = createRequire(options.require, options.id);
 			module.hot = createModuleHotObject(options.id, module);
 			module.parents = currentParents;
 			module.children = [];
 			currentParents = [];
 			options.require = require;
 		});
 		
 		__webpack_require__.hmrC = {};
 		__webpack_require__.hmrI = {};
 		
 		function createRequire(require, moduleId) {
 			var me = installedModules[moduleId];
 			if (!me) return require;
 			var fn = function (request) {
 				if (me.hot.active) {
 					if (installedModules[request]) {
 						var parents = installedModules[request].parents;
 						if (parents.indexOf(moduleId) === -1) {
 							parents.push(moduleId);
 						}
 					} else {
 						currentParents = [moduleId];
 						currentChildModule = request;
 					}
 					if (me.children.indexOf(request) === -1) {
 						me.children.push(request);
 					}
 				} else {
 					console.warn(
 						"[HMR] unexpected require(" +
 							request +
 							") from disposed module " +
 							moduleId
 					);
 					currentParents = [];
 				}
 				return require(request);
 			};
 			var createPropertyDescriptor = function (name) {
 				return {
 					configurable: true,
 					enumerable: true,
 					get: function () {
 						return require[name];
 					},
 					set: function (value) {
 						require[name] = value;
 					}
 				};
 			};
 			for (var name in require) {
 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
 				}
 			}
 			fn.e = function (chunkId) {
 				return trackBlockingPromise(require.e(chunkId));
 			};
 			return fn;
 		}
 		
 		function createModuleHotObject(moduleId, me) {
 			var _main = currentChildModule !== moduleId;
 			var hot = {
 				// private stuff
 				_acceptedDependencies: {},
 				_acceptedErrorHandlers: {},
 				_declinedDependencies: {},
 				_selfAccepted: false,
 				_selfDeclined: false,
 				_selfInvalidated: false,
 				_disposeHandlers: [],
 				_main: _main,
 				_requireSelf: function () {
 					currentParents = me.parents.slice();
 					currentChildModule = _main ? undefined : moduleId;
 					__webpack_require__(moduleId);
 				},
 		
 				// Module API
 				active: true,
 				accept: function (dep, callback, errorHandler) {
 					if (dep === undefined) hot._selfAccepted = true;
 					else if (typeof dep === "function") hot._selfAccepted = dep;
 					else if (typeof dep === "object" && dep !== null) {
 						for (var i = 0; i < dep.length; i++) {
 							hot._acceptedDependencies[dep[i]] = callback || function () {};
 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
 						}
 					} else {
 						hot._acceptedDependencies[dep] = callback || function () {};
 						hot._acceptedErrorHandlers[dep] = errorHandler;
 					}
 				},
 				decline: function (dep) {
 					if (dep === undefined) hot._selfDeclined = true;
 					else if (typeof dep === "object" && dep !== null)
 						for (var i = 0; i < dep.length; i++)
 							hot._declinedDependencies[dep[i]] = true;
 					else hot._declinedDependencies[dep] = true;
 				},
 				dispose: function (callback) {
 					hot._disposeHandlers.push(callback);
 				},
 				addDisposeHandler: function (callback) {
 					hot._disposeHandlers.push(callback);
 				},
 				removeDisposeHandler: function (callback) {
 					var idx = hot._disposeHandlers.indexOf(callback);
 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
 				},
 				invalidate: function () {
 					this._selfInvalidated = true;
 					switch (currentStatus) {
 						case "idle":
 							currentUpdateApplyHandlers = [];
 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
 								__webpack_require__.hmrI[key](
 									moduleId,
 									currentUpdateApplyHandlers
 								);
 							});
 							setStatus("ready");
 							break;
 						case "ready":
 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
 								__webpack_require__.hmrI[key](
 									moduleId,
 									currentUpdateApplyHandlers
 								);
 							});
 							break;
 						case "prepare":
 						case "check":
 						case "dispose":
 						case "apply":
 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
 								moduleId
 							);
 							break;
 						default:
 							// ignore requests in error states
 							break;
 					}
 				},
 		
 				// Management API
 				check: hotCheck,
 				apply: hotApply,
 				status: function (l) {
 					if (!l) return currentStatus;
 					registeredStatusHandlers.push(l);
 				},
 				addStatusHandler: function (l) {
 					registeredStatusHandlers.push(l);
 				},
 				removeStatusHandler: function (l) {
 					var idx = registeredStatusHandlers.indexOf(l);
 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
 				},
 		
 				//inherit from previous dispose call
 				data: currentModuleData[moduleId]
 			};
 			currentChildModule = undefined;
 			return hot;
 		}
 		
 		function setStatus(newStatus) {
 			currentStatus = newStatus;
 			var results = [];
 		
 			for (var i = 0; i < registeredStatusHandlers.length; i++)
 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
 		
 			return Promise.all(results);
 		}
 		
 		function trackBlockingPromise(promise) {
 			switch (currentStatus) {
 				case "ready":
 					setStatus("prepare");
 					blockingPromises.push(promise);
 					waitForBlockingPromises(function () {
 						return setStatus("ready");
 					});
 					return promise;
 				case "prepare":
 					blockingPromises.push(promise);
 					return promise;
 				default:
 					return promise;
 			}
 		}
 		
 		function waitForBlockingPromises(fn) {
 			if (blockingPromises.length === 0) return fn();
 			var blocker = blockingPromises;
 			blockingPromises = [];
 			return Promise.all(blocker).then(function () {
 				return waitForBlockingPromises(fn);
 			});
 		}
 		
 		function hotCheck(applyOnUpdate) {
 			if (currentStatus !== "idle") {
 				throw new Error("check() is only allowed in idle status");
 			}
 			return setStatus("check")
 				.then(__webpack_require__.hmrM)
 				.then(function (update) {
 					if (!update) {
 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
 							function () {
 								return null;
 							}
 						);
 					}
 		
 					return setStatus("prepare").then(function () {
 						var updatedModules = [];
 						blockingPromises = [];
 						currentUpdateApplyHandlers = [];
 		
 						return Promise.all(
 							Object.keys(__webpack_require__.hmrC).reduce(function (
 								promises,
 								key
 							) {
 								__webpack_require__.hmrC[key](
 									update.c,
 									update.r,
 									update.m,
 									promises,
 									currentUpdateApplyHandlers,
 									updatedModules
 								);
 								return promises;
 							},
 							[])
 						).then(function () {
 							return waitForBlockingPromises(function () {
 								if (applyOnUpdate) {
 									return internalApply(applyOnUpdate);
 								} else {
 									return setStatus("ready").then(function () {
 										return updatedModules;
 									});
 								}
 							});
 						});
 					});
 				});
 		}
 		
 		function hotApply(options) {
 			if (currentStatus !== "ready") {
 				return Promise.resolve().then(function () {
 					throw new Error("apply() is only allowed in ready status");
 				});
 			}
 			return internalApply(options);
 		}
 		
 		function internalApply(options) {
 			options = options || {};
 		
 			applyInvalidatedModules();
 		
 			var results = currentUpdateApplyHandlers.map(function (handler) {
 				return handler(options);
 			});
 			currentUpdateApplyHandlers = undefined;
 		
 			var errors = results
 				.map(function (r) {
 					return r.error;
 				})
 				.filter(Boolean);
 		
 			if (errors.length > 0) {
 				return setStatus("abort").then(function () {
 					throw errors[0];
 				});
 			}
 		
 			// Now in "dispose" phase
 			var disposePromise = setStatus("dispose");
 		
 			results.forEach(function (result) {
 				if (result.dispose) result.dispose();
 			});
 		
 			// Now in "apply" phase
 			var applyPromise = setStatus("apply");
 		
 			var error;
 			var reportError = function (err) {
 				if (!error) error = err;
 			};
 		
 			var outdatedModules = [];
 			results.forEach(function (result) {
 				if (result.apply) {
 					var modules = result.apply(reportError);
 					if (modules) {
 						for (var i = 0; i < modules.length; i++) {
 							outdatedModules.push(modules[i]);
 						}
 					}
 				}
 			});
 		
 			return Promise.all([disposePromise, applyPromise]).then(function () {
 				// handle errors in accept handlers and self accepted module load
 				if (error) {
 					return setStatus("fail").then(function () {
 						throw error;
 					});
 				}
 		
 				if (queuedInvalidatedModules) {
 					return internalApply(options).then(function (list) {
 						outdatedModules.forEach(function (moduleId) {
 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
 						});
 						return list;
 					});
 				}
 		
 				return setStatus("idle").then(function () {
 					return outdatedModules;
 				});
 			});
 		}
 		
 		function applyInvalidatedModules() {
 			if (queuedInvalidatedModules) {
 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
 					queuedInvalidatedModules.forEach(function (moduleId) {
 						__webpack_require__.hmrI[key](
 							moduleId,
 							currentUpdateApplyHandlers
 						);
 					});
 				});
 				queuedInvalidatedModules = undefined;
 				return true;
 			}
 		}
 	}();
 	
 	/* webpack/runtime/publicPath */
 	!function() {
 		var scriptUrl;
 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
 		var document = __webpack_require__.g.document;
 		if (!scriptUrl && document) {
 			if (document.currentScript)
 				scriptUrl = document.currentScript.src
 			if (!scriptUrl) {
 				var scripts = document.getElementsByTagName("script");
 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
 			}
 		}
 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
 		__webpack_require__.p = scriptUrl;
 	}();
 	
 	/* webpack/runtime/jsonp chunk loading */
 	!function() {
 		// no baseURI
 		
 		// object to store loaded and loading chunks
 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
 			"main": 0
 		};
 		
 		// no chunk on demand loading
 		
 		// no prefetching
 		
 		// no preloaded
 		
 		var currentUpdatedModulesList;
 		var waitingUpdateResolves = {};
 		function loadUpdateChunk(chunkId) {
 			return new Promise(function(resolve, reject) {
 				waitingUpdateResolves[chunkId] = resolve;
 				// start update chunk loading
 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
 				// create error before stack unwound to get useful stacktrace later
 				var error = new Error();
 				var loadingEnded = function(event) {
 					if(waitingUpdateResolves[chunkId]) {
 						waitingUpdateResolves[chunkId] = undefined
 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
 						var realSrc = event && event.target && event.target.src;
 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
 						error.name = 'ChunkLoadError';
 						error.type = errorType;
 						error.request = realSrc;
 						reject(error);
 					}
 				};
 				__webpack_require__.l(url, loadingEnded);
 			});
 		}
 		
 		self["webpackHotUpdate"] = function(chunkId, moreModules, runtime) {
 			for(var moduleId in moreModules) {
 				if(__webpack_require__.o(moreModules, moduleId)) {
 					currentUpdate[moduleId] = moreModules[moduleId];
 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
 				}
 			}
 			if(runtime) currentUpdateRuntime.push(runtime);
 			if(waitingUpdateResolves[chunkId]) {
 				waitingUpdateResolves[chunkId]();
 				waitingUpdateResolves[chunkId] = undefined;
 			}
 		};
 		
 		var currentUpdateChunks;
 		var currentUpdate;
 		var currentUpdateRemovedChunks;
 		var currentUpdateRuntime;
 		function applyHandler(options) {
 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
 			currentUpdateChunks = undefined;
 			function getAffectedModuleEffects(updateModuleId) {
 				var outdatedModules = [updateModuleId];
 				var outdatedDependencies = {};
 		
 				var queue = outdatedModules.map(function (id) {
 					return {
 						chain: [id],
 						id: id
 					};
 				});
 				while (queue.length > 0) {
 					var queueItem = queue.pop();
 					var moduleId = queueItem.id;
 					var chain = queueItem.chain;
 					var module = __webpack_require__.c[moduleId];
 					if (
 						!module ||
 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
 					)
 						continue;
 					if (module.hot._selfDeclined) {
 						return {
 							type: "self-declined",
 							chain: chain,
 							moduleId: moduleId
 						};
 					}
 					if (module.hot._main) {
 						return {
 							type: "unaccepted",
 							chain: chain,
 							moduleId: moduleId
 						};
 					}
 					for (var i = 0; i < module.parents.length; i++) {
 						var parentId = module.parents[i];
 						var parent = __webpack_require__.c[parentId];
 						if (!parent) continue;
 						if (parent.hot._declinedDependencies[moduleId]) {
 							return {
 								type: "declined",
 								chain: chain.concat([parentId]),
 								moduleId: moduleId,
 								parentId: parentId
 							};
 						}
 						if (outdatedModules.indexOf(parentId) !== -1) continue;
 						if (parent.hot._acceptedDependencies[moduleId]) {
 							if (!outdatedDependencies[parentId])
 								outdatedDependencies[parentId] = [];
 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
 							continue;
 						}
 						delete outdatedDependencies[parentId];
 						outdatedModules.push(parentId);
 						queue.push({
 							chain: chain.concat([parentId]),
 							id: parentId
 						});
 					}
 				}
 		
 				return {
 					type: "accepted",
 					moduleId: updateModuleId,
 					outdatedModules: outdatedModules,
 					outdatedDependencies: outdatedDependencies
 				};
 			}
 		
 			function addAllToSet(a, b) {
 				for (var i = 0; i < b.length; i++) {
 					var item = b[i];
 					if (a.indexOf(item) === -1) a.push(item);
 				}
 			}
 		
 			// at begin all updates modules are outdated
 			// the "outdated" status can propagate to parents if they don't accept the children
 			var outdatedDependencies = {};
 			var outdatedModules = [];
 			var appliedUpdate = {};
 		
 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
 				console.warn(
 					"[HMR] unexpected require(" + module.id + ") to disposed module"
 				);
 			};
 		
 			for (var moduleId in currentUpdate) {
 				if (__webpack_require__.o(currentUpdate, moduleId)) {
 					var newModuleFactory = currentUpdate[moduleId];
 					/** @type {TODO} */
 					var result;
 					if (newModuleFactory) {
 						result = getAffectedModuleEffects(moduleId);
 					} else {
 						result = {
 							type: "disposed",
 							moduleId: moduleId
 						};
 					}
 					/** @type {Error|false} */
 					var abortError = false;
 					var doApply = false;
 					var doDispose = false;
 					var chainInfo = "";
 					if (result.chain) {
 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
 					}
 					switch (result.type) {
 						case "self-declined":
 							if (options.onDeclined) options.onDeclined(result);
 							if (!options.ignoreDeclined)
 								abortError = new Error(
 									"Aborted because of self decline: " +
 										result.moduleId +
 										chainInfo
 								);
 							break;
 						case "declined":
 							if (options.onDeclined) options.onDeclined(result);
 							if (!options.ignoreDeclined)
 								abortError = new Error(
 									"Aborted because of declined dependency: " +
 										result.moduleId +
 										" in " +
 										result.parentId +
 										chainInfo
 								);
 							break;
 						case "unaccepted":
 							if (options.onUnaccepted) options.onUnaccepted(result);
 							if (!options.ignoreUnaccepted)
 								abortError = new Error(
 									"Aborted because " + moduleId + " is not accepted" + chainInfo
 								);
 							break;
 						case "accepted":
 							if (options.onAccepted) options.onAccepted(result);
 							doApply = true;
 							break;
 						case "disposed":
 							if (options.onDisposed) options.onDisposed(result);
 							doDispose = true;
 							break;
 						default:
 							throw new Error("Unexception type " + result.type);
 					}
 					if (abortError) {
 						return {
 							error: abortError
 						};
 					}
 					if (doApply) {
 						appliedUpdate[moduleId] = newModuleFactory;
 						addAllToSet(outdatedModules, result.outdatedModules);
 						for (moduleId in result.outdatedDependencies) {
 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
 								if (!outdatedDependencies[moduleId])
 									outdatedDependencies[moduleId] = [];
 								addAllToSet(
 									outdatedDependencies[moduleId],
 									result.outdatedDependencies[moduleId]
 								);
 							}
 						}
 					}
 					if (doDispose) {
 						addAllToSet(outdatedModules, [result.moduleId]);
 						appliedUpdate[moduleId] = warnUnexpectedRequire;
 					}
 				}
 			}
 			currentUpdate = undefined;
 		
 			// Store self accepted outdated modules to require them later by the module system
 			var outdatedSelfAcceptedModules = [];
 			for (var j = 0; j < outdatedModules.length; j++) {
 				var outdatedModuleId = outdatedModules[j];
 				var module = __webpack_require__.c[outdatedModuleId];
 				if (
 					module &&
 					(module.hot._selfAccepted || module.hot._main) &&
 					// removed self-accepted modules should not be required
 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
 					// when called invalidate self-accepting is not possible
 					!module.hot._selfInvalidated
 				) {
 					outdatedSelfAcceptedModules.push({
 						module: outdatedModuleId,
 						require: module.hot._requireSelf,
 						errorHandler: module.hot._selfAccepted
 					});
 				}
 			}
 		
 			var moduleOutdatedDependencies;
 		
 			return {
 				dispose: function () {
 					currentUpdateRemovedChunks.forEach(function (chunkId) {
 						delete installedChunks[chunkId];
 					});
 					currentUpdateRemovedChunks = undefined;
 		
 					var idx;
 					var queue = outdatedModules.slice();
 					while (queue.length > 0) {
 						var moduleId = queue.pop();
 						var module = __webpack_require__.c[moduleId];
 						if (!module) continue;
 		
 						var data = {};
 		
 						// Call dispose handlers
 						var disposeHandlers = module.hot._disposeHandlers;
 						for (j = 0; j < disposeHandlers.length; j++) {
 							disposeHandlers[j].call(null, data);
 						}
 						__webpack_require__.hmrD[moduleId] = data;
 		
 						// disable module (this disables requires from this module)
 						module.hot.active = false;
 		
 						// remove module from cache
 						delete __webpack_require__.c[moduleId];
 		
 						// when disposing there is no need to call dispose handler
 						delete outdatedDependencies[moduleId];
 		
 						// remove "parents" references from all children
 						for (j = 0; j < module.children.length; j++) {
 							var child = __webpack_require__.c[module.children[j]];
 							if (!child) continue;
 							idx = child.parents.indexOf(moduleId);
 							if (idx >= 0) {
 								child.parents.splice(idx, 1);
 							}
 						}
 					}
 		
 					// remove outdated dependency from module children
 					var dependency;
 					for (var outdatedModuleId in outdatedDependencies) {
 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
 							module = __webpack_require__.c[outdatedModuleId];
 							if (module) {
 								moduleOutdatedDependencies =
 									outdatedDependencies[outdatedModuleId];
 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
 									dependency = moduleOutdatedDependencies[j];
 									idx = module.children.indexOf(dependency);
 									if (idx >= 0) module.children.splice(idx, 1);
 								}
 							}
 						}
 					}
 				},
 				apply: function (reportError) {
 					// insert new code
 					for (var updateModuleId in appliedUpdate) {
 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
 						}
 					}
 		
 					// run new runtime modules
 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
 						currentUpdateRuntime[i](__webpack_require__);
 					}
 		
 					// call accept handlers
 					for (var outdatedModuleId in outdatedDependencies) {
 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
 							var module = __webpack_require__.c[outdatedModuleId];
 							if (module) {
 								moduleOutdatedDependencies =
 									outdatedDependencies[outdatedModuleId];
 								var callbacks = [];
 								var errorHandlers = [];
 								var dependenciesForCallbacks = [];
 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
 									var dependency = moduleOutdatedDependencies[j];
 									var acceptCallback =
 										module.hot._acceptedDependencies[dependency];
 									var errorHandler =
 										module.hot._acceptedErrorHandlers[dependency];
 									if (acceptCallback) {
 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
 										callbacks.push(acceptCallback);
 										errorHandlers.push(errorHandler);
 										dependenciesForCallbacks.push(dependency);
 									}
 								}
 								for (var k = 0; k < callbacks.length; k++) {
 									try {
 										callbacks[k].call(null, moduleOutdatedDependencies);
 									} catch (err) {
 										if (typeof errorHandlers[k] === "function") {
 											try {
 												errorHandlers[k](err, {
 													moduleId: outdatedModuleId,
 													dependencyId: dependenciesForCallbacks[k]
 												});
 											} catch (err2) {
 												if (options.onErrored) {
 													options.onErrored({
 														type: "accept-error-handler-errored",
 														moduleId: outdatedModuleId,
 														dependencyId: dependenciesForCallbacks[k],
 														error: err2,
 														originalError: err
 													});
 												}
 												if (!options.ignoreErrored) {
 													reportError(err2);
 													reportError(err);
 												}
 											}
 										} else {
 											if (options.onErrored) {
 												options.onErrored({
 													type: "accept-errored",
 													moduleId: outdatedModuleId,
 													dependencyId: dependenciesForCallbacks[k],
 													error: err
 												});
 											}
 											if (!options.ignoreErrored) {
 												reportError(err);
 											}
 										}
 									}
 								}
 							}
 						}
 					}
 		
 					// Load self accepted modules
 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
 						var item = outdatedSelfAcceptedModules[o];
 						var moduleId = item.module;
 						try {
 							item.require(moduleId);
 						} catch (err) {
 							if (typeof item.errorHandler === "function") {
 								try {
 									item.errorHandler(err, {
 										moduleId: moduleId,
 										module: __webpack_require__.c[moduleId]
 									});
 								} catch (err2) {
 									if (options.onErrored) {
 										options.onErrored({
 											type: "self-accept-error-handler-errored",
 											moduleId: moduleId,
 											error: err2,
 											originalError: err
 										});
 									}
 									if (!options.ignoreErrored) {
 										reportError(err2);
 										reportError(err);
 									}
 								}
 							} else {
 								if (options.onErrored) {
 									options.onErrored({
 										type: "self-accept-errored",
 										moduleId: moduleId,
 										error: err
 									});
 								}
 								if (!options.ignoreErrored) {
 									reportError(err);
 								}
 							}
 						}
 					}
 		
 					return outdatedModules;
 				}
 			};
 		}
 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
 			if (!currentUpdate) {
 				currentUpdate = {};
 				currentUpdateRuntime = [];
 				currentUpdateRemovedChunks = [];
 				applyHandlers.push(applyHandler);
 			}
 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
 			}
 		};
 		__webpack_require__.hmrC.jsonp = function (
 			chunkIds,
 			removedChunks,
 			removedModules,
 			promises,
 			applyHandlers,
 			updatedModulesList
 		) {
 			applyHandlers.push(applyHandler);
 			currentUpdateChunks = {};
 			currentUpdateRemovedChunks = removedChunks;
 			currentUpdate = removedModules.reduce(function (obj, key) {
 				obj[key] = false;
 				return obj;
 			}, {});
 			currentUpdateRuntime = [];
 			chunkIds.forEach(function (chunkId) {
 				if (
 					__webpack_require__.o(installedChunks, chunkId) &&
 					installedChunks[chunkId] !== undefined
 				) {
 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
 					currentUpdateChunks[chunkId] = true;
 				}
 			});
 			if (__webpack_require__.f) {
 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
 					if (
 						currentUpdateChunks &&
 						!__webpack_require__.o(currentUpdateChunks, chunkId) &&
 						__webpack_require__.o(installedChunks, chunkId) &&
 						installedChunks[chunkId] !== undefined
 					) {
 						promises.push(loadUpdateChunk(chunkId));
 						currentUpdateChunks[chunkId] = true;
 					}
 				};
 			}
 		};
 		
 		__webpack_require__.hmrM = function() {
 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then(function(response) {
 				if(response.status === 404) return; // no update available
 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
 				return response.json();
 			});
 		};
 		
 		// no on chunks loaded
 		
 		// no jsonp function
 	}();
 	
/************************************************************************/
 	
 	// module cache are used so entry inlining is disabled
 	// startup
 	// Load entry module and return exports
 	var __webpack_exports__ = __webpack_require__("./index.ts");
 	
 })()
;